<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Pr√©dio 3D ‚Äî viewer (cores herdadas da FVS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0d1117; color: #c9d1d9; font-family: system-ui, sans-serif; }
    #app { position: fixed; inset: 0; }
    canvas { display:block; }

    /* === HUD compacto no rodap√© === */
    #hud{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      z-index: 20;
      display: flex; flex-wrap: wrap;
      gap: 6px;
      align-items: center; justify-content: center;
      padding: 6px 8px;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      color: #fff;
      border-top: 1px solid #30363d;
      border-radius: 10px 10px 0 0;
      font-size: 13px;
    }
    #hud .row{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    #hud .handle{ display:flex; align-items:center; gap:8px; cursor:grab; user-select:none; }
    #hud .grabber{ width:40px; height:5px; border-radius:4px; background:#58606b; opacity:.85; margin-right:4px; }
    #hudToggle{
      border: 1px solid #30363d; background:#0d1117; color:#c9d1d9;
      border-radius: 8px; padding: 3px 6px; font-size: 12px; line-height:1;
    }

    /* sliders menores */
    #hud input[type="range"]{
      width: 120px;
      height: 4px;
    }
    @media (min-width: 900px){
      #hud{ flex-wrap:nowrap; padding:6px 8px; gap:8px; }
      #hud input[type="range"]{ width: 150px; }
      #hud button, #hud select, #hud label{ white-space:nowrap; }
    }

    /* colapsar: mostra s√≥ a linha de handle */
    #hud.collapsed .row:not(.handle){ display:none; }

    #hud { touch-action: pan-y; }
    #hud button, #hud input, #hud label { touch-action: manipulation; }

    /* === Bot√£o 2D (SVG) === */
    :root{
      --c-2d-off: #8b949e;
      --c-2d-on:  #ff3b30;
    }
    #btn2D.mode2d{
      display:inline-flex; align-items:center; justify-content:center;
      width:40px; height:40px;
      border:1px solid #30363d; border-radius:10px;
      background:#0d1117; color:var(--c-2d-off);
      cursor:pointer; user-select:none;
      transition: color .18s ease, box-shadow .18s ease, border-color .18s ease;
    }
    #btn2D.mode2d:hover{ border-color:#3a3f46; }
    #btn2D.mode2d.active{
      color:var(--c-2d-on);
      box-shadow: 0 0 0 2px rgba(255,59,48,.18), 0 4px 16px rgba(255,59,48,.25);
      border-color: rgba(255,59,48,.55);
    }
    #btn2D.mode2d svg{ width:28px; height:28px; }
    #btn2D.mode2d .badge{ fill:none; stroke:currentColor; stroke-width:2; opacity:.38; }
    #btn2D.mode2d .label{ fill:currentColor; font: 700 13px/1 system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial; }

    @media (min-width: 900px) {
      #hud { flex-wrap: nowrap; padding: 8px 10px; gap: 10px; }
      #hud input[type="range"] { width: 180px; }
      #hud button, #hud select, #hud label { white-space: nowrap; }
    }

    @media (prefers-reduced-motion: reduce) { #hud { transition: none; } }
    #hud { touch-action: pan-y; }
    #hudHandle { touch-action: none; }

    /* === Overlay 2D ocupando a tela toda === */
    #cards2d{
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 9;
      pointer-events: none;
      opacity: 0;
      overflow-x: hidden;
      overflow-y: auto;
    }

    /* Cada cart√£o posicionado por top/left absolutos */
    #cards2d .card{
      position: absolute;
      width: 120px; height: 72px;
      display: flex; align-items: center; justify-content: center;
      border-radius: 12px; border: 1px solid rgba(255,255,255,.18);
      background: rgba(34,40,53,.92); color: #e6eef7;
      box-shadow: 0 8px 24px rgba(0,0,0,.35);
      font: 12px/1.2 system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial;
      user-select: none; cursor: pointer; pointer-events: auto;
      transform: translate(-50%, -50%);
    }
    #cards2d .card .label{
      padding: .35rem .55rem; border-radius: 999px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
    }
    canvas { touch-action: none; }
    html, body { overscroll-behavior: none; }
  </style>
</head>
<body>
  <div id="app"><div id="cards2d"></div></div>

  <div id="hud">
    <div class="row handle" id="hudHandle">
      <div class="grabber" aria-hidden="true"></div>
      <span style="font-weight:600; flex:1;">Controles</span>
      <button id="hudToggle" aria-expanded="true" title="Recolher/Expandir">‚ñæ</button>
    </div>

    <div class="row">
      <button id="resetRot">üîÑ</button>
      <button id="recenter">üéØ</button>
    </div>
    <div class="row">
      <label for="opacity" title="Opacidade">üå´Ô∏è</label>
      <input id="opacity" type="range" min="0" max="100" value="100" />
    </div>
    <div class="row">
      <label for="explodeXY" title="Explodir XY">‚§¢</label>
      <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
    </div>
    <div class="row">
      <label for="explodeY" title="Explodir por piso (Y)">‚¨ÜÔ∏è</label>
      <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
      <button id="resetExplode">Reset</button>
    </div>
    <div class="row">
      <button id="btn2D" class="mode2d" title="Alternar visualiza√ß√£o 2D">
        <svg viewBox="0 0 48 48" aria-hidden="true" focusable="false">
          <circle class="badge" cx="24" cy="24" r="20"></circle>
          <text class="label" x="24" y="29" text-anchor="middle">2D</text>
        </svg>
      </button>
    </div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ====== Carrega o layout ======
    const LAYOUT_URL = './data/layout-3d.json';
    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // ====== Setup ======
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== √ìrbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();

    // ===== Gestos (pointer + tap detector) =====
    let activePointers = new Map();
    let dragging = false;
    let dragMode = 'orbit';
    let lastX = 0, lastY = 0;

    // Tap detector
    let tapState = { isDown:false, startX:0, startY:0, moved:false, multi:false, downAt:0 };
    const TAP_MOVE_THRESH = 6;   // px
    const TAP_TIME_MAX   = 600;  // ms

    const ptsArr   = () => Array.from(activePointers.values());
    const centroid = (pts)=>({ x: pts.reduce((a,p)=>a+p.x,0)/pts.length,
                               y: pts.reduce((a,p)=>a+p.y,0)/pts.length });
    const dist     = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);

    let gesture = null; // { startDist, startRadius, lastCentroid }

    function pointerDown3D(e){
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      renderer.domElement.setPointerCapture(e.pointerId);

      const pts = ptsArr();
      if (pts.length === 1){
        dragMode = (e.button === 2) ? 'pan' : 'orbit';
        dragging = true;
        lastX = e.clientX; lastY = e.clientY;
      } else if (pts.length === 2){
        dragging = false;
        const [p1,p2] = pts;
        gesture = {
          startDist:   dist(p1,p2),
          startRadius: radius,
          lastCentroid: centroid(pts)
        };
      }
      e.preventDefault();

      // tap tracking
      tapState.isDown = true;
      tapState.startX = e.clientX;
      tapState.startY = e.clientY;
      tapState.moved  = false;
      tapState.multi  = (pts.length >= 2);
      tapState.downAt = performance.now();
    }
    renderer.domElement.style.touchAction = 'none';

    function pointerMove3D(e){
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

      // tap tracking
      if (tapState.isDown) {
        const dx = e.clientX - tapState.startX;
        const dy = e.clientY - tapState.startY;
        if (Math.hypot(dx, dy) > TAP_MOVE_THRESH) tapState.moved = true;
      }

      const pts = ptsArr();

      // 1 apontador
      if (pts.length === 1 && dragging){
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        if (dragMode === 'orbit'){
          pivot.rotation.y += dx * 0.005;
          theta = pivot.rotation.y;
          phi   = clamp(phi - dy * 0.005, minPhi, maxPhi);
          updateCamera();
        } else {
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
          updateCamera();
        }
        e.preventDefault();
        return;
      }

      // 2 apontadores (pin√ßa + pan do centroide)
      if (pts.length === 2 && gesture){
        const c  = centroid(pts);
        const d  = dist(pts[0], pts[1]);

        if (gesture.startDist > 0){
          const scale = d / gesture.startDist;
          const newR  = gesture.startRadius / Math.max(0.2, Math.min(5, scale));
          radius = clamp(newR, minRadius, maxRadius);
        }

        const dx = c.x - gesture.lastCentroid.x;
        const dy = c.y - gesture.lastCentroid.y;
        if (dx || dy){
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
        }

        gesture.lastCentroid = c;
        updateCamera();
        e.preventDefault();
        return;
      }
    }

    function pointerUp3D(e){
      if (activePointers.has(e.pointerId)){
        try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
        activePointers.delete(e.pointerId);
      }
      const pts = ptsArr();
      if (pts.length === 0){ dragging = false; gesture = null; }
      if (pts.length < 2){ gesture = null; }
      e.preventDefault();
    }

    renderer.domElement.addEventListener('pointerdown',   pointerDown3D,   {passive:false});
    renderer.domElement.addEventListener('pointermove',   pointerMove3D,   {passive:false});
    renderer.domElement.addEventListener('pointerup',     pointerUp3D,     {passive:false});
    renderer.domElement.addEventListener('pointercancel', pointerUp3D,     {passive:false});

    // bloqueia menu do bot√£o direito (para pan no desktop)
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Scroll do mouse (zoom)
    renderer.domElement.addEventListener('wheel', e=>{
      e.preventDefault();
      const f = 1 + (e.deltaY>0 ? 0.1 : -0.1);
      radius = clamp(radius*f, minRadius, maxRadius);
      updateCamera();
    }, {passive:false});
    // ====== Materiais ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX = 0x6e7681;
    const MAT = {
      face: ()=> new THREE.MeshStandardMaterial({
        color: NEUTRAL_HEX,
        metalness: 0.05,
        roughness: 0.9,
        transparent: true,
        opacity: faceOpacity,
        depthWrite: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      }),
      line: new THREE.LineBasicMaterial({
        color: 0xcad7ff,
        linewidth: 1,
        depthTest: true,
        depthWrite: false,
        transparent: true,
        opacity: 0.95
      }),
      selLine: new THREE.LineBasicMaterial({
        color: 0xffc107,
        linewidth: 2
      })
    };

    function setFacesVisible(visible){
      for (const g of torre.children) g.userData.mesh.visible = visible;
    }

    // ===== Helpers de Opacidade (NOVOS) =====
    const MIN_OPACITY_2D = 0.03;

    function computeEffectiveOpacity(baseOpacity, t2d){
      return THREE.MathUtils.lerp(baseOpacity, MIN_OPACITY_2D, t2d || 0);
    }

    function applyOpacityToAllMeshes(effective){
      if (!torre) return;
      const isOpaque = effective >= 0.999;

      torre.traverse(n=>{
        if (!n.material || !n.isMesh) return;
        n.material.opacity = effective;
        if (isOpaque){
          n.material.transparent = false;
          n.material.depthWrite  = true;
        } else {
          n.material.transparent = true;
          n.material.depthWrite  = false;
        }
        n.material.needsUpdate = true;
      });
    }

    function applyEdgesFade(t2d){
      const lineEff = THREE.MathUtils.lerp(0.95, 0.08, t2d || 0);
      if (!torre) return;
      torre.traverse(n=>{
        if (!(n.isLine || n.isLineSegments) || !n.material) return;
        n.material.opacity     = lineEff;
        n.material.transparent = lineEff < 1;
        n.material.depthWrite  = !n.material.transparent;
        n.material.needsUpdate = true;
      });
    }

    // ===== Dimens√£o b√°sica em "mundo" =====
    const cellW = (layout.meta?.cellW ?? 1.2);
    const cellD = (layout.meta?.cellD ?? 1.2);
    const gap   = (layout.meta?.gap   ?? 0.15);

    const aptoHeight = 0.5;
    const stepX = cellW + gap;
    const stepZ = cellD + gap;
    const stepY = aptoHeight + gap;

    function rectCenterX(x, w){ return x*stepX + (w*cellW + (w-1)*gap)/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*cellD + (d-1)*gap)/2; }

    // ===== Explode =====
    let explodeXY = 0.0;
    let explodeY  = 0.0;

    function applyExplode(){
      if (!torre || torre.children.length === 0) return;

      if ((explodeXY === 0 || !Number.isFinite(explodeXY)) &&
          (explodeY  === 0 || !Number.isFinite(explodeY))) {
        for (const g of torre.children) g.position.copy(g.userData.basePos);
        return;
      }

      // Centroide dos anchors
      let sumX = 0, sumZ = 0, n = 0;
      for (const g of torre.children){
        const a = g.userData.anchor || g.userData.basePos;
        sumX += a.x; sumZ += a.z; n++;
      }
      const cx = n ? (sumX/n) : 0;
      const cz = n ? (sumZ/n) : 0;

      const step = Math.max(stepX, stepZ) || 1;

      for (const g of torre.children){
        const base = g.userData.basePos;
        const pos  = base.clone();

        if (explodeXY > 0){
          const a = g.userData.anchor || base;
          const dir = new THREE.Vector3(a.x - cx, 0, a.z - cz);
          const len = dir.length();
          if (len > 1e-6){
            dir.multiplyScalar(1/len);
            pos.addScaledVector(dir, explodeXY * step);
          }
        }

        if (explodeY !== 0){
          pos.y += (g.userData.levelIndex || 0) * explodeY;
        }

        g.position.copy(pos);
      }
    }

    // ===== Voxeliza√ß√£o por NOME =====
    function voxelizeByNome(l){
      const byNome = new Map();
      for (const p of (l.placements || [])){
        const nome = String(p.nome);
        if (!byNome.has(nome)) byNome.set(nome, new Set());
        const set = byNome.get(nome);
        const baseY = (typeof p.andar === 'number') ? p.andar : 0;
        for (let gx = p.x; gx < p.x + p.w; gx++){
          for (let gz = p.z; gz < p.z + p.d; gz++){
            for (let gy = baseY; gy < baseY + p.h; gy++){
              set.add(`${gx},${gy},${gz}`);
            }
          }
        }
      }
      return byNome;
    }

    // ===== Meshing de fronteira =====
    function buildSurfaceGeometryFromOcc(occSet){
      if (!occSet || occSet.size===0) return null;
      const has = (x,y,z)=> occSet.has(`${x},${y},${z}`);

      const pos = [];
      const idx = [];
      let vbase = 0;

      const pushQuad = (a,b,c,d)=>{
        pos.push( ...a, ...b, ...c, ...d );
        idx.push(vbase, vbase+1, vbase+2,  vbase, vbase+2, vbase+3);
        vbase += 4;
      };

      function voxelBounds(gx,gy,gz){
        const x0 = gx * stepX, x1 = x0 + cellW;
        const z0 = gz * stepZ, z1 = z0 + cellD;
        const y0 = gy * stepY, y1 = y0 + aptoHeight;
        return {x0,x1,y0,y1,z0,z1};
      }

      for (const key of occSet){
        const [gx,gy,gz] = key.split(',').map(Number);
        const {x0,x1,y0,y1,z0,z1} = voxelBounds(gx,gy,gz);

        if (!has(gx-1,gy,gz)) pushQuad([x0,y0,z1],[x0,y0,z0],[x0,y1,z0],[x0,y1,z1]); // -X
        if (!has(gx+1,gy,gz)) pushQuad([x1,y0,z0],[x1,y0,z1],[x1,y1,z1],[x1,y1,z0]); // +X
        if (!has(gx,gy,gz-1)) pushQuad([x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]); // -Z
        if (!has(gx,gy,gz+1)) pushQuad([x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]); // +Z
        if (!has(gx,gy-1,gz)) pushQuad([x0,y0,z0],[x1,y0,z0],[x1,y0,z1],[x0,y0,z1]); // -Y
        if (!has(gx,gy+1,gz)) pushQuad([x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]); // +Y
      }

      if (pos.length===0) return null;

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
      geom.setIndex(new THREE.Uint32BufferAttribute(new Uint32Array(idx), 1));
      geom.computeVertexNormals();
      geom.computeBoundingBox(); geom.computeBoundingSphere();
      return geom;
    }

    // ===== Inflar para desenhar edges limpas =====
    function inflateGeometry(geom, offset=0.04){
      const g = geom.clone();
      g.computeVertexNormals();
      const pos = g.getAttribute('position');
      const nor = g.getAttribute('normal');
      for (let i=0;i<pos.count;i++){
        pos.setX(i, pos.getX(i) + nor.getX(i)*offset);
        pos.setY(i, pos.getY(i) + nor.getY(i)*offset);
        pos.setZ(i, pos.getZ(i) + nor.getZ(i)*offset);
      }
      pos.needsUpdate = true;
      return g;
    }

    // ====== Constru√ß√£o ======
    function buildFromLayout(l){
      // 1) Metadados por NOME
      const aptMeta = new Map();
      if (l && Array.isArray(l.placements)){
        for (const p of l.placements){
          const id = String(p.nome);
          const m  = aptMeta.get(id) || {};
          m.name       = String(p.nome);
          if (p.ordemcol != null) m.ordemcol = Number(p.ordemcol);
          if (p.zindex  != null)  m.zIndex   = Number(p.zindex);
          if (p.floor   != null)  m.floor    = Number(p.floor);
          aptMeta.set(id, m);
        }
      }

      // limpa torre
      while (torre.children.length) torre.remove(torre.children[0]);

      // voxeliza por nome
      const occByNome = voxelizeByNome(l);
      for (const [nome, occ] of occByNome.entries()){
        const surface = buildSurfaceGeometryFromOcc(occ);
        if (!surface) continue;

        const faceMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x6e7681),
          metalness: 0.05,
          roughness: 0.9,
          transparent: faceOpacity < 0.999,
          opacity: Math.min(1, faceOpacity),
          depthWrite: faceOpacity >= 0.999,
          side: THREE.DoubleSide,
          polygonOffset: true,
          polygonOffsetFactor: 1,
          polygonOffsetUnits: 1
        });

        const mesh = new THREE.Mesh(surface, faceMat);
        mesh.renderOrder = 1;

        const inflated = inflateGeometry(surface, 0.04);
        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(inflated, 1), MAT.line);
        edges.renderOrder = 2;

        // pavimento m√≠nimo
        let minLevel = Infinity;
        for (const key of occ){
          const gy = parseInt(key.split(',')[1],10);
          if (gy < minLevel) minLevel = gy;
        }
        if (!Number.isFinite(minLevel)) minLevel = 0;

        const group = new THREE.Group();
        group.add(mesh); group.add(edges);

        const metaFromJson = aptMeta.get(String(nome)) || {};
        const idStr   = String(nome);
        const nameStr = metaFromJson.name || idStr;

        group.userData = {
          nome: idStr,
          mesh, edges,
          levelIndex: minLevel,
          basePos: new THREE.Vector3(0,0,0),
          anchor:  new THREE.Vector3(0,0,0),
          meta: {
            id: idStr,
            name: nameStr,
            ordemcol: (typeof metaFromJson.ordemcol === 'number') ? metaFromJson.ordemcol : undefined,
            zIndex:   (typeof metaFromJson.zIndex   === 'number') ? metaFromJson.zIndex   : undefined
          }
        };

        // centro local ‚Üí anchor
        surface.computeBoundingBox();
        const bb = surface.boundingBox;
        const localCenter = new THREE.Vector3();
        bb.getCenter(localCenter);
        group.__localCenter = localCenter;

        torre.add(group);
      }

      // Centraliza torre
      const bbox = new THREE.Box3().setFromObject(torre);
      const center = new THREE.Vector3(); bbox.getCenter(center);
      const size   = new THREE.Vector3(); bbox.getSize(size);

      for (const g of torre.children){
        g.position.sub(center);
        g.userData.basePos.copy(g.position);

        const lc = g.__localCenter || new THREE.Vector3();
        g.userData.anchor.set(
          g.position.x + lc.x,
          g.position.y + lc.y,
          g.position.z + lc.z
        );
        delete g.__localCenter;
      }

      // C√¢mera inicial
      const diag = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
      const idealRadius = Math.max(8, diag * 0.75);
      radius = clamp(idealRadius, minRadius, maxRadius);
      orbitTarget.set(0, 0, 0);
      updateCamera();

      applyExplode();
    }

    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }

    // metaByNome (se precisar no futuro)
    const metaByNome = new Map();
    for (const p of (layout.placements||[])){
      const key = String(p.nome);
      if (!metaByNome.has(key)){
        metaByNome.set(key, { ordemcol: (p.ordemcol|0) });
      }
    }

    buildFromLayout(layout);

    // ===== Sele√ß√£o com mira (tap real) =====
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function pickAtClientXY(clientX, clientY){
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

      // faces
      const faceObjects = torre.children.map(g => g.userData.mesh);
      raycaster.setFromCamera(mouse, camera);
      let inter = raycaster.intersectObjects(faceObjects, false);

      // fallback em arestas
      if (!inter.length) {
        const edgeObjects = torre.children.map(g => g.userData.edges);
        raycaster.params.Line = raycaster.params.Line || {};
        raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06;
        inter = raycaster.intersectObjects(edgeObjects, false);
      }

      // limpar sele√ß√£o anterior
      if (window.__SEL_GROUP__) {
        const gPrev = window.__SEL_GROUP__;
        gPrev.userData.edges.material = gPrev.__lineBackup;
        gPrev.userData.mesh.material = gPrev.__faceBackup;
        delete gPrev.__lineBackup; delete gPrev.__faceBackup;
        window.__SEL_GROUP__ = null;
      }

      if (!inter.length) return;

      const hitObj   = inter[0].object;
      const selGroup = hitObj.parent;
      if (!selGroup || !selGroup.userData) return;

      // Destaque visual
      selGroup.__lineBackup = selGroup.userData.edges.material;
      selGroup.__faceBackup = selGroup.userData.mesh.material.clone();
      selGroup.userData.edges.material = MAT.selLine;
      const faceClone = selGroup.userData.mesh.material.clone();
      faceClone.opacity = Math.min(1, faceOpacity + 0.2);
      selGroup.userData.mesh.material = faceClone;
      window.__SEL_GROUP__ = selGroup;

      // Mensagem para o parent
      const nomeId = String(selGroup.userData.nome || selGroup.userData?.meta?.id || '').trim();
      let hex = null;
      try { const c = selGroup.userData.mesh.material.color; if (c) hex = '#' + c.getHexString(); } catch(_){}
      try { parent.postMessage({ type: 'viewer:open-apt', apt: nomeId, color: hex }, '*'); } catch(_){}

      console.log('[viewer] tap nome:', nomeId);
    }

    // Tap ‚Äúreal‚Äù (bloqueia click fantasma)
    renderer.domElement.addEventListener('pointerup', (e) => {
      if (e.pointerType === 'mouse' && e.button === 2) return;

      const dt = performance.now() - tapState.downAt;
      const dx = e.clientX - tapState.startX;
      const dy = e.clientY - tapState.startY;
      const moved = Math.hypot(dx, dy) > TAP_MOVE_THRESH;

      const isTap = !tapState.multi && !moved && dt <= TAP_TIME_MAX;

      tapState.isDown = false;
      tapState.multi  = false;

      if (!isTap) return;
      pickAtClientXY(e.clientX, e.clientY);
    }, { passive:false });
    // ===== HUD / UI =====
    const hud  = document.getElementById('hud');
    const hudToggle = document.getElementById('hudToggle');
    const hudHandle = document.getElementById('hudHandle');

    hudToggle.addEventListener('click', () => {
      const collapsed = hud.classList.toggle('collapsed');
      hudToggle.textContent = collapsed ? '‚ñ¥' : '‚ñæ';
      hudToggle.setAttribute('aria-expanded', String(!collapsed));
    });

    // Gesto vertical simples: arrastar a al√ßa para recolher/expandir
    let hudDragId = null, hudStartY = 0, hudDy = 0;
    function hudPointerDown(e){
      hudDragId = e.pointerId;
      hudStartY = e.clientY; hudDy = 0;
      hudHandle.setPointerCapture(hudDragId);
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerMove(e){
      if (e.pointerId !== hudDragId) return;
      hudDy = e.clientY - hudStartY;
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerUp(e){
      if (e.pointerId !== hudDragId) return;
      if (hudDy > 30) {
        hud.classList.add('collapsed');
        hudToggle.textContent = '‚ñ¥';
        hudToggle.setAttribute('aria-expanded', 'false');
      } else if (hudDy < -30) {
        hud.classList.remove('collapsed');
        hudToggle.textContent = '‚ñæ';
        hudToggle.setAttribute('aria-expanded', 'true');
      }
      try { hudHandle.releasePointerCapture(hudDragId); } catch(_){}
      hudDragId = null; hudDy = 0;
      e.preventDefault(); e.stopPropagation();
    }
    hudHandle.addEventListener('pointerdown', hudPointerDown, {passive:false});
    hudHandle.addEventListener('pointermove', hudPointerMove, {passive:false});
    hudHandle.addEventListener('pointerup',   hudPointerUp,   {passive:false});
    hudHandle.addEventListener('pointercancel', hudPointerUp, {passive:false});

    hudHandle.addEventListener('click', (e) => {
      if (e.target === hudToggle) return;
      hudToggle.click();
    });

    // Opacidade (slider)
    const opacity = document.getElementById('opacity');
    opacity.addEventListener('input', () => {
      const v = Number(opacity.value) / 100;
      setFaceOpacity(v);
    });

    // Explodir XY
    const explodeXYRange = document.getElementById('explodeXY');
    explodeXYRange.addEventListener('input', () => {
      explodeXY = Number(explodeXYRange.value) || 0;
      applyExplode();
    });

    // Explodir Y (piso)
    const explodeYRange = document.getElementById('explodeY');
    explodeYRange.addEventListener('input', () => {
      explodeY = Number(explodeYRange.value) || 0;
      applyExplode();
    });

    // Reset explode (e 2D)
    document.getElementById('resetExplode').addEventListener('click', () => {
      explodeXY = 0; explodeY = 0;
      explodeXYRange.value = '0';
      explodeYRange.value  = '0';
      applyExplode();
    });

    // Reset rota√ß√£o
    document.getElementById('resetRot').addEventListener('click', () => {
      pivot.rotation.set(0,0,0);
      theta = 0;
      updateCamera();
    });

    // Recentrar
    document.getElementById('recenter').addEventListener('click', () => {
      recenterOrbitTarget();
      radius = INITIAL_RADIUS;
      phi = INITIAL_PHI;
      updateCamera();
    });

    // ===== Corre√ß√£o de Opacidade ‚Äî fun√ß√µes NOVAS/ALTERADAS =====
    function setFaceOpacity(op){
      faceOpacity = Math.max(0, Math.min(1, op));
      const eff = computeEffectiveOpacity(faceOpacity, flatten2D || 0);
      applyOpacityToAllMeshes(eff);
    }

    // ===== 2D Toggle / Transi√ß√£o =====
    let flatten2D = 0;
    const cards2d = document.getElementById('cards2d');

    function cacheBaseVisualsIfNeeded(){
      if (!torre || torre.userData.__dogeBaseCached) return;
      torre.userData.__dogeBaseCached = true;
      torre.userData.__baseScale = torre.scale.clone();

      torre.traverse(n=>{
        if (!n.material) return;
        if (n.isMesh && typeof n.userData.__baseOpacityMesh === 'undefined') {
          n.userData.__baseOpacityMesh =
            (typeof n.material.opacity === 'number') ? n.material.opacity : 1.0;
        }
        if ((n.isLine || n.isLineSegments) && typeof n.userData.__baseOpacityLine === 'undefined') {
          n.userData.__baseOpacityLine =
            (typeof n.material.opacity === 'number') ? n.material.opacity : 0.95;
        }
      });
    }

    function apply2DTransition(){
      if (!torre) return;
      cacheBaseVisualsIfNeeded();

      if (!__aptRoots || __aptRoots.length === 0) collectApartmentRoots();
      if (!__gridModel) prepareGridModel();
      if (!__cardsBuilt) build2DCards();

      const t = flatten2D;

      // 1) Escala
      const baseScale = torre.userData.__baseScale || new THREE.Vector3(1,1,1);
      const s = THREE.MathUtils.lerp(1.0, 0.50, t);
      torre.scale.set(baseScale.x * s, baseScale.y * s, baseScale.z * s);

      // 2) Opacidade unificada (sem disputar com slider)
      const eff = computeEffectiveOpacity(faceOpacity, t);
      applyOpacityToAllMeshes(eff);
      applyEdgesFade(t);

      // 3) Overlay 2D
      render2DCardsToScreen(t);

      // 4) Eventos
      if (renderer && renderer.domElement) {
        renderer.domElement.style.pointerEvents = (t >= 0.95) ? 'none' : 'auto';
      }
    }

    const btn2D = document.getElementById('btn2D');
    function update2DButtonVisual(){
      if (!btn2D) return;
      btn2D.classList.toggle('active', flatten2D >= 0.999);
    }

    function tweenFlatten2D(target, ms=280){
      const from = flatten2D;
      const to   = Math.max(0, Math.min(1, target));
      if (Math.abs(from - to) < 1e-4){ update2DButtonVisual(); return; }

      const start = performance.now();
      function step(now){
        const k = Math.min(1, (now - start) / ms);
        const eased = k < 0.5 ? 2*k*k : 1 - Math.pow(-2*k + 2, 2)/2;
        flatten2D = from + (to - from) * eased;
        apply2DTransition();

        if (k < 1) {
          requestAnimationFrame(step);
        } else {
          flatten2D = to;
          apply2DTransition();
          update2DButtonVisual();

          // Se voltou ao 3D, n√£o precisamos reescrever opacidades manualmente;
          // computeEffectiveOpacity j√° resolve com t=0.
        }
      }
      requestAnimationFrame(step);
    }

    if (btn2D){
      btn2D.addEventListener('click', ()=>{
        const going2D = flatten2D < 0.5;
        tweenFlatten2D(going2D ? 1 : 0);
      });
    }
    update2DButtonVisual();

    // Reset geral (explode + sair do 2D + opacidade consistente)
    const resetBtn = document.getElementById('resetExplode');
    if (resetBtn){
      resetBtn.addEventListener('click', ()=>{
        // 1) explode volta ao zero
        explodeXY = 0; explodeY = 0;
        const elExplodeXY = document.getElementById('explodeXY');
        const elExplodeY  = document.getElementById('explodeY');
        if (elExplodeXY) elExplodeXY.value = '0';
        if (elExplodeY)  elExplodeY.value  = '0';
        if (typeof applyExplode === 'function') applyExplode();

        // 2) sai do 2D com anima√ß√£o curta
        tweenFlatten2D(0, 220);

        // 3) restaura escala e re-aplica opacidade via helpers
        if (torre && torre.userData.__baseScale){
          torre.scale.copy(torre.userData.__baseScale);
        }
        const eff = computeEffectiveOpacity(faceOpacity, 0);
        applyOpacityToAllMeshes(eff);
        applyEdgesFade(0);
        delete torre.userData.__dogeBaseCached;

        // 4) oculta overlay 2D
        if (cards2d){
          cards2d.style.opacity = '0';
          cards2d.style.pointerEvents = 'none';
        }
        // 5) canvas 3D volta a receber eventos
        if (renderer && renderer.domElement) {
          renderer.domElement.style.pointerEvents = 'auto';
        }
        // 6) bot√£o
        update2DButtonVisual();
      });
    }

    // Inicializa opacidade conforme slider
    setFaceOpacity(Number(opacity.value)/100);
    setFacesVisible(true);
    // ================== [DOGE] Globais da grade 2D ==================
    let __aptRoots   = [];
    let __gridModel  = null;
    let __cardsBuilt = false;

    // Coleta de apartamentos
    function collectApartmentRoots(){
      __aptRoots = [];
      if (!torre) return;

      const seen = new Set();
      torre.updateMatrixWorld(true);

      const candidates = [];
      torre.traverse(n=>{
        if (n.type === 'Group' && typeof n.userData.levelIndex === 'number') candidates.push(n);
      });
      if (candidates.length === 0){
        for (const child of torre.children){
          if (child.isGroup) candidates.push(child);
        }
      }

      for (const root of candidates){
        if (seen.has(root.id)) continue;
        seen.add(root.id);

        const meta = root.userData.meta || (root.userData.meta = {});
        if (meta.floor == null){
          meta.floor = (typeof root.userData.levelIndex === 'number') ? root.userData.levelIndex : 0;
        }

        const ax = (root.userData.anchor && typeof root.userData.anchor.x === 'number')
                    ? root.userData.anchor.x : 0;
        meta.__anchorX = ax;

        if (!meta.id && root.userData.nome) meta.id = String(root.userData.nome);
        if (!meta.name) meta.name = meta.id || `apt-${root.id}`;

        if (!root.userData._base){
          root.userData._base = {
            pos: root.position.clone(),
            rot: root.rotation.clone(),
            scale: root.scale.clone()
          };
        }

        __aptRoots.push({ root, meta, base: root.userData._base });
      }
    }

    // Modelo da grade + cards
    function colorFor(meta){
      if (meta && meta.status && window.COLOR_MAP?.colors?.[meta.status]) return window.COLOR_MAP.colors[meta.status];
      if (meta && meta.color) return meta.color;
      return '#6e7681';
    }

    function prepareGridModel(){
      if (!__aptRoots || !__aptRoots.length) return;

      const hasOrdem = __aptRoots.some(A => Number.isFinite(Number(A.meta?.ordemcol)));
      if (hasOrdem){
        for (const A of __aptRoots){
          const col1 = Number(A.meta?.ordemcol);
          A.meta.__colIdx = Number.isFinite(col1) ? Math.max(0, Math.floor(col1 - 1)) : 0;
        }
      } else {
        const xs = __aptRoots.map(A => (typeof A.meta?.__anchorX === 'number') ? A.meta.__anchorX : 0);
        xs.sort((a,b)=>a-b);
        const COL_EPS = 0.001;
        const groups = [];
        for (const x of xs){
          const g = groups[groups.length-1];
          if (!g || Math.abs(x - g.center) > COL_EPS){
            groups.push({ center:x, values:[x] });
          } else {
            g.values.push(x);
            g.center = g.values.reduce((s,v)=>s+v,0)/g.values.length;
          }
        }
        function colIndexFor(x){
          if (groups.length === 0) return 0;
          let best = 0, bestD = Math.abs(x - groups[0].center);
          for (let i=1;i<groups.length;i++){
            const d = Math.abs(x - groups[i].center);
            if (d < bestD){ bestD = d; best = i; }
          }
          return best;
        }
        for (const A of __aptRoots){
          const x = (typeof A.meta?.__anchorX === 'number') ? A.meta.__anchorX : 0;
          A.meta.__colIdx = colIndexFor(x);
        }
      }

      const floors = new Set();
      const cols   = new Set();
      const map    = new Map();
      for (const A of __aptRoots){
        const f = Number(A.meta?.floor)   || 0;
        const c = Number(A.meta?.__colIdx)|| 0;
        floors.add(f); cols.add(c);
        const k = `${f}|${c}`;
        if (!map.has(k)) map.set(k, []);
        map.get(k).push(A);
      }

      const floorsArr = Array.from(floors).sort((a,b)=>b-a);
      const colsArr   = Array.from(cols).sort((a,b)=>a-b);

      for (const arr of map.values()){
        arr.sort((a,b)=>{
          const za = Number(a.meta?.zIndex || a.meta?.z || 0) || 0;
          const zb = Number(b.meta?.zIndex || b.meta?.z || 0) || 0;
          return za - zb;
        });
      }

      __gridModel = { floors: floorsArr, cols: colsArr, map };
    }

    function build2DCards(){
      if (!__aptRoots || !__aptRoots.length) return;
      if (!__gridModel) prepareGridModel();
      if (!__gridModel) return;

      cards2d.innerHTML = '';

      for (const A of __aptRoots){
        const el = document.createElement('div');
        el.className  = 'card';
        const idStr = A.meta?.id || A.meta?.name || A.root.userData.nome || '';
        el.dataset.id = idStr;

        // cor pela FVS (igual ao 3D)
        const piso = (A.meta?.floor ?? A.root.userData.levelIndex ?? 0);
        el.style.background = pickFVSColor(idStr, piso);

        const lab = document.createElement('div');
        lab.className = 'label';
        lab.textContent = A.meta?.name || A.meta?.id || 'apt';
        el.appendChild(lab);

        el.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          const aptId = String(A.meta?.id || A.meta?.name || '').trim();
          let hex = null;
          try {
            const c = (A.root?.userData?.mesh?.material?.color);
            if (c) hex = '#' + c.getHexString();
          } catch(_) {}
          try {
            parent.postMessage({ type: 'viewer:open-apt', apt: aptId, color: hex }, '*');
          } catch(_) {}
        });

        cards2d.appendChild(el);
        A.root.userData._cardEl = el;
      }
      __cardsBuilt = true;
    }

    function layout2D_computeMetrics(){
      const pad = 16;
      const W = window.innerWidth, H = window.innerHeight;
      const usableW = Math.max(320, W - pad*2);
      const usableH = Math.max(260, H - pad*2);

      const floorsCount = (__gridModel?.floors?.length || 1);
      const colsCount   = (__gridModel?.cols?.length   || 1);

      const CARD_RATIO = 120/72;
      const MIN_H = 40, MAX_H = 120;
      const V_GAP_MIN = 6, V_GAP_MAX = 14;
      const H_GAP_MIN = 10, H_GAP_MAX = 22;

      let cardH = Math.min(MAX_H, Math.floor(usableH / Math.max(1, floorsCount*0.9)));
      cardH = Math.max(MIN_H, cardH);
      let vGap = Math.min(V_GAP_MAX, Math.max(V_GAP_MIN, Math.floor(cardH*0.12)));

      const totalH = (h, gap) => floorsCount*h + Math.max(0, floorsCount-1)*gap;
      while (totalH(cardH, vGap) > usableH && cardH > MIN_H) cardH -= 1;
      while (totalH(cardH, vGap) > usableH && vGap  > V_GAP_MIN) vGap -= 1;

      const cardW = Math.floor(cardH * CARD_RATIO);
      let hGap = Math.min(H_GAP_MAX, Math.max(H_GAP_MIN, Math.floor(cardW*0.15)));

      const totalW = colsCount*cardW + Math.max(0, colsCount-1)*hGap;
      const originX = Math.floor((W - totalW)/2) + Math.floor(cardW/2);
      const totalHpx = totalH(cardH, vGap);
      const originY = Math.floor((H - totalHpx)/2) + Math.floor(cardH/2);

      return { cardW, cardH, vGap, hGap, originX, originY, floorsCount, colsCount };
    }

    function render2DCardsToScreen(tFade){
      if (!__gridModel) prepareGridModel();
      if (!__gridModel) return;
      if (!__cardsBuilt) build2DCards();

      const { floors, cols, map } = __gridModel;
      const rows    = floors.length;
      const colsLen = cols.length;
      if (!rows || !colsLen) return;

      const hud = document.getElementById('hud');
      const hudH = hud ? hud.offsetHeight : 0;

      const pane = cards2d;
      pane.style.position      = 'fixed';
      pane.style.top           = '0';
      pane.style.left          = '0';
      pane.style.right         = '0';
      pane.style.setProperty('bottom', `${hudH}px`, 'important');
      pane.style.opacity       = String(tFade);
      pane.style.pointerEvents = (tFade > 0) ? 'auto' : 'none';
      pane.style.display       = (tFade > 0 ? 'block' : 'none');
      pane.style.overflowY     = 'hidden';

      // for√ßa reflow
      pane.offsetHeight;
      const availW = Math.max(240, pane.clientWidth);
      const availH = Math.max(180, pane.clientHeight);

      const slotsPerFloor = floors.map(f=>{
        let m = 1;
        for (let i=0;i<colsLen;i++){
          const arr = map.get(`${f}|${cols[i]}`) || [];
          if (arr.length > m) m = arr.length;
        }
        return m;
      });
      const sumSlots = slotsPerFloor.reduce((s,v)=>s+v,0);

      const RATIO = 120/72;
      const MIN_W=44, MIN_H=18, MIN_FONT=8;

      let hGap = Math.max(8, Math.floor(availW * 0.012));
      let vGap = Math.max(6, Math.floor(availH * 0.012));

      let cardH = Math.floor((availH - Math.max(0, rows-1)*vGap) / Math.max(1, sumSlots));
      cardH = Math.max(MIN_H, cardH);
      let cardW = Math.max(MIN_W, Math.floor(cardH * RATIO));

      const totalW = () => colsLen*cardW + Math.max(0, colsLen-1)*hGap;
      const totalH = () => sumSlots*cardH + Math.max(0, rows-1)*vGap;

      let TW = totalW(), TH = totalH();
      if (TW > availW){
        const sx = availW / TW;
        cardW = Math.max(MIN_W, Math.floor(cardW * sx));
        hGap  = Math.max(6, Math.floor(hGap  * sx));
        TW = totalW(); TH = totalH();
      }

      let useScroll = false, guard = 400;
      while (TH > availH && guard-- > 0){
        if (vGap > 2) vGap -= 1;
        else if (cardH > MIN_H) cardH -= 1;
        else { useScroll = true; break; }
        TW = totalW(); TH = totalH();
      }
      pane.style.overflowY = useScroll ? 'auto' : 'hidden';

      const originX = Math.floor(availW/2);
      const padTop = 8;
      const originY = useScroll
        ? (padTop + Math.floor(cardH/2))
        : (Math.floor(availH/2 - TH/2) + Math.floor(cardH/2));

      const fontPx = Math.max(MIN_FONT, Math.round(Math.min(cardW, cardH) * 0.18));
      for (const A of __aptRoots){
        const el = A.root.userData?._cardEl;
        if (!el) continue;
        el.style.width     = `${cardW}px`;
        el.style.height    = `${cardH}px`;
        el.style.fontSize  = `${fontPx}px`;
        el.style.opacity   = String(0.15 + 0.85*tFade);
      }

      let cursorY = useScroll ? (originY - Math.floor(cardH/2)) : (originY - TH/2);
      for (let r=0; r<rows; r++){
        const f = floors[r];
        const bandH = slotsPerFloor[r] * cardH;
        const rowCenterY = cursorY + bandH/2;

        for (let cx=0; cx<colsLen; cx++){
          const key = `${f}|${cols[cx]}`;
          const arr = map.get(key) || [];
          const slots = Math.max(1, arr.length);

          const colCenterX = originX - (TW/2) + cx*(cardW + hGap) + cardW/2;
          const topBand = rowCenterY - (slots*cardH)/2;

          for (let k=0; k<arr.length; k++){
            const A = arr[k];
            const el = A.root.userData?._cardEl;
            if (!el) continue;

            const x = colCenterX;
            const y = topBand + cardH*(k + 0.5);

            el.style.left = `${x}px`;
            el.style.top  = `${y}px`;
          }
        }
        cursorY += bandH + (r < rows-1 ? vGap : 0);
      }

      if (useScroll) pane.scrollTop = 0;
    }

    (function watchHudAndRerender(){
      let lastHudH = -1;
      function tick(){
        const hud = document.getElementById('hud');
        const h = hud ? hud.offsetHeight : 0;
        if (flatten2D > 0 && h !== lastHudH){
          lastHudH = h;
          render2DCardsToScreen(flatten2D);
        }
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();

    function hide2DCards(){
      cards2d.style.opacity = '0';
      cards2d.style.pointerEvents = 'none';
    }

    // ===== Cores herdadas do 2D =====
    let COLOR_MAP = {
      default: '#6e7681',
      colors:  {},
      byFloor: {}
    };

    function doge_openDetails(aptoId, floorIdx){
      try {
        parent.postMessage({
          type: 'open-fvs-modal',
          payload: {
            aptoId: String(aptoId ?? ''),
            floorIdx: Number.isFinite(floorIdx) ? Number(floorIdx) : null
          }
        }, '*');
      } catch (_) {}

      if (typeof window.openAptModal === 'function') {
        window.openAptModal({ id: String(aptoId ?? ''), floor: floorIdx });
      }
    }

    function doge_decideAndOpen(aptoId, floorIdx){
      const idNorm = (aptoId != null) ? String(aptoId) : '';
      const hasApt = !!(COLOR_MAP.colors[idNorm] || COLOR_MAP.colors[normApto(idNorm)]);
      const hasFloor = !!COLOR_MAP.byFloor?.[String(floorIdx)];
      if (hasApt) {
        doge_openDetails(idNorm, null);
      } else if (hasFloor) {
        doge_openDetails(null, floorIdx);
      } else {
        doge_openDetails(idNorm, floorIdx);
      }
    }

    function normApto(s){
      if (s == null) return '';
      let t = String(s).trim().toUpperCase();
      t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
      t = t.replace(/[\s\-\._\/]/g, '');
      return t;
    }

    function pickFVSColor(aptoId, floorIdx){
      const hexA = COLOR_MAP.colors[aptoId] || COLOR_MAP.colors[normApto(aptoId)];
      if (hexA && /^#?[0-9a-f]{6}$/i.test(hexA)) return hexA.startsWith('#') ? hexA : '#'+hexA;

      const hexF = COLOR_MAP.byFloor[String(floorIdx)];
      if (hexF && /^#?[0-9a-f]{6}$/i.test(hexF)) return hexF.startsWith('#') ? hexF : '#'+hexF;

      const defHex = COLOR_MAP.default || '#6e7681';
      return defHex.startsWith('#') ? defHex : '#'+defHex;
    }

    // Recolor (ajustada para n√£o disputar opacidade)
    function recolorMeshes3D(){
      if (!torre) return;
      for (const g of torre.children){
        const nome  = g.userData.nome || g.userData.meta?.id || '';
        const floor = g.userData.levelIndex ?? 0;
        const hex   = pickFVSColor(nome, floor);

        const mat = g.userData.mesh.material;
        mat.color = new THREE.Color(hex);
        mat.needsUpdate = true;
      }
      // Reaplica opacidade efetiva ap√≥s recolorir
      const eff = computeEffectiveOpacity(faceOpacity, flatten2D || 0);
      applyOpacityToAllMeshes(eff);
    }

    function recolorCards2D(){
      if (!__aptRoots || !__aptRoots.length) return;
      for (const A of __aptRoots){
        const el = A.root.userData?._cardEl;
        if (!el) continue;
        const id   = A.meta?.id || A.meta?.name || A.root.userData.nome || '';
        const piso = (A.meta?.floor ?? A.root.userData.levelIndex ?? 0);
        el.style.background = pickFVSColor(id, piso);
      }
    }

    function setFVSColorMap(payload){
      if (!payload) return;
      COLOR_MAP = {
        default: payload.default || '#6e7681',
        colors:  payload.colors  || {},
        byFloor: payload.byFloor || {}
      };
      recolorMeshes3D();
      recolorCards2D();
    }

    window.addEventListener('message', (e)=>{
      const data = e.data || {};
      if (data.type === 'fvsColorMap') {
        setFVSColorMap(data.payload);
      }
    });
    try { parent.postMessage({ type: 'ready-3d' }, '*'); } catch(_) {}

    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      updateCamera();

      if (typeof flatten2D !== 'undefined' && flatten2D > 0 && typeof render2DCardsToScreen === 'function') {
        render2DCardsToScreen(flatten2D);
      }
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>