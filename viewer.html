<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Pr√©dio 3D viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0d1117; color: #c9d1d9; font-family: system-ui, sans-serif; }
    #app { position: fixed; inset: 0; }
    canvas { display:block; }

    /* === HUD (desktop por padr√É¬£o) === */
    #hud {
      position: fixed; left: 12px; top: 12px; padding: 10px 12px;
      background: rgba(0,0,0,.45); backdrop-filter: blur(6px);
      border: 1px solid #30363d; border-radius: 10px; font-size: 14px; z-index: 10;
      display: grid; gap: 8px; width: max-content;
      transition: transform .25s ease;
    }
    #hud .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .val { width: 3.6rem; text-align: right; display: inline-block; }
    button, label { user-select: none; }

    /* Al√É¬ßa (handle) e bot√É¬£o de toggle */
    #hud .handle { display:flex; align-items:center; gap:8px; cursor:grab; user-select:none; }
    #hud .grabber {
      width: 44px; height: 6px; border-radius: 4px;
      background: #58606b; opacity: .85;
      margin-right: 4px;
    }
    #hudToggle {
      border: 1px solid #30363d;
      background: #0d1117;
      color: #c9d1d9;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 13px;
      line-height: 1;
    }

    /* Estado recolhido (no mobile vira bottom sheet; no desktop, opcional) */
    #hud.collapsed { transform: translateY(0); } /* neutro no desktop */

    /* === Mobile: HUD como bottom sheet === */
    @media (max-width: 640px) {
      #hud {
        left: 0; right: 0; top: auto; bottom: 0;
        margin: 0 8px 8px;
        width: auto;
        border-radius: 12px;
        backdrop-filter: blur(8px);
        max-height: 65vh;
        overflow: auto;
        transform: translateY(0); /* expandido */
      }
      /* No mobile, recolhido = s√É¬≥ a √¢‚Ç¨≈ìal√É¬ßa√¢‚Ç¨¬ù vis√É¬≠vel (~40px) */
      #hud.collapsed {
        transform: translateY(calc(100% - 40px));
      }
    }

    /* Respeita usu√É¬°rios com movimento reduzido */
    @media (prefers-reduced-motion: reduce) {
      #hud { transition: none; }
    }

    /* O canvas deve receber todos os gestos (sem scroll/browser gestures) */
    canvas { touch-action: none; }

    /* O HUD pode rolar verticalmente, mas a al√É¬ßa n√É¬£o */
    #hud { touch-action: pan-y; }
    #hudHandle { touch-action: none; }

    /* ==== Camadas: canvas (0) < cards2d (9) < HUD (10) ==== */
#app canvas { position:absolute; inset:0; z-index:0; display:block; }
#cards2d .card{
  position:absolute; width:120px; height:72px;
  border-radius:10px; border:1px solid rgba(255,255,255,.18);
  background:rgba(34,40,53,.92); color:#e6eef7;
  font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto;
  box-shadow:0 8px 24px rgba(0,0,0,.35);
  display:flex; align-items:center; justify-content:center;
  user-select:none; cursor:pointer;
  transform:translate(-50%,-50%);
  opacity:0; transition:opacity .18s ease;
  pointer-events:auto; /* controlado pelo JS com base no t */
}
#cards2d .card .label{
  padding:.35rem .55rem; border-radius:999px;
  background:rgba(0,0,0,.25);
  border:1px solid rgba(255,255,255,.12);
}
  </style>
</head>
<body>
  <!-- ==== BLOCO DO CONTAINER 3D + OVERLAY 2D (SUBSTITUIR A LINHA 77) ==== -->
<div id="app" style="position:fixed; inset:0">
  <!-- O canvas do Three.js ser√° anexado aqui via JS (root.appendChild(renderer.domElement)) -->
  <!-- Overlay dos cards 2D clic√°veis -->
  <div id="cards2d" style="position:absolute; inset:0; z-index:9; pointer-events:none;"></div>
</div>
<!-- ==== FIM DO BLOCO ==== -->

  <div id="hud">
    <div class="row handle" id="hudHandle">
      <div class="grabber" aria-hidden="true"></div>
      <span style="font-weight:600; flex:1;">Controles</span>
      <button id="hudToggle" aria-expanded="true" title="Recolher/Expandir">‚ñæ</button>
    </div>
    <div class="row" id="dragHint">
      <b>Arraste</b> (esq = orbitar, dir = mover) ‚Ä¢ <b>Scroll</b> = zoom
    </div>
    <div class="row">
      <label><input id="wireOnly" type="checkbox" /> S√≥ arame</label>
      <button id="resetRot">üîÑ Resetar giro</button>
      <button id="recenter">üéØ Centralizar c√¢mera</button>
    </div>
    <div class="row">
      Opacidade: <input id="opacity" type="range" min="5" max="100" value="30" />
      <span id="opacityVal" class="val">0.30</span>
    </div>
<div class="row">
  Explodir XY: <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
  <span id="explodeXYVal" class="val">0.00</span>
</div>
<div class="row">
  Explodir Y (piso): <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
  <span id="explodeYVal" class="val">0.00</span>
</div>
<div class="row">
  2D (explode‚Üígrid): <input id="flatten2D" type="range" min="0" max="1" step="0.01" value="0" />
  <span id="flatten2DVal" class="val">0.00</span>
</div>
<div class="row">
  <button id="resetExplode">Reset</button>
</div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ====== Carrega o layout do repo ======
    const LAYOUT_URL = './data/layout-3d.json';
    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // ====== Setup ======
    const root = document.getElementById('app');
   // Overlay 2D (cards)
const cards2dRoot = document.getElementById('cards2d'); 
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== √É‚Äúrbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();


    // ===== √É‚Äúrbita + Pan (mouse) + Pin√É¬ßa (zoom) e 2 dedos (pan) √¢‚Ç¨‚Äù Pointer Events =====
    let activePointers = new Map();     // pointerId -> {x,y}
    let dragging = false;
    let dragMode = 'orbit';
    let lastX = 0, lastY = 0;

    const ptsArr   = () => Array.from(activePointers.values());
    const centroid = (pts)=>({ x: pts.reduce((a,p)=>a+p.x,0)/pts.length,
                               y: pts.reduce((a,p)=>a+p.y,0)/pts.length });
    const dist     = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);

    let gesture = null; // { startDist, startRadius, lastCentroid }

    function pointerDown3D(e){
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      renderer.domElement.setPointerCapture(e.pointerId);

      const pts = ptsArr();
      if (pts.length === 1){
        // 1 dedo / 1 mouse: ORBIT (bot√É¬£o direito do mouse = pan)
        dragMode = (e.button === 2) ? 'pan' : 'orbit';
        dragging = true;
        lastX = e.clientX; lastY = e.clientY;
      } else if (pts.length === 2){
        // 2 dedos: pin√É¬ßa + pan do centroide
        const [p1,p2] = pts;
        gesture = {
          startDist:   dist(p1,p2),
          startRadius: radius,
          lastCentroid: centroid(pts)
        };
      }
      e.preventDefault();
    }

    function pointerMove3D(e){
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

      const pts = ptsArr();

      // 1 apontador (mouse/1 dedo)
      if (pts.length === 1 && dragging){
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        if (dragMode === 'orbit'){
          pivot.rotation.y += dx * 0.005;
          theta = pivot.rotation.y;
          phi   = clamp(phi - dy * 0.005, minPhi, maxPhi);
          updateCamera();
        } else {
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
          updateCamera();
        }
        e.preventDefault();
        return;
      }

      // 2 apontadores (pin√É¬ßa para zoom + centroide para pan)
      if (pts.length === 2 && gesture){
        const c  = centroid(pts);
        const d  = dist(pts[0], pts[1]);

        if (gesture.startDist > 0){
          // afastar dedos afasta a c√É¬¢mera (zoom out)
          const scale = d / gesture.startDist;
          const newR  = gesture.startRadius / Math.max(0.2, Math.min(5, scale));
          radius = clamp(newR, minRadius, maxRadius);
        }

        const dx = c.x - gesture.lastCentroid.x;
        const dy = c.y - gesture.lastCentroid.y;
        if (dx || dy){
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
        }

        gesture.lastCentroid = c;
        updateCamera();
        e.preventDefault();
        return;
      }
    }

    function pointerUp3D(e){
      if (activePointers.has(e.pointerId)){
        try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
        activePointers.delete(e.pointerId);
      }
      const pts = ptsArr();
      if (pts.length === 0){ dragging = false; gesture = null; }
      if (pts.length < 2){ gesture = null; }
      e.preventDefault();
    }


    /* ===== [DOGE] Helper: reparent preservando world transform (sem SceneUtils) ===== */
function attachPreserveWorld(obj, newParent) {
  // Guarda a matrixWorld atual do objeto
  const oldWorld = obj.matrixWorld.clone();

  // Muda o parent
  newParent.add(obj);

  // newParent.matrixWorld^-1 * oldWorld = nova matrix local do obj
  const invParentWorld = new THREE.Matrix4().copy(newParent.matrixWorld).invert();
  const newLocal = new THREE.Matrix4().multiplyMatrices(invParentWorld, oldWorld);

  // Aplica no objeto e atualiza posi√ß√£o/rota√ß√£o/escala
  obj.matrix.copy(newLocal);
  obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
  obj.updateMatrixWorld(true);
}

/* ===== [DOGE] Coleta de ra√≠zes de apartamentos (mesh + contorno juntos) ===== */
let __dogeAptRoots = [];      // [{root, meta, base:{pos,rot,scale}}...]
let __doge2DTargetsBuilt = false;

function doge_collectApartmentRoots() {
  __dogeAptRoots = [];

  if (!torre) return;
  const seen = new Set();

  torre.updateMatrixWorld(true);

  torre.traverse(obj => {
    if (!obj) return;
    // meta pode estar em obj.userData.meta ou diretamente em userData
    const meta = (obj.userData && (obj.userData.meta || obj.userData)) || null;

    // consideramos "apartamento" quando encontrar um mesh com meta.floor/col
    if (obj.isMesh && meta && (meta.floor != null) && (meta.col != null)) {
      let root = obj;

      // Se o pai n√£o √© a torre, prefira mover o pai (inclui contornos/linhas)
      if (obj.parent && obj.parent !== torre) {
        root = obj.parent;
      } else {
        // Se est√° diretamente sob 'torre', verifique irm√£os de contorno
        const siblings = obj.parent ? obj.parent.children.slice() : [];
        const hasContourSibling = siblings.some(
          c => c !== obj && (c.isLine || c.isLineSegments || c.isPoints)
        );

        if (hasContourSibling) {
          // Cria wrapper e reparenta mesh + contornos mantendo world transform
          const wrap = new THREE.Group();
          wrap.name = `APT_WRAP_${meta.name || meta.id || ''}`;
          wrap.updateMatrixWorld(true);

          // Adiciona o wrapper sob a torre, posicionado exatamente no mundo
          torre.add(wrap);
          wrap.position.copy(new THREE.Vector3(0,0,0));
          wrap.quaternion.copy(new THREE.Quaternion());
          wrap.scale.set(1,1,1);
          wrap.updateMatrixWorld(true);

          // Move o mesh principal
          attachPreserveWorld(obj, wrap);

          // Move irm√£os de contorno (line/edges/points)
          siblings.forEach(n => {
            if (n === obj) return;
            if (n.isLine || n.isLineSegments || n.isPoints) {
              attachPreserveWorld(n, wrap);
            }
          });

          root = wrap;
        }
      }

      // Evita duplicados quando v√°rios filhos trazem a mesma meta/raiz
      if (seen.has(root.id)) return;
      seen.add(root.id);

      // Garante meta no root
      root.userData.meta = root.userData.meta || meta;

      // Base transform (uma vez)
      if (!root.userData._base) {
        root.userData._base = {
          pos: root.position.clone(),
          rot: root.rotation.clone(),
          scale: root.scale.clone()
        };
      }

      __dogeAptRoots.push({
        root,
        meta: root.userData.meta,
        base: root.userData._base,
        target2D: null // ser√° preenchido no buildTargets
      });
    }
  });
}


/* ===== [DOGE] Overlay 2D: cria√ß√£o/atualiza√ß√£o dos cards ===== */
/* ===== [DOGE] Overlay 2D: cria√ß√£o/atualiza√ß√£o dos cards ===== */
/* ===== [DOGE] Overlay 2D: cards clic√°veis ===== */
let __dogeCardsBuilt = false;

function doge_colorFor(meta){
  if (meta && meta.status && COLOR_MAP?.colors?.[meta.status]) return COLOR_MAP.colors[meta.status];
  if (meta && meta.color) return meta.color;
  return COLOR_MAP?.default || '#6e7681';
}

function doge_build2DCards(){
  if (!__doge2DTargetsBuilt) doge_build2DTargets();
  if (!__dogeAptRoots.length) return;

  cards2dRoot.innerHTML = '';
  for (const A of __dogeAptRoots){
    if (!A.target2D) continue;

    const el = document.createElement('div');
    el.className = 'card';
    el.dataset.id = A.meta?.id || A.meta?.name || '';
    el.style.background = doge_colorFor(A.meta);

    const lab = document.createElement('div');
    lab.className = 'label';
    lab.textContent = A.meta?.name || A.meta?.id || 'apt';
    el.appendChild(lab);

    el.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      openAptModal(A.meta);
    });

    cards2dRoot.appendChild(el);
    A.root.userData._cardEl = el;
  }
  __dogeCardsBuilt = true;
}

function doge_render2DCards(localT){
  if (!__doge2DTargetsBuilt) doge_build2DTargets();
  if (!__dogeCardsBuilt) doge_build2DCards();

  const interactive = (flatten2D >= 0.95);
  cards2dRoot.style.pointerEvents = interactive ? 'auto' : 'none';

  for (const A of __dogeAptRoots){
    const el = A.root.userData._cardEl;
    const tgt = A.target2D;
    if (!el || !tgt) continue;

    const screen = worldToScreen(new THREE.Vector3(tgt.x, tgt.y, 0));
    el.style.left = `${screen.x}px`;
    el.style.top  = `${screen.y}px`;

    el.style.opacity = String(0.1 + 0.9 * localT);
    el.style.background = doge_colorFor(A.meta);
  }
}

function doge_hide2DCards(){
  for (const A of __dogeAptRoots){
    if (A.root.userData._cardEl) A.root.userData._cardEl.style.opacity = '0';
  }
  cards2dRoot.style.pointerEvents = 'none';
}
      
    renderer.domElement.addEventListener('pointerdown',   pointerDown3D,   {passive:false});
    renderer.domElement.addEventListener('pointermove',   pointerMove3D,   {passive:false});
    renderer.domElement.addEventListener('pointerup',     pointerUp3D,     {passive:false});
    renderer.domElement.addEventListener('pointercancel', pointerUp3D,     {passive:false});

    // bloqueia menu do bot√É¬£o direito (para pan no desktop)
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Scroll do mouse (zoom)
    renderer.domElement.addEventListener('wheel', e=>{
      e.preventDefault();
      const f = 1 + (e.deltaY>0 ? 0.1 : -0.1);
      radius = clamp(radius*f, minRadius, maxRadius);
      updateCamera();
    }, {passive:false});

    // ====== Materiais com polygonOffset (linhas limpas, sem z-fighting) ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX = 0x6e7681;
    const MAT = {
      face: ()=> new THREE.MeshStandardMaterial({
        color: NEUTRAL_HEX,
        metalness: 0.05,
        roughness: 0.9,
        transparent: true,
        opacity: faceOpacity,
        depthWrite: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      }),
      line: new THREE.LineBasicMaterial({
        color: 0xcad7ff,
        linewidth: 1,
        depthTest: true,
        depthWrite: false,
        transparent: true,
        opacity: 0.95
      }),
      selLine: new THREE.LineBasicMaterial({
        color: 0xffc107,
        linewidth: 2
      })
    };

    function setFacesVisible(visible){
      for (const g of torre.children) g.userData.mesh.visible = visible;
    }

    function setFaceOpacity(op){
      faceOpacity = op;
      for (const g of torre.children){
        const m = g.userData.mesh.material;
        m.opacity = faceOpacity;

        if (faceOpacity >= 0.999) {
          m.transparent = false;
          m.depthWrite = true;
          m.opacity = 1.0;
        } else {
          m.transparent = true;
          m.depthWrite = false;
        }
        m.needsUpdate = true;
      }
    }

    // ===== Dimens√É¬£o b√É¬°sica em "mundo" =====
    const cellW = (layout.meta?.cellW ?? 1.2);
    const cellD = (layout.meta?.cellD ?? 1.2);
    const gap   = (layout.meta?.gap   ?? 0.15);

    const aptoHeight = 0.5;          // altura "unit√É¬°ria" por n√É¬≠vel
    const stepX = cellW + gap;
    const stepZ = cellD + gap;
    const stepY = aptoHeight + gap;

    function rectCenterX(x, w){ return x*stepX + (w*cellW + (w-1)*gap)/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*cellD + (d-1)*gap)/2; }

    // ===== Explode (√É¬∫nica fonte de verdade) =====
    let explodeXY = 0.0;
    let explodeY  = 0.0;
    let flatten2D = 0.0;   // NOVO
    function applyExplode(){
      if (!torre || torre.children.length === 0) return;

      if ((explodeXY === 0 || !Number.isFinite(explodeXY)) &&
          (explodeY  === 0 || !Number.isFinite(explodeY))) {
        for (const g of torre.children) g.position.copy(g.userData.basePos);
        return;
      }

      // Centroide dos anchors
      let sumX = 0, sumZ = 0, n = 0;
      for (const g of torre.children){
        const a = g.userData.anchor || g.userData.basePos;
        sumX += a.x; sumZ += a.z; n++;
      }
      const cx = n ? (sumX/n) : 0;
      const cz = n ? (sumZ/n) : 0;

      const step = Math.max(stepX, stepZ) || 1;

      for (const g of torre.children){
        const base = g.userData.basePos;
        const pos  = base.clone();

        if (explodeXY > 0){
          const a = g.userData.anchor || base;
          const dir = new THREE.Vector3(a.x - cx, 0, a.z - cz);
          const len = dir.length();
          if (len > 1e-6){
            dir.multiplyScalar(1/len);
            pos.addScaledVector(dir, explodeXY * step);
          }
        }

        if (explodeY !== 0){
          pos.y += (g.userData.levelIndex || 0) * explodeY;
        }

        g.position.copy(pos);
      }
    }

    /* ===== [DOGE] Alvos 2D (grade por pavimento√ócoluna, faixas por zIndex) ===== */
//let __doge2DTargetsBuilt = false;

/* ===== [DOGE] Alvos 2D no plano frontal (linhas = pavimentos; colunas = fachadas; faixas = z) ===== */
function doge_build2DTargets() {
  if (!__dogeAptRoots.length) doge_collectApartmentRoots();
  if (!__dogeAptRoots.length) return;

  // Agrupa por c√©lula (floor|col)
  const byCell = new Map();
  let maxFloor = 0, maxCol = 0;

  for (const a of __dogeAptRoots) {
    const meta = a.meta || {};
    const floor = Number(meta.floor) || 1;
    const col   = Number(meta.col)   || 1;
    const zIdx  = Number(meta.zIndex || meta.z || 0) || 0;

    maxFloor = Math.max(maxFloor, floor);
    maxCol   = Math.max(maxCol,   col);

    const k = `${floor}|${col}`;
    if (!byCell.has(k)) byCell.set(k, []);
    byCell.get(k).push({ a, zIdx });
  }

  // Ordena por profundidade (zIndex)
  for (const arr of byCell.values()) {
    arr.sort((x,y)=> x.zIdx - y.zIdx);
  }

  // Par√¢metros visuais do grid
  const cellW = 140, cardW = 100, cardH = 60, cellH = 95;
  const marginX = -((maxCol - 1) * cellW) / 2;
  const marginY =  ((maxFloor) * cellH) / 2;

  for (const [key, arr] of byCell) {
    const [fStr, cStr] = key.split('|');
    const floor = +fStr, col = +cStr;
    const slots = arr.length;

    const baseX = marginX + (col - 1) * cellW;
    const baseY = marginY - (floor - 1) * cellH;
    const stripeH = cardH / Math.max(1, slots);

    arr.forEach((entry, idx) => {
      const A = entry.a;
      const stripeCenterY = baseY - cardH/2 + idx*stripeH + stripeH/2;

      A.target2D = {
        x: baseX,
        y: stripeCenterY,
        z: 0,
        w: cardW,
        h: stripeH,
        slots,
        stripeIndex: idx
      };

      // tamb√©m grava no root para f√°cil acesso
      A.root.userData.target2D = A.target2D;
    });
  }

  __doge2DTargetsBuilt = true;
}

    // ===== 3D ‚Üí 2D (explode‚Üíflatten‚Üígrid) ‚Äî STUB =====

    // ===== [DOGE] 3D ‚Üí 2D (0..0.5 explodeZ ; 0.5..1 flatten+grid) =====
 // ===== [DOGE] 3D ‚Üí 2D (0..0.5 explodeZ ; 0.5..1 flatten+grid + overlay cards) =====
// ===== [DOGE] 3D ‚Üí 2D (explodeZ ‚Üí flatten/grid) + c√¢mera frontal =====
function apply2DTransition() {
  const t = flatten2D || 0;
  const phase = (t <= 0.5) ? 0 : 1;
  const local = (phase === 0) ? (t / 0.5) : ((t - 0.5) / 0.5);

  if (!torre) return;

  // Inicializa√ß√µes √∫nicas
  if (!__dogeAptRoots.length) doge_collectApartmentRoots();
  if (!__doge2DTargetsBuilt) doge_build2DTargets();

  // snapshot de c√¢mera no momento que o usu√°rio sai de 0
  if (t > 0 && !__camSnap) {
    doge_snapshotCamera();
    doge_computeFrontPose();
  }
  // tween da c√¢mera: 0‚Üífrente
  if (t > 0) {
    doge_tweenCamera(THREE.MathUtils.smoothstep(t, 0, 1));
  } else {
    // t == 0: garante estado original
    if (__camSnap && camera && controls) {
      camera.position.copy(__camSnap.pos);
      controls.target.copy(__camSnap.target);
      camera.updateProjectionMatrix();
      controls.update();
    }
    __camSnap = null;
    __camFront = null;
  }

  // Controles de intera√ß√£o
  if (controls) {
    controls.enableRotate = (t === 0);  // trava rota√ß√£o no 2D
    controls.enablePan    = true;
    controls.enableZoom   = true;
  }

  // Movimenta√ß√£o dos apartamentos (mover raiz!)
  for (const A of __dogeAptRoots) {
    const root = A.root;
    const base = A.base;
    const meta = A.meta || {};
    const zIndex = Number(meta.zIndex || meta.z || 0) || 0;

    const Bpos = base.pos.clone();
    Bpos.z += (zIndex * -120);

    if (phase === 0) {
      // A ‚Üí B (explodeZ)
      root.position.lerpVectors(base.pos, Bpos, local);
      const sZ = THREE.MathUtils.lerp(base.scale.z, base.scale.z * 0.85, local);
      root.scale.set(base.scale.x, base.scale.y, sZ);

      // meshes s√≥lidos
      root.traverse(n=>{
        if (n.isMesh && n.material && 'opacity' in n.material) {
          n.material.transparent = true;
          n.material.opacity = 1.0;
        }
      });

    } else {
      // B ‚Üí C (grid 2D)
      const tgt = A.target2D;
      const Cpos = tgt ? new THREE.Vector3(tgt.x, tgt.y, 0) : Bpos;

      root.position.lerpVectors(Bpos, Cpos, local);

      const scaleZ = THREE.MathUtils.lerp(base.scale.z * 0.85, 0.05, local);
      const scaleX = THREE.MathUtils.lerp(base.scale.x, 1.0, local);
      const scaleY = THREE.MathUtils.lerp(base.scale.y, 1.0, local);
      root.scale.set(scaleX, scaleY, scaleZ);

      // crossfade leve nos meshes
      root.traverse(n=>{
        if (n.isMesh && n.material && 'opacity' in n.material) {
          n.material.transparent = true;
          n.material.opacity = THREE.MathUtils.lerp(1.0, 0.35, local);
        }
      });
    }
  }

  // Overlay de cards
  if (phase === 1) {
    if (!__dogeCardsBuilt) doge_build2DCards();
    doge_render2DCards(local);
  } else {
    doge_hide2DCards();
  }

  // Pointer events (canvas x overlay)
  if (renderer && renderer.domElement) {
    renderer.domElement.style.pointerEvents = (t >= 0.95) ? 'none' : 'auto';
  }
}



    /* ===== [DOGE] Tween de c√¢mera: snapshot ‚Üî frente ===== */
let __camSnap = null;   // {pos, target}
let __camFront = null;  // {pos, target}

function doge_snapshotCamera(){
  if (!camera || !controls) return;
  __camSnap = {
    pos: camera.position.clone(),
    target: controls.target.clone()
  };
}

function doge_computeFrontPose(){
  if (!torre || !controls) return;
  // calcula o bounding box do pr√©dio para centralizar
  const box = new THREE.Box3().setFromObject(torre);
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);

  // dist√¢ncia para caber na tela (aproxima√ß√£o)
  const fitWidth = size.x * 0.6;
  const dist = fitWidth / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
  const pos = new THREE.Vector3(center.x, center.y, center.z + dist + size.z*0.5);

  __camFront = {
    pos, target: center.clone()
  };
}

function doge_tweenCamera(t01){
  // t01: 0 = snapshot original; 1 = frontal
  if (!__camSnap || !__camFront || !camera || !controls) return;

  camera.position.lerpVectors(__camSnap.pos, __camFront.pos, t01);
  controls.target.lerpVectors(__camSnap.target, __camFront.target, t01);
  camera.updateProjectionMatrix();
  controls.update();
}

    // ===== Voxeliza√É¬ß√É¬£o por APTO =====
    function voxelizeByApto(l){
      const byApto = new Map();
      for (const p of l.placements){
        const apt = String(p.apto);
        if (!byApto.has(apt)) byApto.set(apt, new Set());
        const set = byApto.get(apt);
        const baseY = (typeof p.andar === 'number') ? p.andar : 0; // 'AT' => 0
        for (let gx = p.x; gx < p.x + p.w; gx++){
          for (let gz = p.z; gz < p.z + p.d; gz++){
            for (let gy = baseY; gy < baseY + p.h; gy++){
              set.add(`${gx},${gy},${gz}`);
            }
          }
        }
      }
      return byApto;
    }

    // ===== Meshing de fronteira (sem faces internas) =====
    function buildSurfaceGeometryFromOcc(occSet){
      if (!occSet || occSet.size===0) return null;
      const has = (x,y,z)=> occSet.has(`${x},${y},${z}`);

      const pos = [];
      const idx = [];
      let vbase = 0;

      const pushQuad = (a,b,c,d)=>{
        pos.push( ...a, ...b, ...c, ...d );
        idx.push(vbase, vbase+1, vbase+2,  vbase, vbase+2, vbase+3);
        vbase += 4;
      };

      function voxelBounds(gx,gy,gz){
        const x0 = gx * stepX, x1 = x0 + cellW;
        const z0 = gz * stepZ, z1 = z0 + cellD;
        const y0 = gy * stepY, y1 = y0 + aptoHeight;
        return {x0,x1,y0,y1,z0,z1};
      }

      for (const key of occSet){
        const [gx,gy,gz] = key.split(',').map(Number);
        const {x0,x1,y0,y1,z0,z1} = voxelBounds(gx,gy,gz);

        if (!has(gx-1,gy,gz)) pushQuad([x0,y0,z1],[x0,y0,z0],[x0,y1,z0],[x0,y1,z1]); // -X
        if (!has(gx+1,gy,gz)) pushQuad([x1,y0,z0],[x1,y0,z1],[x1,y1,z1],[x1,y1,z0]); // +X
        if (!has(gx,gy,gz-1)) pushQuad([x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]); // -Z
        if (!has(gx,gy,gz+1)) pushQuad([x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]); // +Z
        if (!has(gx,gy-1,gz)) pushQuad([x0,y0,z0],[x1,y0,z0],[x1,y0,z1],[x0,y0,z1]); // -Y
        if (!has(gx,gy+1,gz)) pushQuad([x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]); // +Y
      }

      if (pos.length===0) return null;

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
      geom.setIndex(new THREE.Uint32BufferAttribute(new Uint32Array(idx), 1));
      geom.computeVertexNormals();
      geom.computeBoundingBox(); geom.computeBoundingSphere();
      return geom;
    }

    // ===== Inflar para desenhar edges limpas =====
    function inflateGeometry(geom, offset=0.04){
      const g = geom.clone();
      g.computeVertexNormals();
      const pos = g.getAttribute('position');
      const nor = g.getAttribute('normal');
      for (let i=0;i<pos.count;i++){
        pos.setX(i, pos.getX(i) + nor.getX(i)*offset);
        pos.setY(i, pos.getY(i) + nor.getY(i)*offset);
        pos.setZ(i, pos.getZ(i) + nor.getZ(i)*offset);
      }
      pos.needsUpdate = true;
      return g;
    }

    // ====== Constru√É¬ß√É¬£o ======
    function buildFromLayout(l){
      // limpa torre
      while (torre.children.length) torre.remove(torre.children[0]);

      // voxeliza por apartamento
      const occByApto = voxelizeByApto(l);

      for (const [apto, occ] of occByApto.entries()){
        const surface = buildSurfaceGeometryFromOcc(occ);
        if (!surface) continue;

        // material neutro (cores vir√É¬£o do FVS; opacidade coerente)
        const faceMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x6e7681),
          metalness: 0.05,
          roughness: 0.9,
          transparent: faceOpacity < 0.999,
          opacity: Math.min(1, faceOpacity),
          depthWrite: faceOpacity >= 0.999,
          side: THREE.DoubleSide,   // preenche laterais
          polygonOffset: true,
          polygonOffsetFactor: 1,
          polygonOffsetUnits: 1
        });

        const mesh = new THREE.Mesh(surface, faceMat);
        mesh.renderOrder = 1;

        // contorno limpo
        const inflated = inflateGeometry(surface, 0.04);
        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(inflated, 1), MAT.line);
        edges.renderOrder = 2;

        // pavimento m√É¬≠nimo (explodeY)
        let minLevel = Infinity;
        for (const key of occ){
          const gy = parseInt(key.split(',')[1],10);
          if (gy < minLevel) minLevel = gy;
        }
        if (!Number.isFinite(minLevel)) minLevel = 0;

        const group = new THREE.Group();
        group.add(mesh); group.add(edges);
        group.position.set(0,0,0);

        // guardaremos basePos e anchor ap√É¬≥s centralizar tudo
        group.userData = {
          apto: String(apto),
          mesh, edges,
          levelIndex: minLevel,
          basePos: new THREE.Vector3(0,0,0),
          anchor:  new THREE.Vector3(0,0,0)
        };

        // centro local do geometry (para anchor depois)
        surface.computeBoundingBox();
        const bb = surface.boundingBox;
        const localCenter = new THREE.Vector3();
        bb.getCenter(localCenter);
        group.__localCenter = localCenter;

        torre.add(group);
      }

      // Centraliza todo o conjunto no (0,0,0)
      const bbox = new THREE.Box3().setFromObject(torre);
      const center = new THREE.Vector3(); bbox.getCenter(center);
      const size   = new THREE.Vector3(); bbox.getSize(size);

      for (const g of torre.children){
        g.position.sub(center);
        g.userData.basePos.copy(g.position);

        // anchor = centro do apto em mundo colado
        const lc = g.__localCenter || new THREE.Vector3();
        g.userData.anchor.set(
          g.position.x + lc.x,
          g.position.y + lc.y,
          g.position.z + lc.z
        );
        delete g.__localCenter;
      }

      // C√É¬¢mera inicial baseada no tamanho real
      const diag = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
      const idealRadius = Math.max(8, diag * 0.75);
      radius = clamp(idealRadius, minRadius, maxRadius);

      orbitTarget.set(0, 0, 0);
      updateCamera();

      // Aplica estado atual do explode (zero √¢‚Ä†‚Äô colado)
      applyExplode();
    }

    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }

    buildFromLayout(layout);

    // ====== Sele√É¬ß√É¬£o com mira refinada ======
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      // 1) faces
      const faceObjects = torre.children.map(g => g.userData.mesh);
      raycaster.setFromCamera(mouse, camera);
      let inter = raycaster.intersectObjects(faceObjects, false);

      // 2) fallback em arestas
      if (!inter.length) {
        const edgeObjects = torre.children.map(g => g.userData.edges);
        raycaster.params.Line = raycaster.params.Line || {};
        raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06;
        inter = raycaster.intersectObjects(edgeObjects, false);
      }

      // limpar sele√É¬ß√É¬£o anterior
      if (window.__SEL_GROUP__) {
        const gPrev = window.__SEL_GROUP__;
        gPrev.userData.edges.material = gPrev.__lineBackup;
        gPrev.userData.mesh.material = gPrev.__faceBackup;
        delete gPrev.__lineBackup; delete gPrev.__faceBackup;
        window.__SEL_GROUP__ = null;
      }

      if (inter.length) {
        const hitObj = inter[0].object;
        const selGroup = hitObj.parent;
        if (selGroup && selGroup.userData) {
          selGroup.__lineBackup = selGroup.userData.edges.material;
          selGroup.__faceBackup = selGroup.userData.mesh.material.clone();

          selGroup.userData.edges.material = MAT.selLine;

          const faceClone = selGroup.userData.mesh.material.clone();
          faceClone.opacity = Math.min(1, faceOpacity + 0.2);
          selGroup.userData.mesh.material = faceClone;

          window.__SEL_GROUP__ = selGroup;
          console.log('Selecionado:', selGroup.userData.apto);
        }
      }
    });

    // ====== HUD / UI ======
    const hud       = document.getElementById('hud');
    const hudToggle = document.getElementById('hudToggle');
    const hudHandle = document.getElementById('hudHandle');

    hudToggle.addEventListener('click', () => {
      const collapsed = hud.classList.toggle('collapsed');
      hudToggle.textContent = collapsed ? '‚ñ¥' : '‚ñæ';
      hudToggle.setAttribute('aria-expanded', String(!collapsed));
    });

    // Gesto vertical simples: arrastar a al√É¬ßa para recolher/expandir
    let hudDragId = null, hudStartY = 0, hudDy = 0;
    function hudPointerDown(e){
      hudDragId = e.pointerId;
      hudStartY = e.clientY; hudDy = 0;
      hudHandle.setPointerCapture(hudDragId);
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerMove(e){
      if (e.pointerId !== hudDragId) return;
      hudDy = e.clientY - hudStartY;
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerUp(e){
      if (e.pointerId !== hudDragId) return;
      if (hudDy > 30) {
        hud.classList.add('collapsed');
        hudToggle.textContent = '√¢‚Äì¬¥';
        hudToggle.setAttribute('aria-expanded', 'false');
      } else if (hudDy < -30) {
        hud.classList.remove('collapsed');
        hudToggle.textContent = '√¢‚Äì¬æ';
        hudToggle.setAttribute('aria-expanded', 'true');
      }
      try { hudHandle.releasePointerCapture(hudDragId); } catch(_){}
      hudDragId = null; hudDy = 0;
      e.preventDefault(); e.stopPropagation();
    }
    hudHandle.addEventListener('pointerdown', hudPointerDown, {passive:false});
    hudHandle.addEventListener('pointermove', hudPointerMove, {passive:false});
    hudHandle.addEventListener('pointerup',   hudPointerUp,   {passive:false});
    hudHandle.addEventListener('pointercancel', hudPointerUp, {passive:false});

    // Clique na al√É¬ßa alterna (bom no desktop)
    hudHandle.addEventListener('click', (e) => {
      if (e.target === hudToggle) return;
      hudToggle.click();
    });

    document.getElementById('wireOnly').addEventListener('change', (e) => setFacesVisible(!e.target.checked));

    const opacity = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    opacity.addEventListener('input', () => {
      const v = Number(opacity.value) / 100;
      opacityVal.textContent = v.toFixed(2);
      setFaceOpacity(v);
    });

    const explodeXYRange = document.getElementById('explodeXY');
    const explodeXYVal   = document.getElementById('explodeXYVal');
    explodeXYRange.addEventListener('input', () => {
      explodeXY = Number(explodeXYRange.value) || 0;
      explodeXYVal.textContent = explodeXY.toFixed(2);
      applyExplode();
    });

    const explodeYRange = document.getElementById('explodeY');
    const explodeYVal   = document.getElementById('explodeYVal');
    explodeYRange.addEventListener('input', () => {
      explodeY = Number(explodeYRange.value) || 0;
      explodeYVal.textContent = explodeY.toFixed(2);
      applyExplode();
    });
    
const flatten2DRange = document.getElementById('flatten2D');
const flatten2DVal   = document.getElementById('flatten2DVal');
if (flatten2DRange && flatten2DVal){
  flatten2DRange.addEventListener('input', () => {
    flatten2D = Number(flatten2DRange.value) || 0;
    flatten2DVal.textContent = flatten2D.toFixed(2);
    apply2DTransition();
  });
}
    // Reset explode/2D e volta cada mesh √† base
// Reset explode + 2D + c√¢mera
document.getElementById('resetExplode')?.addEventListener('click', () => {
  explodeXY = 0;
  explodeY  = 0;
  flatten2D = 0;

  // sliders (se existirem)
  document.getElementById('explodeXY')?.value = '0';
  document.getElementById('explodeY') ?.value = '0';
  document.getElementById('flatten2D')?.value = '0';
  document.getElementById('explodeXYVal')?.textContent = '0.00';
  document.getElementById('explodeYVal') ?.textContent = '0.00';
  document.getElementById('flatten2DVal')?.textContent = '0.00';

  // restaurar transform dos apt roots
  if (__dogeAptRoots.length) {
    for (const A of __dogeAptRoots){
      const base = A.base;
      A.root.position.copy(base.pos);
      A.root.rotation.copy(base.rot);
      A.root.scale.copy(base.scale);
      // restaurar materiais
      A.root.traverse(n=>{
        if (n.isMesh && n.material && 'opacity' in n.material) {
          n.material.transparent = false;
          n.material.opacity = 1.0;
        }
      });
    }
  }

  // esconder overlay e liberar canvas
  doge_hide2DCards();
  if (renderer && renderer.domElement) {
    renderer.domElement.style.pointerEvents = 'auto';
  }

  // restaurar c√¢mera
  if (__camSnap && camera && controls) {
    camera.position.copy(__camSnap.pos);
    controls.target.copy(__camSnap.target);
    camera.updateProjectionMatrix();
    controls.update();
  }
  __camSnap = null;
  __camFront = null;

  // liberar rota√ß√£o
  if (controls) controls.enableRotate = true;
});

    document.getElementById('resetRot').addEventListener('click', () => {
      pivot.rotation.set(0,0,0);
      theta = 0;
      updateCamera();
    });

    document.getElementById('recenter').addEventListener('click', () => {
      recenterOrbitTarget();
      radius = INITIAL_RADIUS; phi = INITIAL_PHI;
      updateCamera();
    });

    // Estado inicial
    opacityVal.textContent = (Number(opacity.value)/100).toFixed(2);
    setFaceOpacity(Number(opacity.value)/100);
    setFacesVisible(true);

    // ====== Cores herdadas do 2D ======
    function normApto(s){
      if (s == null) return '';
      let t = String(s).trim().toUpperCase();
      t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
      t = t.replace(/[\s\-\._\/]/g, '');
      return t;
    }
    function aplicarCoresFVS(payload){
      if (!payload) return;

      // payload:
      // { default:"#RRGGBB", colors:{ "301":"#..." }, byFloor:{ "0":"#..." } }
      const defHex   = (payload.default || '#6e7681').trim();
      const mapApto  = payload.colors || {};
      const mapFloor = payload.byFloor || {};

      const pickColor = (aptoId, floorIdx) => {
        const hexA = mapApto[aptoId] || mapApto[normApto(aptoId)];
        if (hexA && /^#?[0-9a-f]{6}$/i.test(hexA)) return hexA.startsWith('#') ? hexA : '#'+hexA;

        const hexF = mapFloor[String(floorIdx)];
        if (hexF && /^#?[0-9a-f]{6}$/i.test(hexF)) return hexF.startsWith('#') ? hexF : '#'+hexF;

        return defHex.startsWith('#') ? defHex : '#'+defHex;
      };

      for (const g of torre.children){
        const apt   = g.userData.apto || '';
        const floor = g.userData.levelIndex ?? 0;
        const hex   = pickColor(apt, floor);

        const mat = g.userData.mesh.material;
        mat.color = new THREE.Color(hex);
        if (faceOpacity >= 0.999){
          mat.transparent = false;
          mat.depthWrite = true;
          mat.opacity = 1.0;
        } else {
          mat.transparent = true;
          mat.depthWrite = false;
          mat.opacity = faceOpacity;
        }
        mat.needsUpdate = true;
      }
    }
    window.addEventListener('message', (e)=>{
      const data = e.data || {};
      if (data.type === 'fvsColorMap') {
        aplicarCoresFVS(data.payload);
      }
      if (data.type === 'doge-2d-set') {
  flatten2D = Number(data.t) || 0;
  const r = document.getElementById('flatten2D');
  const v = document.getElementById('flatten2DVal');
  if (r) r.value = String(flatten2D);
  if (v) v.textContent = flatten2D.toFixed(2);
  apply2DTransition();
}
    });
    try { parent.postMessage({ type: 'ready-3d' }, '*'); } catch(_) {}
try { parent.postMessage({ type: 'doge-2d-ready' }, '*'); } catch(_) {}
    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);

      if (flatten2D > 0.5) {
  doge_render2DCards(Math.min(1, (flatten2D - 0.5) / 0.5));
}
      updateCamera();
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>






