<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Pr√©dio 3D ‚Äî viewer (cores herdadas da FVS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0d1117; color: #c9d1d9; font-family: system-ui, sans-serif; }
    #app { position: fixed; inset: 0; }
    #hud {
      position: fixed; left: 12px; top: 12px; padding: 10px 12px;
      background: rgba(0,0,0,.45); backdrop-filter: blur(6px);
      border: 1px solid #30363d; border-radius: 10px; font-size: 14px; z-index: 10;
      display: grid; gap: 8px; width: max-content;
    }
    #hud .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .val { width: 3.6rem; text-align: right; display: inline-block; }
    button, label { user-select: none; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div class="row" id="dragHint"><b>Arraste</b> para <span id="modeText">orbitar</span> ‚Ä¢ <b>Scroll</b> para zoom</div>
    <div class="row">
      <button id="modeBtn" title="Alternar entre Orbitar e Mover">üñêÔ∏è Mover</button>
      <label><input id="wireOnly" type="checkbox" /> S√≥ arame</label>
      <button id="resetRot">üîÑ Resetar giro</button>
      <button id="recenter">üéØ Centralizar c√¢mera</button>
    </div>
    <div class="row">
      Opacidade: <input id="opacity" type="range" min="5" max="100" value="30" />
      <span id="opacityVal" class="val">0.30</span>
    </div>
    <div class="row">
      Explodir XY: <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
      <span id="explodeXYVal" class="val">0.00</span>
    </div>
    <div class="row">
      Explodir Y (piso): <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
      <span id="explodeYVal" class="val">0.00</span>
      <button id="resetExplode">Reset</button>
    </div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ====== Carrega o layout do repo ======
    const LAYOUT_URL = './data/layout-3d.json';
    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // ====== Setup ======
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== √ìrbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();

    // Modo arraste: 'orbit' ou 'pan'
    let dragMode = 'orbit';
    const modeBtn = document.getElementById('modeBtn');
    const modeText = document.getElementById('modeText');
    function toggleMode(){
      dragMode = (dragMode === 'orbit') ? 'pan' : 'orbit';
      modeBtn.textContent = (dragMode === 'orbit') ? 'üñêÔ∏è Mover' : 'üéØ Orbitar';
      modeText.textContent = (dragMode === 'orbit') ? 'orbitar' : 'mover';
    }
    modeBtn.addEventListener('click', toggleMode);

    let dragging=false,lastX=0,lastY=0;
    const onDown=(x,y)=>{dragging=true;lastX=x;lastY=y;};
    const onMove=(x,y)=>{
      if(!dragging) return;
      const dx=x-lastX, dy=y-lastY;
      lastX=x; lastY=y;

      if (dragMode === 'orbit') {
        pivot.rotation.y += dx * 0.005;
        phi -= dy * 0.005; phi = clamp(phi, minPhi, maxPhi);
        updateCamera();
      } else {
        const panScale = radius * 0.0025;
        const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
        const up = new THREE.Vector3().copy(camera.up).normalize();
        orbitTarget.addScaledVector(right, -dx * panScale);
        orbitTarget.addScaledVector(up,    dy * panScale);
        updateCamera();
      }
    };
    const onUp=()=>{dragging=false;};
    renderer.domElement.addEventListener('mousedown',e=>onDown(e.clientX,e.clientY));
    window.addEventListener('mousemove',e=>onMove(e.clientX,e.clientY));
    window.addEventListener('mouseup',onUp);

    // Touch
    renderer.domElement.addEventListener('touchstart',e=>{
      if(e.touches.length===1) onDown(e.touches[0].clientX,e.touches[0].clientY);
    },{passive:true});
    renderer.domElement.addEventListener('touchmove',e=>{
      if(e.touches.length===1) onMove(e.touches[0].clientX,e.touches[0].clientY);
    },{passive:true});
    window.addEventListener('touchend',onUp);

    // Zoom
    renderer.domElement.addEventListener('wheel',e=>{
      e.preventDefault();
      const f=1+(e.deltaY>0?0.1:-0.1);
      radius=clamp(radius*f,minRadius,maxRadius);
      updateCamera();
    },{passive:false});

    // ====== Materiais (base NEUTRA cinza) ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX_STR = '#6e7681';
    const NEUTRAL_HEX_INT = 0x6e7681;
    const makeFace = (color)=> new THREE.MeshStandardMaterial({
      color, metalness:0.0, roughness:0.9, transparent:true, opacity:faceOpacity, depthWrite:false
    });
    const makeLine = (color,width=1)=> new THREE.LineBasicMaterial({ color, linewidth:width });

    const MAT = {
      face: ()=>makeFace(NEUTRAL_HEX_INT),
      line: makeLine(0x9aa3ab),
      selLine: makeLine(0xffc107, 2)
    };

    // ====== Passos e helpers ======
    const stepX = (layout.meta?.cellW ?? 1.2) + (layout.meta?.gap ?? 0.15);
    const stepZ = (layout.meta?.cellD ?? 1.2) + (layout.meta?.gap ?? 0.15);
    const aptoHeight = 0.5;
    const stepY = aptoHeight + (layout.meta?.gap ?? 0.15);

    function rectCenterX(x, w){ return x*stepX + (w*(layout.meta?.cellW??1.2) + (w-1)*(layout.meta?.gap??0.15))/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*(layout.meta?.cellD??1.2) + (d-1)*(layout.meta?.gap??0.15))/2; }

    function computeLevels(placements){
      const set = new Set(placements.map(p=>p.andar));
      const nums = [...set].filter(v => typeof v === 'number').sort((a,b)=>a-b);
      const hasAT = [...set].some(v => v === 'AT');
      if (hasAT) nums.push('AT');
      const idx = new Map(nums.map((v,i)=>[v,i]));
      return { order: nums, indexOf: (v)=>idx.get(v) };
    }

    function setFacesVisible(visible){ for (const g of torre.children) g.userData.mesh.visible = visible; }
    function setFaceOpacity(op){ faceOpacity = op; for (const g of torre.children) g.userData.mesh.material.opacity = faceOpacity; }

    // ====== Explodir ======
    let explodeXY = 0.0;
    let explodeY  = 0.0;
    function applyExplode(){
      for (const g of torre.children){
        const base = g.userData.basePos;
        const pos = base.clone();
        if (explodeXY > 0){
          const dir = new THREE.Vector3(base.x, 0, base.z);
          const len = dir.length();
          if (len > 1e-6){
            dir.multiplyScalar(1/len);
            const step = Math.max(stepX, stepZ);
            pos.addScaledVector(dir, explodeXY * step);
          }
        }
        pos.y += g.userData.levelIndex * explodeY;
        g.position.copy(pos);
      }
    }

    // ====== √çndice por apartamento (para aplicar cores rapidamente) ======
    let IDX = new Map(); // aptKey -> Array<THREE.Group>

    function aptKey(s){
      if (s == null) return '';
      let t = String(s).trim().toUpperCase();
      t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');  // sem acento
      t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, ''); // sem prefixos
      t = t.replace(/[\s\-\._\/]/g, ''); // sem separadores
      return t;
    }

    function rebuildIndex(){
      IDX.clear();
      for (const g of torre.children){
        const k = aptKey(g.userData.apto);
        if (!IDX.has(k)) IDX.set(k, []);
        IDX.get(k).push(g);
      }
      // para debug:
      // console.debug('Index 3D rebuild:', IDX);
    }

    // ====== Constru√ß√£o ======
    function buildFromLayout(l){
      while (torre.children.length) torre.remove(torre.children[0]);

      const levels = computeLevels(l.placements);

      for (const p of l.placements){
        const width  = p.w*(layout.meta?.cellW??1.2) + (p.w-1)*(layout.meta?.gap??0.15);
        const depth  = p.d*(layout.meta?.cellD??1.2) + (p.d-1)*(layout.meta?.gap??0.15);
        const height = p.h*aptoHeight + (p.h-1)*(layout.meta?.gap??0.15);

        const geom = new THREE.BoxGeometry(width, height, depth);
        const mesh = new THREE.Mesh(geom, MAT.face());
        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geom, 1), MAT.line);

        const cx = rectCenterX(p.x, p.w);
        const cz = rectCenterZ(p.z, p.d);
        const ly = levels.indexOf(p.andar);
        const cy = ly*stepY + (height/2);

        const group = new THREE.Group();
        group.position.set(cx, cy, cz);
        mesh.position.set(0, 0, 0);
        edges.position.set(0, 0, 0);
        group.add(mesh); group.add(edges);

        group.userData = { ...p, mesh, edges, levelIndex: ly, basePos: new THREE.Vector3() };
        torre.add(group);
      }

      // Centraliza
      const bbox = new THREE.Box3().setFromObject(torre);
      const center = new THREE.Vector3(); bbox.getCenter(center);
      for (const g of torre.children) {
        g.position.sub(center);
        g.userData.basePos.copy(g.position);
      }
      applyExplode();
      recenterOrbitTarget();
      updateCamera();

      // cria/atualiza √≠ndice
      rebuildIndex();
    }

    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }

    buildFromLayout(layout);

    // ====== Sele√ß√£o (bordas) ======
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selGroup = null, selLineBackup = null, selFaceBackup = null;
    renderer.domElement.addEventListener('click', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      const edgeObjects = torre.children.map(g => g.userData.edges);
      raycaster.setFromCamera(mouse, camera);
      let inter = raycaster.intersectObjects(edgeObjects, false);
      if (!inter.length) {
        const faceObjects = torre.children.map(g => g.userData.mesh);
        inter = raycaster.intersectObjects(faceObjects, false);
      }

      if (selGroup) {
        selGroup.userData.edges.material = selLineBackup;
        selGroup.userData.mesh.material = selFaceBackup;
        selGroup = null;
      }

      if (inter.length) {
        const hitObj = inter[0].object;
        selGroup = torre.children.find(g => g.userData.edges === hitObj || g.userData.mesh === hitObj);
        if (selGroup) {
          selLineBackup = selGroup.userData.edges.material;
          selFaceBackup = selGroup.userData.mesh.material.clone();
          selGroup.userData.edges.material = MAT.selLine;
          selGroup.userData.mesh.material = selGroup.userData.mesh.material.clone();
          selGroup.userData.mesh.material.opacity = Math.min(1, faceOpacity + 0.2);
          console.log('Selecionado:', selGroup.userData);
        }
      }
    });

    // ====== UI ======
    const opacity = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    opacity.addEventListener('input', () => {
      const v = parseInt(opacity.value, 10)/100;
      opacityVal.textContent = v.toFixed(2);
      setFaceOpacity(v);
    });
    document.getElementById('wireOnly').addEventListener('change', (e) => setFacesVisible(!e.target.checked));
    const explodeXYRange = document.getElementById('explodeXY');
    const explodeXYVal = document.getElementById('explodeXYVal');
    explodeXYRange.addEventListener('input', () => {
      explodeXY = parseFloat(explodeXYRange.value);
      explodeXYVal.textContent = explodeXY.toFixed(2);
      applyExplode();
    });
    const explodeYRange = document.getElementById('explodeY');
    const explodeYVal = document.getElementById('explodeYVal');
    explodeYRange.addEventListener('input', () => {
      explodeY = parseFloat(explodeYRange.value);
      explodeYVal.textContent = explodeY.toFixed(2);
      applyExplode();
    });
    document.getElementById('resetExplode').addEventListener('click', () => {
      explodeXY = 0; explodeY = 0;
      explodeXYRange.value = '0'; explodeYRange.value = '0';
      explodeXYVal.textContent = '0.00'; explodeYVal.textContent = '0.00';
      applyExplode();
    });
    document.getElementById('resetRot').addEventListener('click', () => { pivot.rotation.set(0,0,0); });
    document.getElementById('recenter').addEventListener('click', () => {
      recenterOrbitTarget(); radius = INITIAL_RADIUS; phi = INITIAL_PHI; updateCamera();
    });

    // Estado inicial
    setFaceOpacity(parseInt(opacity.value,10)/100);
    setFacesVisible(true);

    // ====== Aplica√ß√£o de cores recebidas do 2D ======
    function applyColorMap(payload){
      // payload: { mode, colors: { [aptKey]: '#RRGGBB' }, default: '#6e7681' }
      if (!payload) return;
      const defHex = (payload.default || NEUTRAL_HEX_STR).trim();
      const map = payload.colors || {};

      // pinta tudo com a cor default primeiro
      for (const g of torre.children){
        g.userData.mesh.material.color.set(defHex);
        g.userData.mesh.material.needsUpdate = true;
      }

      // aplica overrides por unidade (aptKey)
      for (const [rawKey, hex] of Object.entries(map)){
        const k = aptKey(rawKey);
        const arr = IDX.get(k);
        if (!arr) continue;
        for (const g of arr){
          g.userData.mesh.material.color.set(hex);
          g.userData.mesh.material.needsUpdate = true;
        }
      }
    }

    // Recebe mapa do 2D
    window.addEventListener('message', (e)=>{
      const data = e.data || {};
      if (data.type === 'fvsColorMap') {
        applyColorMap(data.payload);
      }
    });

    // Handshake: avisa que o 3D est√° pronto
    try { window.parent?.postMessage({ type: 'ready-3d' }, '*'); } catch(_) {}

    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      updateCamera();
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>
