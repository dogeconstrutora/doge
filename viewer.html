<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Pr√©dio 3D ‚Äî viewer (cores herdadas da FVS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0d1117; color: #c9d1d9; font-family: system-ui, sans-serif; }
    #app { position: fixed; inset: 0; }
    canvas { display:block; }

/* === HUD fixo no rodap√© (todas as telas) === */
#hud {
  position: fixed;
  left: 0; right: 0; bottom: 0;
  z-index: 20;
  display: flex;
  flex-wrap: wrap;            /* pode quebrar linha em telas estreitas */
  gap: 8px;
  align-items: center;
  justify-content: center;    /* desktop: centraliza numa linha */
  padding: 10px 12px;
  background: rgba(0,0,0,.45);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  color: #fff;
  border-top: 1px solid #30363d;
  border-radius: 10px 10px 0 0;
  font-size: 14px;
}

/* Controles no HUD */
#hud .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
.val { width: 3.6rem; text-align: right; display: inline-block; }
button, label { user-select: none; }

/* Al√ßa / bot√£o */
#hud .handle { display:flex; align-items:center; gap:8px; cursor:grab; user-select:none; }
#hud .grabber { width:44px; height:6px; border-radius:4px; background:#58606b; opacity:.85; margin-right:4px; }
#hudToggle {
  border: 1px solid #30363d; background: #0d1117; color: #c9d1d9;
  border-radius: 8px; padding: 4px 8px; font-size: 13px; line-height: 1;
}

#hud { touch-action: pan-y; }      /* j√° est√° */
#hud button, #hud input, #hud label { touch-action: manipulation; }    
/* === Bot√£o 2D (SVG) === */
:root{
  --c-2d-off: #8b949e;   /* esmaecido no modo 3D */
  --c-2d-on:  #ff3b30;   /* vermelho no modo 2D */
}
#btn2D.mode2d{
  display:inline-flex; align-items:center; justify-content:center;
  width:40px; height:40px;
  border:1px solid #30363d; border-radius:10px;
  background:#0d1117; color:var(--c-2d-off);
  cursor:pointer; user-select:none;
  transition: color .18s ease, box-shadow .18s ease, border-color .18s ease;
}
#btn2D.mode2d:hover{ border-color:#3a3f46; }
#btn2D.mode2d.active{
  color:var(--c-2d-on);
  box-shadow: 0 0 0 2px rgba(255,59,48,.18), 0 4px 16px rgba(255,59,48,.25);
  border-color: rgba(255,59,48,.55);
}
#btn2D.mode2d svg{ width:28px; height:28px; }
#btn2D.mode2d .badge{ fill:none; stroke:currentColor; stroke-width:2; opacity:.38; }
#btn2D.mode2d .label{ fill:currentColor; font: 700 13px/1 system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial; }

/* Desktop largo: for√ßa tudo numa linha estreita */
@media (min-width: 900px) {
  #hud { flex-wrap: nowrap; padding: 8px 10px; gap: 10px; }
  #hud input[type="range"] { width: 180px; }
  #hud button, #hud select, #hud label { white-space: nowrap; }
}

/* Respeito a movimento reduzido */
@media (prefers-reduced-motion: reduce) { #hud { transition: none; } }

/* O HUD rola verticalmente se lotar (mobile), mas a al√ßa n√£o */
#hud { touch-action: pan-y; }
#hudHandle { touch-action: none; }

/* === Overlay 2D (sem inset no CSS; JS define top/bottom) === */
/* === Overlay 2D ocupando o #app inteiro (n√£o sai do #app) === */
  /* ...seu CSS anterior... */

  /* === Overlay 2D (um √∫nico cont√™iner fixo) === */
  /* === Overlay 2D ocupando a tela toda (ajuste do bottom via JS) === */
#cards2d{
  position: fixed;        /* sempre fixo, independente do #app */
  top: 0; left: 0; right: 0; bottom: 0;   /* JS vai ajustar o bottom p/ n√£o ficar sob o HUD */
  z-index: 9;
  pointer-events: none;   /* liberado via JS quando t‚âà1 */
  opacity: 0;             /* fade controlado no JS */
  overflow-x: hidden;
  overflow-y: auto;       /* permite scroll quando necess√°rio */
}

/* Cada cart√£o √© posicionado por top/left absolutos (sem translate) */
#cards2d .card{
  position: absolute;
  width: 120px; height: 72px;
  display: flex; align-items: center; justify-content: center;
  border-radius: 12px; border: 1px solid rgba(255,255,255,.18);
  background: rgba(34,40,53,.92); color: #e6eef7;
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
  font: 12px/1.2 system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial;
  user-select: none; cursor: pointer; pointer-events: auto;
  transform: translate(-50%, -50%);   /* <<< troquei: REMOVA o !important e volte o translate */
}

#cards2d .card .label{
  padding: .35rem .55rem; border-radius: 999px;
  background: rgba(0,0,0,.25);
  border: 1px solid rgba(255,255,255,.12);
}
canvas { touch-action: none; }
html, body { overscroll-behavior: none; } /* evita bounce/pull-to-refresh */   
    
  </style>
</head>
<body>
  <div id="app"><div id="cards2d"></div>
  </div>
  <div id="hud">
    <div class="row handle" id="hudHandle">
      <div class="grabber" aria-hidden="true"></div>
      <span style="font-weight:600; flex:1;">Controles</span>
      <button id="hudToggle" aria-expanded="true" title="Recolher/Expandir">‚ñæ</button>
    </div>

    <div class="row">
      <label><input id="wireOnly" type="checkbox" /> S√≥ arame</label>
      <button id="resetRot">üîÑ Resetar giro</button>
      <button id="recenter">üéØ Centralizar</button>
    </div>
    <div class="row">
      Opacidade: <input id="opacity" type="range" min="0" max="100" value="100" />
      <span id="opacityVal" class="val">1</span>
    </div>
    <div class="row">
      Explodir XY: <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
      <span id="explodeXYVal" class="val">0.00</span>
    </div>
    <div class="row">
      Explodir Y (piso): <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
      <span id="explodeYVal" class="val">0.00</span>
      <button id="resetExplode">Reset</button>
    </div>
    <!-- [DOGE] Slider 2D (fade/zoom do pr√©dio) -->
<div class="row">
  <button id="btn2D" class="mode2d" title="Alternar visualiza√ß√£o 2D">
    <svg viewBox="0 0 48 48" aria-hidden="true" focusable="false">
      <circle class="badge" cx="24" cy="24" r="20"></circle>
      <text class="label" x="24" y="29" text-anchor="middle">2D</text>
    </svg>
  </button>
</div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ====== Carrega o layout do repo ======
    const LAYOUT_URL = './data/layout-3d.json';
    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // ====== Setup ======
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== √ìrbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();

    // ===== √ìrbita + Pan (mouse) + Pin√ßa (zoom) e 2 dedos (pan) ‚Äî Pointer Events =====
    let activePointers = new Map();     // pointerId -> {x,y}
    let dragging = false;
    let dragMode = 'orbit';
    let lastX = 0, lastY = 0;

    const ptsArr   = () => Array.from(activePointers.values());
    const centroid = (pts)=>({ x: pts.reduce((a,p)=>a+p.x,0)/pts.length,
                               y: pts.reduce((a,p)=>a+p.y,0)/pts.length });
    const dist     = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);

    let gesture = null; // { startDist, startRadius, lastCentroid }

    function pointerDown3D(e){
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      renderer.domElement.setPointerCapture(e.pointerId);

      const pts = ptsArr();
      if (pts.length === 1){
        // 1 dedo / 1 mouse: ORBIT (bot√£o direito do mouse = pan)
        dragMode = (e.button === 2) ? 'pan' : 'orbit';
        dragging = true;
        lastX = e.clientX; lastY = e.clientY;
      } else if (pts.length === 2){
        // 2 dedos: pin√ßa + pan do centroide
        const [p1,p2] = pts;
        gesture = {
          startDist:   dist(p1,p2),
          startRadius: radius,
          lastCentroid: centroid(pts)
        };
      }
      e.preventDefault();
    }
renderer.domElement.style.touchAction = 'none';
    function pointerMove3D(e){
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

      const pts = ptsArr();

      // 1 apontador (mouse/1 dedo)
      if (pts.length === 1 && dragging){
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        if (dragMode === 'orbit'){
          pivot.rotation.y += dx * 0.005;
          theta = pivot.rotation.y;
          phi   = clamp(phi - dy * 0.005, minPhi, maxPhi);
          updateCamera();
        } else {
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
          updateCamera();
        }
        e.preventDefault();
        return;
      }

      // 2 apontadores (pin√ßa para zoom + centroide para pan)
      if (pts.length === 2 && gesture){
        const c  = centroid(pts);
        const d  = dist(pts[0], pts[1]);

        if (gesture.startDist > 0){
          // afastar dedos afasta a c√¢mera (zoom out)
          const scale = d / gesture.startDist;
          const newR  = gesture.startRadius / Math.max(0.2, Math.min(5, scale));
          radius = clamp(newR, minRadius, maxRadius);
        }

        const dx = c.x - gesture.lastCentroid.x;
        const dy = c.y - gesture.lastCentroid.y;
        if (dx || dy){
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
        }

        gesture.lastCentroid = c;
        updateCamera();
        e.preventDefault();
        return;
      }
    }

    function pointerUp3D(e){
      if (activePointers.has(e.pointerId)){
        try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
        activePointers.delete(e.pointerId);
      }
      const pts = ptsArr();
      if (pts.length === 0){ dragging = false; gesture = null; }
      if (pts.length < 2){ gesture = null; }
      e.preventDefault();
    }

    renderer.domElement.addEventListener('pointerdown',   pointerDown3D,   {passive:false});
    renderer.domElement.addEventListener('pointermove',   pointerMove3D,   {passive:false});
    renderer.domElement.addEventListener('pointerup',     pointerUp3D,     {passive:false});
    renderer.domElement.addEventListener('pointercancel', pointerUp3D,     {passive:false});

    // bloqueia menu do bot√£o direito (para pan no desktop)
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Scroll do mouse (zoom)
    renderer.domElement.addEventListener('wheel', e=>{
      e.preventDefault();
      const f = 1 + (e.deltaY>0 ? 0.1 : -0.1);
      radius = clamp(radius*f, minRadius, maxRadius);
      updateCamera();
    }, {passive:false});

    // ====== Materiais com polygonOffset (linhas limpas, sem z-fighting) ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX = 0x6e7681;
    const MAT = {
      face: ()=> new THREE.MeshStandardMaterial({
        color: NEUTRAL_HEX,
        metalness: 0.05,
        roughness: 0.9,
        transparent: true,
        opacity: faceOpacity,
        depthWrite: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      }),
      line: new THREE.LineBasicMaterial({
        color: 0xcad7ff,
        linewidth: 1,
        depthTest: true,
        depthWrite: false,
        transparent: true,
        opacity: 0.95
      }),
      selLine: new THREE.LineBasicMaterial({
        color: 0xffc107,
        linewidth: 2
      })
    };

    function setFacesVisible(visible){
      for (const g of torre.children) g.userData.mesh.visible = visible;
    }

    function setFaceOpacity(op){
      faceOpacity = op;
      for (const g of torre.children){
        const m = g.userData.mesh.material;
        m.opacity = faceOpacity;

        if (faceOpacity >= 0.999) {
          m.transparent = false;
          m.depthWrite = true;
          m.opacity = 1.0;
        } else {
          m.transparent = true;
          m.depthWrite = false;
        }
        m.needsUpdate = true;
      }
    }

    // ===== Dimens√£o b√°sica em "mundo" =====
    const cellW = (layout.meta?.cellW ?? 1.2);
    const cellD = (layout.meta?.cellD ?? 1.2);
    const gap   = (layout.meta?.gap   ?? 0.15);

    const aptoHeight = 0.5;          // altura "unit√°ria" por n√≠vel
    const stepX = cellW + gap;
    const stepZ = cellD + gap;
    const stepY = aptoHeight + gap;

    function rectCenterX(x, w){ return x*stepX + (w*cellW + (w-1)*gap)/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*cellD + (d-1)*gap)/2; }

    // ===== Explode (√∫nica fonte de verdade) =====
    let explodeXY = 0.0;
    let explodeY  = 0.0;

    function applyExplode(){
      if (!torre || torre.children.length === 0) return;

      if ((explodeXY === 0 || !Number.isFinite(explodeXY)) &&
          (explodeY  === 0 || !Number.isFinite(explodeY))) {
        for (const g of torre.children) g.position.copy(g.userData.basePos);
        return;
      }

      // Centroide dos anchors
      let sumX = 0, sumZ = 0, n = 0;
      for (const g of torre.children){
        const a = g.userData.anchor || g.userData.basePos;
        sumX += a.x; sumZ += a.z; n++;
      }
      const cx = n ? (sumX/n) : 0;
      const cz = n ? (sumZ/n) : 0;

      const step = Math.max(stepX, stepZ) || 1;

      for (const g of torre.children){
        const base = g.userData.basePos;
        const pos  = base.clone();

        if (explodeXY > 0){
          const a = g.userData.anchor || base;
          const dir = new THREE.Vector3(a.x - cx, 0, a.z - cz);
          const len = dir.length();
          if (len > 1e-6){
            dir.multiplyScalar(1/len);
            pos.addScaledVector(dir, explodeXY * step);
          }
        }

        if (explodeY !== 0){
          pos.y += (g.userData.levelIndex || 0) * explodeY;
        }

        g.position.copy(pos);
      }
    }

    // ===== Voxeliza√ß√£o por APTO =====
    function voxelizeByApto(l){
      const byApto = new Map();
      for (const p of l.placements){
        const apt = String(p.apto);
        if (!byApto.has(apt)) byApto.set(apt, new Set());
        const set = byApto.get(apt);
        const baseY = (typeof p.andar === 'number') ? p.andar : 0; // 'AT' => 0
        for (let gx = p.x; gx < p.x + p.w; gx++){
          for (let gz = p.z; gz < p.z + p.d; gz++){
            for (let gy = baseY; gy < baseY + p.h; gy++){
              set.add(`${gx},${gy},${gz}`);
            }
          }
        }
      }
      return byApto;
    }

    // ===== Meshing de fronteira (sem faces internas) =====
    function buildSurfaceGeometryFromOcc(occSet){
      if (!occSet || occSet.size===0) return null;
      const has = (x,y,z)=> occSet.has(`${x},${y},${z}`);

      const pos = [];
      const idx = [];
      let vbase = 0;

      const pushQuad = (a,b,c,d)=>{
        pos.push( ...a, ...b, ...c, ...d );
        idx.push(vbase, vbase+1, vbase+2,  vbase, vbase+2, vbase+3);
        vbase += 4;
      };

      function voxelBounds(gx,gy,gz){
        const x0 = gx * stepX, x1 = x0 + cellW;
        const z0 = gz * stepZ, z1 = z0 + cellD;
        const y0 = gy * stepY, y1 = y0 + aptoHeight;
        return {x0,x1,y0,y1,z0,z1};
      }

      for (const key of occSet){
        const [gx,gy,gz] = key.split(',').map(Number);
        const {x0,x1,y0,y1,z0,z1} = voxelBounds(gx,gy,gz);

        if (!has(gx-1,gy,gz)) pushQuad([x0,y0,z1],[x0,y0,z0],[x0,y1,z0],[x0,y1,z1]); // -X
        if (!has(gx+1,gy,gz)) pushQuad([x1,y0,z0],[x1,y0,z1],[x1,y1,z1],[x1,y1,z0]); // +X
        if (!has(gx,gy,gz-1)) pushQuad([x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]); // -Z
        if (!has(gx,gy,gz+1)) pushQuad([x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]); // +Z
        if (!has(gx,gy-1,gz)) pushQuad([x0,y0,z0],[x1,y0,z0],[x1,y0,z1],[x0,y0,z1]); // -Y
        if (!has(gx,gy+1,gz)) pushQuad([x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]); // +Y
      }

      if (pos.length===0) return null;

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
      geom.setIndex(new THREE.Uint32BufferAttribute(new Uint32Array(idx), 1));
      geom.computeVertexNormals();
      geom.computeBoundingBox(); geom.computeBoundingSphere();
      return geom;
    }

    // ===== Inflar para desenhar edges limpas =====
    function inflateGeometry(geom, offset=0.04){
      const g = geom.clone();
      g.computeVertexNormals();
      const pos = g.getAttribute('position');
      const nor = g.getAttribute('normal');
      for (let i=0;i<pos.count;i++){
        pos.setX(i, pos.getX(i) + nor.getX(i)*offset);
        pos.setY(i, pos.getY(i) + nor.getY(i)*offset);
        pos.setZ(i, pos.getZ(i) + nor.getZ(i)*offset);
      }
      pos.needsUpdate = true;
      return g;
    }

    // ====== Constru√ß√£o ======
// ====== Constru√ß√£o ======
function buildFromLayout(l){
  // --- 1) Colete metadados por apartamento (nome, ordemcol, zIndex, etc.)
  //     Se houver mais de um placement para o mesmo apto, o √∫ltimo "vence".
  const aptMeta = new Map();
  if (l && Array.isArray(l.placements)){
    for (const p of l.placements){
      const id = String(p.apto);
      const m  = aptMeta.get(id) || {};
      if (p.nome != null)      m.name     = String(p.nome);
      if (p.ordemcol != null)  m.ordemcol = Number(p.ordemcol); // 1-based
      if (p.zindex != null)    m.zIndex   = Number(p.zindex);
      // opcional: se no futuro houver m.floor vindo do JSON
      if (p.floor != null)     m.floor    = Number(p.floor);
      aptMeta.set(id, m);
    }
  }

  // limpa torre
  while (torre.children.length) torre.remove(torre.children[0]);

  // voxeliza por apartamento
  const occByApto = voxelizeByApto(l);

  for (const [apto, occ] of occByApto.entries()){
    const surface = buildSurfaceGeometryFromOcc(occ);
    if (!surface) continue;

    // material neutro (cores vir√£o do FVS; opacidade coerente)
    const faceMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color(0x6e7681),
      metalness: 0.05,
      roughness: 0.9,
      transparent: faceOpacity < 0.999,
      opacity: Math.min(1, faceOpacity),
      depthWrite: faceOpacity >= 0.999,
      side: THREE.DoubleSide,
      polygonOffset: true,
      polygonOffsetFactor: 1,
      polygonOffsetUnits: 1
    });

    const mesh = new THREE.Mesh(surface, faceMat);
    mesh.renderOrder = 1;

    // contorno limpo
    const inflated = inflateGeometry(surface, 0.04);
    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(inflated, 1), MAT.line);
    edges.renderOrder = 2;

    // pavimento m√≠nimo (explodeY)
    let minLevel = Infinity;
    for (const key of occ){
      const gy = parseInt(key.split(',')[1],10);
      if (gy < minLevel) minLevel = gy;
    }
    if (!Number.isFinite(minLevel)) minLevel = 0;

    const group = new THREE.Group();
    group.add(mesh); group.add(edges);
    group.position.set(0,0,0);

    // meta vindo do JSON (se houver) + campos locais
    const metaFromJson = aptMeta.get(String(apto)) || {};
    // garante string de id e name
    const idStr   = String(apto);
    const nameStr = metaFromJson.name || idStr;

    group.userData = {
      apto: idStr,
      mesh, edges,
      levelIndex: minLevel,                          // usado no explode Y
      basePos: new THREE.Vector3(0,0,0),
      anchor:  new THREE.Vector3(0,0,0),
      // meta fica aqui; ser√° lida em collectApartmentRoots()
      meta: {
        id: idStr,
        name: nameStr,
        // 1-based no JSON; guardamos como veio.
        ordemcol: (typeof metaFromJson.ordemcol === 'number') ? metaFromJson.ordemcol : undefined,
        zIndex:   (typeof metaFromJson.zIndex   === 'number') ? metaFromJson.zIndex   : undefined
      }
    };

    // centro local do geometry (para anchor depois)
    surface.computeBoundingBox();
    const bb = surface.boundingBox;
    const localCenter = new THREE.Vector3();
    bb.getCenter(localCenter);
    group.__localCenter = localCenter;

    torre.add(group);
  }

  // Centraliza todo o conjunto no (0,0,0)
  const bbox = new THREE.Box3().setFromObject(torre);
  const center = new THREE.Vector3(); bbox.getCenter(center);
  const size   = new THREE.Vector3(); bbox.getSize(size);

  for (const g of torre.children){
    g.position.sub(center);
    g.userData.basePos.copy(g.position);

    // anchor = centro do apto em mundo colado
    const lc = g.__localCenter || new THREE.Vector3();
    g.userData.anchor.set(
      g.position.x + lc.x,
      g.position.y + lc.y,
      g.position.z + lc.z
    );
    delete g.__localCenter;
  }

  // C√¢mera inicial baseada no tamanho real
  const diag = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
  const idealRadius = Math.max(8, diag * 0.75);
  radius = clamp(idealRadius, minRadius, maxRadius);

  orbitTarget.set(0, 0, 0);
  updateCamera();

  // Aplica estado atual do explode (zero ‚Üí colado)
  applyExplode();
}


    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }
// Mapa de metadados por apto (nome, ordemcol) vindo do JSON
const metaByApto = new Map();
for (const p of (layout.placements||[])){
  const key = String(p.apto);
  if (!metaByApto.has(key)){
    metaByApto.set(key, { nome: (p.nome||''), ordemcol: (p.ordemcol|0) });
  }
}


    buildFromLayout(layout);

    // ====== Sele√ß√£o com mira refinada ======
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

renderer.domElement.addEventListener('click', (e) => {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

  // 1) faces
  const faceObjects = torre.children.map(g => g.userData.mesh);
  raycaster.setFromCamera(mouse, camera);
  let inter = raycaster.intersectObjects(faceObjects, false);

  // 2) fallback em arestas
  if (!inter.length) {
    const edgeObjects = torre.children.map(g => g.userData.edges);
    raycaster.params.Line = raycaster.params.Line || {};
    raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06;
    inter = raycaster.intersectObjects(edgeObjects, false);
  }

  // limpar sele√ß√£o anterior (visual)
  if (window.__SEL_GROUP__) {
    const gPrev = window.__SEL_GROUP__;
    gPrev.userData.edges.material = gPrev.__lineBackup;
    gPrev.userData.mesh.material = gPrev.__faceBackup;
    delete gPrev.__lineBackup; delete gPrev.__faceBackup;
    window.__SEL_GROUP__ = null;
  }

  if (inter.length) {
    const hitObj   = inter[0].object;
    const selGroup = hitObj.parent; // o Group do apto
    if (selGroup && selGroup.userData) {
      // Destaque visual (opcional, mantive seu comportamento atual)
      selGroup.__lineBackup = selGroup.userData.edges.material;
      selGroup.__faceBackup = selGroup.userData.mesh.material.clone();
      selGroup.userData.edges.material = MAT.selLine;
      const faceClone = selGroup.userData.mesh.material.clone();
      faceClone.opacity = Math.min(1, faceOpacity + 0.2);
      selGroup.userData.mesh.material = faceClone;
      window.__SEL_GROUP__ = selGroup;

      // >>> Envia mensagem ao pai para abrir o modal
      const aptId = String(selGroup.userData.apto || selGroup.userData?.meta?.id || '').trim();
      // tenta extrair a cor atual do material
      let hex = null;
      try {
        const c = selGroup.userData.mesh.material.color;
        if (c) hex = '#' + c.getHexString();
      } catch(_) {}
      try {
        parent.postMessage({ type: 'viewer:open-apt', apt: aptId, color: hex }, '*');
      } catch(_) {}

      // log interno
      console.log('[viewer] click apto:', aptId);
    }
  }
});



    // ====== HUD / UI ======
    const hud       = document.getElementById('hud');
    const hudToggle = document.getElementById('hudToggle');
    const hudHandle = document.getElementById('hudHandle');

    hudToggle.addEventListener('click', () => {
      const collapsed = hud.classList.toggle('collapsed');
      hudToggle.textContent = collapsed ? '‚ñ¥' : '‚ñæ';
      hudToggle.setAttribute('aria-expanded', String(!collapsed));
    });

    // Gesto vertical simples: arrastar a al√ßa para recolher/expandir
    let hudDragId = null, hudStartY = 0, hudDy = 0;
    function hudPointerDown(e){
      hudDragId = e.pointerId;
      hudStartY = e.clientY; hudDy = 0;
      hudHandle.setPointerCapture(hudDragId);
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerMove(e){
      if (e.pointerId !== hudDragId) return;
      hudDy = e.clientY - hudStartY;
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerUp(e){
      if (e.pointerId !== hudDragId) return;
      if (hudDy > 30) {
        hud.classList.add('collapsed');
        hudToggle.textContent = '‚ñ¥';
        hudToggle.setAttribute('aria-expanded', 'false');
      } else if (hudDy < -30) {
        hud.classList.remove('collapsed');
        hudToggle.textContent = '‚ñæ';
        hudToggle.setAttribute('aria-expanded', 'true');
      }
      try { hudHandle.releasePointerCapture(hudDragId); } catch(_){}
      hudDragId = null; hudDy = 0;
      e.preventDefault(); e.stopPropagation();
    }
    hudHandle.addEventListener('pointerdown', hudPointerDown, {passive:false});
    hudHandle.addEventListener('pointermove', hudPointerMove, {passive:false});
    hudHandle.addEventListener('pointerup',   hudPointerUp,   {passive:false});
    hudHandle.addEventListener('pointercancel', hudPointerUp, {passive:false});

    // Clique na al√ßa alterna (bom no desktop)
    hudHandle.addEventListener('click', (e) => {
      if (e.target === hudToggle) return;
      hudToggle.click();
    });

    document.getElementById('wireOnly').addEventListener('change', (e) => setFacesVisible(!e.target.checked));

    const opacity = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    opacity.addEventListener('input', () => {
      const v = Number(opacity.value) / 100;
      opacityVal.textContent = v.toFixed(2);
      setFaceOpacity(v);
    });

    const explodeXYRange = document.getElementById('explodeXY');
    const explodeXYVal   = document.getElementById('explodeXYVal');
    explodeXYRange.addEventListener('input', () => {
      explodeXY = Number(explodeXYRange.value) || 0;
      explodeXYVal.textContent = explodeXY.toFixed(2);
      applyExplode();
    });

    const explodeYRange = document.getElementById('explodeY');
    const explodeYVal   = document.getElementById('explodeYVal');
    explodeYRange.addEventListener('input', () => {
      explodeY = Number(explodeYRange.value) || 0;
      explodeYVal.textContent = explodeY.toFixed(2);
      applyExplode();
    });

    document.getElementById('resetExplode').addEventListener('click', () => {
      explodeXY = 0; explodeY = 0;
      explodeXYRange.value = '0'; explodeYRange.value = '0';
      explodeXYVal.textContent = '0.00'; explodeYVal.textContent = '0.00';
      applyExplode();
    });

    document.getElementById('resetRot').addEventListener('click', () => {
      pivot.rotation.set(0,0,0);
      theta = 0;
      updateCamera();
    });

    document.getElementById('recenter').addEventListener('click', () => {
      recenterOrbitTarget();
      radius = INITIAL_RADIUS; phi = INITIAL_PHI;
      updateCamera();
    });
    // ================== [DOGE] Fade/Zoom do pr√©dio (Etapa 1) ==================
    let flatten2D = 0;

    // Aponta elementos do HUD
    //const flatten2DRange = document.getElementById('flatten2D');
    //const flatten2DVal   = document.getElementById('flatten2DVal');

    // Container da futura grade 2D (na Etapa 2 popularemos)
    //const cards2d = document.getElementById('cards2d');
    const cards2d = document.getElementById('cards2d');
    // Guarda opacidades base para conseguir restaurar no reset
    function cacheBaseVisualsIfNeeded(){
      if (!torre || torre.userData.__dogeBaseCached) return;
      torre.userData.__dogeBaseCached = true;
      torre.userData.__baseScale = torre.scale.clone();

      torre.traverse(n=>{
        if (!n.material) return;
        if (n.isMesh && typeof n.userData.__baseOpacityMesh === 'undefined') {
          n.userData.__baseOpacityMesh =
            (typeof n.material.opacity === 'number') ? n.material.opacity : 1.0;
        }
        if ((n.isLine || n.isLineSegments) && typeof n.userData.__baseOpacityLine === 'undefined') {
          n.userData.__baseOpacityLine =
            (typeof n.material.opacity === 'number') ? n.material.opacity : 0.95;
        }
      });
    }

    // Aplica o efeito conforme t‚àà[0..1]
    // ================== [DOGE] Transi√ß√£o 3D‚Üí2D (fade/zoom + grade overlay) ==================
function apply2DTransition(){
  if (!torre) return;
   cacheBaseVisualsIfNeeded();
  // Garante coleta/constru√ß√£o da grade na 1¬™ vez que o slider mexe
  if (!__aptRoots || __aptRoots.length === 0) collectApartmentRoots();
  if (!__gridModel) prepareGridModel();
  if (!__cardsBuilt) build2DCards();

  const t = flatten2D;

  // 1) Torre: escala e opacidade (fade-out/zoom-out suave)
  const baseScale = torre.userData.__baseScale || new THREE.Vector3(1,1,1);
  const s = THREE.MathUtils.lerp(1.0, 0.50, t);  // 1 ‚Üí 0.5
  torre.scale.set(baseScale.x * s, baseScale.y * s, baseScale.z * s);

torre.traverse(n=>{
  if (!n.material) return;

  if (n.isMesh) {
    const base = (typeof n.userData.__baseOpacityMesh === 'number')
                  ? n.userData.__baseOpacityMesh
                  : (typeof faceOpacity==='number' ? faceOpacity : 1.0);

    const op = THREE.MathUtils.lerp(base, 0.03, t);
    n.material.opacity = op;

    // quando estamos ‚Äúno 3D‚Äù (t ~ 0), volte aos flags originais
    if (t <= 0.001) {
      const opaque = base >= 0.999;
      n.material.transparent = !opaque;
      n.material.depthWrite  = opaque;
    } else {
      n.material.transparent = true;
      n.material.depthWrite  = false;
    }
    n.material.needsUpdate = true;
  }

  if (n.isLine || n.isLineSegments) {
    const base = (typeof n.userData.__baseOpacityLine === 'number')
                  ? n.userData.__baseOpacityLine : 0.95;

    const op = THREE.MathUtils.lerp(base, 0.08, t);
    n.material.opacity = op;

    if (t <= 0.001) {
      const opaque = base >= 0.999;
      n.material.transparent = !opaque;
      n.material.depthWrite  = opaque;
    } else {
      n.material.transparent = true;
      n.material.depthWrite  = false;
    }
    n.material.needsUpdate = true;
  }
});

  // 2) Overlay 2D: posiciona e controla visibilidade
  render2DCardsToScreen(t);

  // Canvas 3D s√≥ para de receber eventos quando o t est√° no fim
  if (renderer && renderer.domElement) {
    renderer.domElement.style.pointerEvents = (t >= 0.95) ? 'none' : 'auto';
  }
}


    // Listener do slider 2D
// ================== [DOGE] Toggle 2D por bot√£o ==================
//let flatten2D = (typeof flatten2D === 'number') ? flatten2D : 0; // mant√©m se j√° existir
const btn2D = document.getElementById('btn2D');

// Atualiza a apar√™ncia do bot√£o conforme estado
function update2DButtonVisual(){
  if (!btn2D) return;
  btn2D.classList.toggle('active', flatten2D >= 0.999);
}

// Anima suavemente 3D‚áÑ2D (0‚Üí1 ou 1‚Üí0)
function tweenFlatten2D(target, ms=280){
  const from = flatten2D;
  const to   = Math.max(0, Math.min(1, target));
  if (Math.abs(from - to) < 1e-4){ update2DButtonVisual(); return; }

  const start = performance.now();
  function step(now){
    const k = Math.min(1, (now - start) / ms);
    const eased = k < 0.5 ? 2*k*k : 1 - Math.pow(-2*k + 2, 2)/2;
    flatten2D = from + (to - from) * eased;
    apply2DTransition();

    if (k < 1) {
      requestAnimationFrame(step);
    } else {
      flatten2D = to;
      apply2DTransition();
      update2DButtonVisual();

      // se voltamos ao 3D, restaura exatamente a base
      if (to === 0 && torre) {
        torre.traverse(n=>{
          if (!n.material) return;
          if (n.isMesh && typeof n.userData.__baseOpacityMesh === 'number') {
            const base = n.userData.__baseOpacityMesh;
            n.material.opacity     = base;
            const opaque           = base >= 0.999;
            n.material.transparent = !opaque;
            n.material.depthWrite  = opaque;
            n.material.needsUpdate = true;
          }
          if ((n.isLine || n.isLineSegments) && typeof n.userData.__baseOpacityLine === 'number') {
            const base = n.userData.__baseOpacityLine;
            n.material.opacity     = base;
            const opaque           = base >= 0.999;
            n.material.transparent = !opaque;
            n.material.depthWrite  = opaque;
            n.material.needsUpdate = true;
          }
        });
      }
    }
  }
  requestAnimationFrame(step);
}

if (btn2D){
  btn2D.addEventListener('click', ()=>{
    const going2D = flatten2D < 0.5;
    tweenFlatten2D(going2D ? 1 : 0);
  });
}
// estado inicial
update2DButtonVisual();


    // Integra√ß√£o com o bot√£o Reset (substitui somente o trecho que seta valores)
 // === Reset Explode + volta ao 3D e oculta cards ===
const resetBtn = document.getElementById('resetExplode');
if (resetBtn){
  resetBtn.addEventListener('click', ()=>{
    // 1) explode volta ao zero
    explodeXY = 0; explodeY = 0;
    const elExplodeXY = document.getElementById('explodeXY');
    const elExplodeY  = document.getElementById('explodeY');
    const elExplodeXYVal = document.getElementById('explodeXYVal');
    const elExplodeYVal  = document.getElementById('explodeYVal');
    if (elExplodeXY)    elExplodeXY.value = '0';
    if (elExplodeY)     elExplodeY.value  = '0';
    if (elExplodeXYVal) elExplodeXYVal.textContent = '0.00';
    if (elExplodeYVal)  elExplodeYVal.textContent  = '0.00';
    if (typeof applyExplode === 'function') applyExplode();

    // 2) sai do 2D com anima√ß√£o curta
    tweenFlatten2D(0, 220);

    // 3) restaura escala/opacidades
    if (torre && torre.userData.__baseScale){
      torre.scale.copy(torre.userData.__baseScale);
    }
    if (torre){
      torre.traverse(n=>{
        if (!n.material) return;
        if (n.isMesh && typeof n.userData.__baseOpacityMesh === 'number'){
          n.material.transparent = (n.userData.__baseOpacityMesh < 1.0);
          n.material.depthWrite  = !n.material.transparent;
          n.material.opacity     = n.userData.__baseOpacityMesh;
          n.material.needsUpdate = true;
        }
        if ((n.isLine || n.isLineSegments) && typeof n.userData.__baseOpacityLine === 'number'){
          n.material.transparent = (n.userData.__baseOpacityLine < 1.0);
          n.material.depthWrite  = !n.material.transparent;
          n.material.opacity     = n.userData.__baseOpacityLine;
          n.material.needsUpdate = true;
        }
      });
      delete torre.userData.__dogeBaseCached;
    }

    // 4) oculta overlay 2D
    if (typeof cards2d !== 'undefined' && cards2d){
      cards2d.style.opacity = '0';
      cards2d.style.pointerEvents = 'none';
    }
    // 5) canvas 3D volta a receber eventos
    if (renderer && renderer.domElement) {
      renderer.domElement.style.pointerEvents = 'auto';
    }

    // atualiza visual do bot√£o
    update2DButtonVisual();
  });
}


    // ================== [DOGE] Globais da grade 2D ==================
    let __aptRoots   = [];   // [{root, meta, base:{pos,rot,scale}}]
    let __gridModel  = null; // { floors:[], cols:[], map: Map("f|c" -> [aptos]) }
    let __cardsBuilt = false;

    // ================== [DOGE] Coleta de apartamentos (deriva floor/col) ==================
// ================== [DOGE] Coleta de apartamentos (deriva floor e guarda anchorX) ==================
// ================== [DOGE] Coleta de apartamentos (deriva floor e guarda anchorX/ordemcol) ==================
function collectApartmentRoots(){
  __aptRoots = [];
  if (!torre) return;

  const seen = new Set();
  torre.updateMatrixWorld(true);

  // Preferimos grupos (cada apto como um Group com levelIndex)
  const candidates = [];
  torre.traverse(n=>{
    if (n.type === 'Group' && typeof n.userData.levelIndex === 'number') candidates.push(n);
  });
  // Fallback: filhos diretos do 'torre' que sejam Group
  if (candidates.length === 0){
    for (const child of torre.children){
      if (child.isGroup) candidates.push(child);
    }
  }

  for (const root of candidates){
    if (seen.has(root.id)) continue;
    seen.add(root.id);

    // Pega meta do buildFromLayout (se foi populado l√°)
    const meta = root.userData.meta || (root.userData.meta = {});

    // floor: usa meta.floor; sen√£o levelIndex; fallback 0
    if (meta.floor == null){
      meta.floor = (typeof root.userData.levelIndex === 'number') ? root.userData.levelIndex : 0;
    }

    // guarda o anchor.x bruto (fallback para cluster por X se n√£o houver ordemcol)
    const ax = (root.userData.anchor && typeof root.userData.anchor.x === 'number')
                ? root.userData.anchor.x : 0;
    meta.__anchorX = ax;

    // id/nome b√°sicos
    if (!meta.id && root.userData.apto) meta.id = String(root.userData.apto);
    if (!meta.name) meta.name = meta.id || `apt-${root.id}`;

    // base transform
    if (!root.userData._base){
      root.userData._base = {
        pos: root.position.clone(),
        rot: root.rotation.clone(),
        scale: root.scale.clone()
      };
    }

    __aptRoots.push({ root, meta, base: root.userData._base });
  }
}


    // ================== [DOGE] Modelo da grade + cards ==================
    function colorFor(meta){
      // respeita seu mapa de cores existente (status ‚Üí cor) se houver
      if (meta && meta.status && window.COLOR_MAP?.colors?.[meta.status]) return window.COLOR_MAP.colors[meta.status];
      if (meta && meta.color) return meta.color;
      return '#6e7681';
    }

// ================== [DOGE] Modelo da grade (colunas por cluster de anchorX) ==================
// ================== [DOGE] Modelo da grade (prioriza ordemcol, sen√£o cluster por anchorX) ==================
function prepareGridModel(){
  if (!__aptRoots || !__aptRoots.length) return;

  // Se a maioria tiver ordemcol num√©rica, usamos isso.
  const hasOrdem = __aptRoots.some(A => Number.isFinite(Number(A.meta?.ordemcol)));
  if (hasOrdem){
    for (const A of __aptRoots){
      const col1 = Number(A.meta?.ordemcol);   // 1-based
      A.meta.__colIdx = Number.isFinite(col1) ? Math.max(0, Math.floor(col1 - 1)) : 0;
    }
  } else {
    // Fallback antigo: agrupa por X (anchor)
    const xs = __aptRoots.map(A => (typeof A.meta?.__anchorX === 'number') ? A.meta.__anchorX : 0);
    xs.sort((a,b)=>a-b);
    const COL_EPS = 0.001;
    const groups = [];
    for (const x of xs){
      const g = groups[groups.length-1];
      if (!g || Math.abs(x - g.center) > COL_EPS){
        groups.push({ center:x, values:[x] });
      } else {
        g.values.push(x);
        g.center = g.values.reduce((s,v)=>s+v,0)/g.values.length;
      }
    }
    function colIndexFor(x){
      if (groups.length === 0) return 0;
      let best = 0, bestD = Math.abs(x - groups[0].center);
      for (let i=1;i<groups.length;i++){
        const d = Math.abs(x - groups[i].center);
        if (d < bestD){ bestD = d; best = i; }
      }
      return best;
    }
    for (const A of __aptRoots){
      const x = (typeof A.meta?.__anchorX === 'number') ? A.meta.__anchorX : 0;
      A.meta.__colIdx = colIndexFor(x);
    }
  }

  // floors/cols/map
  const floors = new Set();
  const cols   = new Set();
  const map    = new Map();
  for (const A of __aptRoots){
    const f = Number(A.meta?.floor)   || 0;
    const c = Number(A.meta?.__colIdx)|| 0;
    floors.add(f); cols.add(c);
    const k = `${f}|${c}`;
    if (!map.has(k)) map.set(k, []);
    map.get(k).push(A);
  }

  const floorsArr = Array.from(floors).sort((a,b)=>b-a); // topo ‚Üí base
  const colsArr   = Array.from(cols).sort((a,b)=>a-b);   // 0..N-1

  // ordenar cada c√©lula por profundidade (zIndex/z): frente ‚Üí fundo
  for (const arr of map.values()){
    arr.sort((a,b)=>{
      const za = Number(a.meta?.zIndex || a.meta?.z || 0) || 0;
      const zb = Number(b.meta?.zIndex || b.meta?.z || 0) || 0;
      return za - zb;
    });
  }

  __gridModel = { floors: floorsArr, cols: colsArr, map };
}



function build2DCards(){
  if (!__aptRoots || !__aptRoots.length) return;
  if (!__gridModel) prepareGridModel();
  if (!__gridModel) return;

  cards2d.innerHTML = '';

  for (const A of __aptRoots){
    const el = document.createElement('div');
    el.className  = 'card';
    const idStr   = A.meta?.id || A.meta?.name || A.root.userData.apto || '';
    el.dataset.id = idStr;

    // cor pela FVS (igual ao 3D)
    const piso = (A.meta?.floor ?? A.root.userData.levelIndex ?? 0);
    el.style.background = pickFVSColor(idStr, piso);

    const lab = document.createElement('div');
    lab.className = 'label';
    lab.textContent = A.meta?.name || A.meta?.id || 'apt';
    el.appendChild(lab);

el.addEventListener('click', (ev)=>{
  ev.stopPropagation();
  const aptId = String(A.meta?.id || A.meta?.name || '').trim();
  let hex = null;
  try {
    const c = (A.root?.userData?.mesh?.material?.color);
    if (c) hex = '#' + c.getHexString();
  } catch(_) {}
  try {
    parent.postMessage({ type: 'viewer:open-apt', apt: aptId, color: hex }, '*');
  } catch(_) {}
});


    cards2d.appendChild(el);
    A.root.userData._cardEl = el;
  }
  __cardsBuilt = true;
}


// === [DOGE] M√©tricas responsivas da grade 2D (faz caber na tela) ===
function layout2D_computeMetrics(){
  const pad = 16;                         // margem interna do overlay
  const W = window.innerWidth, H = window.innerHeight;
  const usableW = Math.max(320, W - pad*2);
  const usableH = Math.max(260, H - pad*2);

  const floorsCount = (__gridModel?.floors?.length || 1);
  const colsCount   = (__gridModel?.cols?.length   || 1);

  // propor√ß√£o do card (w:h) ‚Äì ajuste se quiser outra ‚Äúsilhueta‚Äù
  const CARD_RATIO = 120/72;              // ~1.67
  const MIN_H = 40, MAX_H = 120;          // limites de altura do card
  const V_GAP_MIN = 6, V_GAP_MAX = 14;    // gap vertical
  const H_GAP_MIN = 10, H_GAP_MAX = 22;   // gap horizontal

  // come√ßa ‚Äúgrande‚Äù e reduz at√© caber a pilha inteira de pavimentos
  let cardH = Math.min(MAX_H, Math.floor(usableH / Math.max(1, floorsCount*0.9)));
  cardH = Math.max(MIN_H, cardH);
  let vGap = Math.min(V_GAP_MAX, Math.max(V_GAP_MIN, Math.floor(cardH*0.12)));

  const totalH = (h, gap) => floorsCount*h + Math.max(0, floorsCount-1)*gap;
  while (totalH(cardH, vGap) > usableH && cardH > MIN_H) cardH -= 1;
  while (totalH(cardH, vGap) > usableH && vGap  > V_GAP_MIN) vGap -= 1;

  const cardW = Math.floor(cardH * CARD_RATIO);
  let hGap = Math.min(H_GAP_MAX, Math.max(H_GAP_MIN, Math.floor(cardW*0.15)));

  const totalW = colsCount*cardW + Math.max(0, colsCount-1)*hGap;
  const originX = Math.floor((W - totalW)/2) + Math.floor(cardW/2);
  const totalHpx = totalH(cardH, vGap);
  const originY = Math.floor((H - totalHpx)/2) + Math.floor(cardH/2);

  return { cardW, cardH, vGap, hGap, originX, originY, floorsCount, colsCount };
}


// ================== [DOGE] Render 2D responsivo (colunas pr√≥ximas sem colis√£o) ==================

// === Render 2D: responsivo, SEM SCROLL, cabendo 100% na √°rea √∫til ===
function render2DCardsToScreen(tFade){
  if (!__gridModel) prepareGridModel();
  if (!__gridModel) return;
  if (!__cardsBuilt) build2DCards();

  const { floors, cols, map } = __gridModel;
  const rows    = floors.length;
  const colsLen = cols.length;
  if (!rows || !colsLen) return;

  // (A) mede HUD e configura overlay para terminar no topo do HUD
  const hud = document.getElementById('hud');
  const hudH = hud ? hud.offsetHeight : 0;

  const pane = cards2d; // seu #cards2d
  pane.style.position      = 'fixed';
  pane.style.top           = '0';
  pane.style.left          = '0';
  pane.style.right         = '0';
  
  pane.style.setProperty('bottom', `${hudH}px`, 'important');   // ENCOSTA no HUD
  pane.style.opacity       = String(tFade);
  pane.style.pointerEvents = (tFade > 0) ? 'auto' : 'none';
  pane.style.display       = (tFade > 0 ? 'block' : 'none');
  pane.style.overflowY     = 'hidden';      // ajusto abaixo se precisar

  // (B) mede a √°rea √∫til REAL do overlay (ap√≥s aplicar bottom)
  // for√ßa reflow
  // eslint-disable-next-line no-unused-expressions
  pane.offsetHeight;
  const availW = Math.max(240, pane.clientWidth);
  const availH = Math.max(180, pane.clientHeight);

  // (C) slots por pavimento (m√°ximo empilhado na coluna para aquele pav.)
  const slotsPerFloor = floors.map(f=>{
    let m = 1;
    for (let i=0;i<colsLen;i++){
      const arr = map.get(`${f}|${cols[i]}`) || [];
      if (arr.length > m) m = arr.length;
    }
    return m;
  });
  const sumSlots = slotsPerFloor.reduce((s,v)=>s+v,0);

  // (D) m√©tricas base
  const RATIO = 120/72;
  const MIN_W=44, MIN_H=18, MIN_FONT=8;

  let hGap = Math.max(8, Math.floor(availW * 0.012));
  let vGap = Math.max(6, Math.floor(availH * 0.012));

  let cardH = Math.floor((availH - Math.max(0, rows-1)*vGap) / Math.max(1, sumSlots));
  cardH = Math.max(MIN_H, cardH);
  let cardW = Math.max(MIN_W, Math.floor(cardH * RATIO));

  const totalW = () => colsLen*cardW + Math.max(0, colsLen-1)*hGap;
  const totalH = () => sumSlots*cardH + Math.max(0, rows-1)*vGap;

  // caber em largura
  let TW = totalW(), TH = totalH();
  if (TW > availW){
    const sx = availW / TW;
    cardW = Math.max(MIN_W, Math.floor(cardW * sx));
    hGap  = Math.max(6, Math.floor(hGap  * sx));
    TW = totalW(); TH = totalH();
  }

  // se n√£o couber em altura no m√≠nimo ‚Üí ativa scroll
  let useScroll = false, guard = 400;
  while (TH > availH && guard-- > 0){
    if (vGap > 2) vGap -= 1;
    else if (cardH > MIN_H) cardH -= 1;
    else { useScroll = true; break; }
    TW = totalW(); TH = totalH();
  }
  pane.style.overflowY = useScroll ? 'auto' : 'hidden';

  // (E) centraliza√ß√£o horizontal garantida no overlay
 const originX = Math.floor(availW/2);

  // vertical: centraliza se couber; sen√£o come√ßa do topo com respiro
  const padTop = 8;
  const originY = useScroll
    ? (padTop + Math.floor(cardH/2))
    : (Math.floor(availH/2 - TH/2) + Math.floor(cardH/2));

  // fonte + tamanho dos cards
  const fontPx = Math.max(MIN_FONT, Math.round(Math.min(cardW, cardH) * 0.18));
  for (const A of __aptRoots){
    const el = A.root.userData?._cardEl;
    if (!el) continue;
    el.style.width     = `${cardW}px`;
    el.style.height    = `${cardH}px`;
    el.style.fontSize  = `${fontPx}px`;
    el.style.opacity   = String(0.15 + 0.85*tFade);
    // mantemos o translate(-50%,-50%) do CSS
  }

  // (F) posicionamento por pavimento/coluna
  let cursorY = useScroll ? (originY - Math.floor(cardH/2)) : (originY - TH/2);
  for (let r=0; r<rows; r++){
    const f = floors[r];
    const bandH = slotsPerFloor[r] * cardH;
    const rowCenterY = cursorY + bandH/2;

    for (let cx=0; cx<colsLen; cx++){
      const key = `${f}|${cols[cx]}`;
      const arr = map.get(key) || [];
      const slots = Math.max(1, arr.length);

      const colCenterX = originX - (TW/2) + cx*(cardW + hGap) + cardW/2;
      const topBand = rowCenterY - (slots*cardH)/2;

      for (let k=0; k<arr.length; k++){
        const A = arr[k];
        const el = A.root.userData?._cardEl;
        if (!el) continue;

        const x = colCenterX;
        const y = topBand + cardH*(k + 0.5);

        el.style.left = `${x}px`;
        el.style.top  = `${y}px`;
      }
    }
    cursorY += bandH + (r < rows-1 ? vGap : 0);
  }

  if (useScroll) pane.scrollTop = 0;
}

(function watchHudAndRerender(){
  let lastHudH = -1;
  function tick(){
    const hud = document.getElementById('hud');
    const h = hud ? hud.offsetHeight : 0;
    if (flatten2D > 0 && h !== lastHudH){
      lastHudH = h;
      render2DCardsToScreen(flatten2D);
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();


    function hide2DCards(){
      cards2d.style.opacity = '0';
      cards2d.style.pointerEvents = 'none';
    }

    // Estado inicial
    opacityVal.textContent = (Number(opacity.value)/100).toFixed(2);
    setFaceOpacity(Number(opacity.value)/100);
    setFacesVisible(true);

    // ====== Cores herdadas do 2D ======
// ====== FVS ‚Üí mapa de cores unificado (3D + 2D) ======
let COLOR_MAP = {
  default: '#6e7681',
  colors:  {},       // { "301": "#RRGGBB", ... }
  byFloor: {}        // { "0": "#RRGGBB", ... } (por √≠ndice de pavimento num√©rico)
};

// ====== Disparo do modal de detalhes (comunica√ß√£o com index.html) ======
function doge_openDetails(aptoId, floorIdx){
  // Envia para o parent (index.html) abrir o modal
  try {
    parent.postMessage({
      type: 'open-fvs-modal',
      payload: {
        aptoId: String(aptoId ?? ''),
        floorIdx: Number.isFinite(floorIdx) ? Number(floorIdx) : null
      }
    }, '*');
  } catch (_) {}

  // Fallback local: se existir uma fun√ß√£o global no viewer, usa
  if (typeof window.openAptModal === 'function') {
    window.openAptModal({ id: String(aptoId ?? ''), floor: floorIdx });
  }
}

// Decide se o clique √© por apartamento ou por pavimento
// Regra: se houver cor espec√≠fica para o apto ‚Üí trata como apto;
// sen√£o, se houver cor para o pavimento ‚Üí trata como pavimento;
// se nada houver, ainda assim tenta abrir por apto.
function doge_decideAndOpen(aptoId, floorIdx){
  const idNorm = (aptoId != null) ? String(aptoId) : '';
  const hasApt = !!(COLOR_MAP.colors[idNorm] || COLOR_MAP.colors[normApto(idNorm)]);
  const hasFloor = !!COLOR_MAP.byFloor?.[String(floorIdx)];
  if (hasApt) {
    doge_openDetails(idNorm, null);
  } else if (hasFloor) {
    doge_openDetails(null, floorIdx);
  } else {
    doge_openDetails(idNorm, floorIdx);
  }
}


// Normaliza id do apartamento (mesma regra)
function normApto(s){
  if (s == null) return '';
  let t = String(s).trim().toUpperCase();
  t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
  t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
  t = t.replace(/[\s\-\._\/]/g, '');
  return t;
}

// Busca a cor da FVS para um apto/piso
function pickFVSColor(aptoId, floorIdx){
  const hexA = COLOR_MAP.colors[aptoId] || COLOR_MAP.colors[normApto(aptoId)];
  if (hexA && /^#?[0-9a-f]{6}$/i.test(hexA)) return hexA.startsWith('#') ? hexA : '#'+hexA;

  const hexF = COLOR_MAP.byFloor[String(floorIdx)];
  if (hexF && /^#?[0-9a-f]{6}$/i.test(hexF)) return hexF.startsWith('#') ? hexF : '#'+hexF;

  const defHex = COLOR_MAP.default || '#6e7681';
  return defHex.startsWith('#') ? defHex : '#'+defHex;
}

// Repinta as malhas 3D
function recolorMeshes3D(){
  if (!torre) return;
  for (const g of torre.children){
    const apt   = g.userData.apto || '';
    const floor = g.userData.levelIndex ?? 0;
    const hex   = pickFVSColor(apt, floor);

    const mat = g.userData.mesh.material;
    mat.color = new THREE.Color(hex);
    if (faceOpacity >= 0.999){
      mat.transparent = false;
      mat.depthWrite = true;
      mat.opacity = 1.0;
    } else {
      mat.transparent = true;
      mat.depthWrite = false;
      mat.opacity = faceOpacity;
    }
    mat.needsUpdate = true;
  }
}

// Repinta os cards 2D
function recolorCards2D(){
  if (!__aptRoots || !__aptRoots.length) return;
  for (const A of __aptRoots){
    const el = A.root.userData?._cardEl;
    if (!el) continue;
    const id   = A.meta?.id || A.meta?.name || A.root.userData.apto || '';
    const piso = (A.meta?.floor ?? A.root.userData.levelIndex ?? 0);
    el.style.background = pickFVSColor(id, piso);
  }
}

// Atualiza o mapa e repinta tudo (usado pelo main.html via postMessage)
function setFVSColorMap(payload){
  if (!payload) return;
  COLOR_MAP = {
    default: payload.default || '#6e7681',
    colors:  payload.colors  || {},
    byFloor: payload.byFloor || {}
  };
  recolorMeshes3D();
  recolorCards2D();
}

// Mant√©m compat√≠vel com o main.html j√° existente
window.addEventListener('message', (e)=>{
  const data = e.data || {};
  if (data.type === 'fvsColorMap') {
    setFVSColorMap(data.payload);
  }
});
try { parent.postMessage({ type: 'ready-3d' }, '*'); } catch(_) {}


    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      updateCamera();

      // [DOGE] se a transi√ß√£o 2D estiver ativa, reposiciona a grade
      if (typeof flatten2D !== 'undefined' && flatten2D > 0 && typeof render2DCardsToScreen === 'function') {
        render2DCardsToScreen(flatten2D);
      }
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>


