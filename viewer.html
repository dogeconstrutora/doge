<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>PrÃ©dio 3D â€” viewer (cores herdadas da FVS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0d1117; color: #c9d1d9; font-family: system-ui, sans-serif; }
    #app { position: fixed; inset: 0; }
    #hud {
      position: fixed; left: 12px; top: 12px; padding: 10px 12px;
      background: rgba(0,0,0,.45); backdrop-filter: blur(6px);
      border: 1px solid #30363d; border-radius: 10px; font-size: 14px; z-index: 10;
      display: grid; gap: 8px; width: max-content;
    }
    #hud .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .val { width: 3.6rem; text-align: right; display: inline-block; }
    button, label { user-select: none; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div class="row" id="dragHint">
      <b>Arraste</b> (esq = orbitar, dir = mover) â€¢ <b>Scroll</b> = zoom
    </div>
    <div class="row">
      <label><input id="wireOnly" type="checkbox" /> SÃ³ arame</label>
      <button id="resetRot">ðŸ”„ Resetar giro</button>
      <button id="recenter">ðŸŽ¯ Centralizar cÃ¢mera</button>
    </div>
    <div class="row">
      Opacidade: <input id="opacity" type="range" min="5" max="100" value="30" />
      <span id="opacityVal" class="val">0.30</span>
    </div>
    <div class="row">
      Explodir XY: <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
      <span id="explodeXYVal" class="val">0.00</span>
    </div>
    <div class="row">
      Explodir Y (piso): <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
      <span id="explodeYVal" class="val">0.00</span>
      <button id="resetExplode">Reset</button>
    </div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ====== Carrega o layout do repo ======
    const LAYOUT_URL = './data/layout-3d.json';
    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // ====== Setup ======
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== Ã“rbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();

    // Controles de mouse (esq=orbitar, dir=pan)
    let dragging=false,lastX=0,lastY=0, dragMode='orbit';
    function onDownMouse(e){
      dragMode = (e.button === 2) ? 'pan' : 'orbit';
      dragging = true; lastX = e.clientX; lastY = e.clientY;
    }
    function onMoveMouse(e){
      if(!dragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;

      if (dragMode === 'orbit') {
        pivot.rotation.y += dx * 0.005;
        theta = pivot.rotation.y;
        phi -= dy * 0.005; phi = clamp(phi, minPhi, maxPhi);
        updateCamera();
      } else {
        const panScale = radius * 0.0025;
        const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
        const up = new THREE.Vector3().copy(camera.up).normalize();
        orbitTarget.addScaledVector(right, -dx * panScale);
        orbitTarget.addScaledVector(up,    dy * panScale);
        updateCamera();
      }
    }
    function onUpMouse(){ dragging=false; }

    renderer.domElement.addEventListener('mousedown', onDownMouse);
    window.addEventListener('mousemove', onMoveMouse);
    window.addEventListener('mouseup', onUpMouse);
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Touch (1 dedo = orbitar)
    renderer.domElement.addEventListener('touchstart',e=>{
      if(e.touches.length===1){
        dragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; dragMode='orbit';
      }
    },{passive:true});
    renderer.domElement.addEventListener('touchmove',e=>{
      if(e.touches.length===1){
        onMoveMouse({ clientX:e.touches[0].clientX, clientY:e.touches[0].clientY });
      }
    },{passive:true});
    window.addEventListener('touchend',()=>{ dragging=false; });

    // Zoom
    renderer.domElement.addEventListener('wheel',e=>{
      e.preventDefault();
      const f=1+(e.deltaY>0?0.1:-0.1);
      radius=clamp(radius*f,minRadius,maxRadius);
      updateCamera();
    },{passive:false});

    // ====== Materiais com polygonOffset (linhas limpas, sem z-fighting) ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX = 0x6e7681;
    const MAT = {
      face: ()=> new THREE.MeshStandardMaterial({
        color: NEUTRAL_HEX,
        metalness: 0.05,
        roughness: 0.9,
        transparent: true,
        opacity: faceOpacity,
        depthWrite: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      }),
      line: new THREE.LineBasicMaterial({
        color: 0xcad7ff,
        linewidth: 1,
        depthTest: true,
        depthWrite: false,
        transparent: true,
        opacity: 0.95
      }),
      selLine: new THREE.LineBasicMaterial({
        color: 0xffc107,
        linewidth: 2
      })
    };

    function setFacesVisible(visible){
      for (const g of torre.children) g.userData.mesh.visible = visible;
    }
    
function setFaceOpacity(op){
  faceOpacity = op;
  for (const g of torre.children){
    const m = g.userData.mesh.material;
    m.opacity = faceOpacity;

    if (faceOpacity >= 0.999) {
      m.transparent = false;
      m.depthWrite = true;
      m.opacity = 1.0; // garante sÃ³lido
    } else {
      m.transparent = true;
      m.depthWrite = false;
    }
    m.needsUpdate = true;
  }
}

    // ===== DimensÃ£o bÃ¡sica em "mundo" =====
    const cellW = (layout.meta?.cellW ?? 1.2);
    const cellD = (layout.meta?.cellD ?? 1.2);
    const gap   = (layout.meta?.gap   ?? 0.15);

    const aptoHeight = 0.5;          // altura "unitÃ¡ria" por nÃ­vel
    const stepX = cellW + gap;
    const stepZ = cellD + gap;
    const stepY = aptoHeight + gap;

    function rectCenterX(x, w){ return x*stepX + (w*cellW + (w-1)*gap)/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*cellD + (d-1)*gap)/2; }

    // ===== Explodir =====
// ===== Explode (Ãºnica fonte de verdade) =====
let explodeXY = 0.0;
let explodeY  = 0.0;

// aplica explode atual Ã s posiÃ§Ãµes dos grupos
function applyExplode(){
  if (!torre || torre.children.length === 0) return;

  // Se ambos zero â†’ volta para as posiÃ§Ãµes coladas
  if ((explodeXY === 0 || !Number.isFinite(explodeXY)) &&
      (explodeY  === 0 || !Number.isFinite(explodeY))) {
    for (const g of torre.children) g.position.copy(g.userData.basePos);
    return;
  }

  // Centroide dos ANCHORS (nÃ£o das basePos)
  let sumX = 0, sumZ = 0, n = 0;
  for (const g of torre.children){
    const a = g.userData.anchor || g.userData.basePos;
    sumX += a.x; sumZ += a.z; n++;
  }
  const cx = n ? (sumX/n) : 0;
  const cz = n ? (sumZ/n) : 0;

  const step = Math.max(stepX, stepZ) || 1;

  for (const g of torre.children){
    const base = g.userData.basePos;            // onde fica "colado"
    const pos  = base.clone();

    // Explode radial no plano XZ a partir do centroide dos anchors
    if (explodeXY > 0){
      const a = g.userData.anchor || base;
      const dir = new THREE.Vector3(a.x - cx, 0, a.z - cz);
      const len = dir.length();
      if (len > 1e-6){
        dir.multiplyScalar(1/len);              // mesmo deslocamento p/ todos
        pos.addScaledVector(dir, explodeXY * step);
        // Se quiser proporcional ao raio, troque por:
        // pos.addScaledVector(dir, explodeXY * step * (len/Math.max(1, step)));
      }
    }

    // Explode vertical por pavimento
    if (explodeY !== 0){
      pos.y += (g.userData.levelIndex || 0) * explodeY;
    }

    g.position.copy(pos);
  }
}
    // ===== VoxelizaÃ§Ã£o por APTO =====
    function voxelizeByApto(l){
      const byApto = new Map();
      for (const p of l.placements){
        const apt = String(p.apto);
        if (!byApto.has(apt)) byApto.set(apt, new Set());
        const set = byApto.get(apt);
        const baseY = (typeof p.andar === 'number') ? p.andar : 0; // 'AT' => 0
        for (let gx = p.x; gx < p.x + p.w; gx++){
          for (let gz = p.z; gz < p.z + p.d; gz++){
            for (let gy = baseY; gy < baseY + p.h; gy++){
              set.add(`${gx},${gy},${gz}`);
            }
          }
        }
      }
      return byApto;
    }

    // ===== Meshing de fronteira (sem faces internas) =====
    function buildSurfaceGeometryFromOcc(occSet){
      if (!occSet || occSet.size===0) return null;
      const has = (x,y,z)=> occSet.has(`${x},${y},${z}`);

      const pos = [];
      const idx = [];
      let vbase = 0;

      const pushQuad = (a,b,c,d)=>{
        pos.push( ...a, ...b, ...c, ...d );
        idx.push(vbase, vbase+1, vbase+2,  vbase, vbase+2, vbase+3);
        vbase += 4;
      };

      function voxelBounds(gx,gy,gz){
        const x0 = gx * stepX, x1 = x0 + cellW;
        const z0 = gz * stepZ, z1 = z0 + cellD;
        const y0 = gy * stepY, y1 = y0 + aptoHeight;
        return {x0,x1,y0,y1,z0,z1};
      }

      for (const key of occSet){
        const [gx,gy,gz] = key.split(',').map(Number);
        const {x0,x1,y0,y1,z0,z1} = voxelBounds(gx,gy,gz);

        if (!has(gx-1,gy,gz)) pushQuad([x0,y0,z1],[x0,y0,z0],[x0,y1,z0],[x0,y1,z1]); // -X
        if (!has(gx+1,gy,gz)) pushQuad([x1,y0,z0],[x1,y0,z1],[x1,y1,z1],[x1,y1,z0]); // +X
        if (!has(gx,gy,gz-1)) pushQuad([x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]); // -Z
        if (!has(gx,gy,gz+1)) pushQuad([x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]); // +Z
        if (!has(gx,gy-1,gz)) pushQuad([x0,y0,z0],[x1,y0,z0],[x1,y0,z1],[x0,y0,z1]); // -Y
        if (!has(gx,gy+1,gz)) pushQuad([x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]); // +Y
      }

      if (pos.length===0) return null;

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
      geom.setIndex(new THREE.Uint32BufferAttribute(new Uint32Array(idx), 1));
      geom.computeVertexNormals();
      geom.computeBoundingBox(); geom.computeBoundingSphere();
      return geom;
    }

    // ===== Inflar para desenhar edges limpas =====
    function inflateGeometry(geom, offset=0.04){
      const g = geom.clone();
      g.computeVertexNormals();
      const pos = g.getAttribute('position');
      const nor = g.getAttribute('normal');
      for (let i=0;i<pos.count;i++){
        pos.setX(i, pos.getX(i) + nor.getX(i)*offset);
        pos.setY(i, pos.getY(i) + nor.getY(i)*offset);
        pos.setZ(i, pos.getZ(i) + nor.getZ(i)*offset);
      }
      pos.needsUpdate = true;
      return g;
    }

    // ====== ConstruÃ§Ã£o ======
function buildFromLayout(l){
  // limpa torre
  while (torre.children.length) torre.remove(torre.children[0]);

  // voxeliza por apartamento
  const occByApto = voxelizeByApto(l);

  for (const [apto, occ] of occByApto.entries()){
    const surface = buildSurfaceGeometryFromOcc(occ);
    if (!surface) continue;

    // material neutro (cores virÃ£o do FVS; opacidade coerente)
    const faceMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color(0x6e7681),
      metalness: 0.05,
      roughness: 0.9,
      transparent: faceOpacity < 0.999,
      opacity: Math.min(1, faceOpacity),
      depthWrite: faceOpacity >= 0.999,
      polygonOffset: true,
      polygonOffsetFactor: 1,
      polygonOffsetUnits: 1
    });

    const mesh = new THREE.Mesh(surface, faceMat);
    mesh.renderOrder = 1;

    // contorno limpo
    const inflated = inflateGeometry(surface, 0.04);
    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(inflated, 1), MAT.line);
    edges.renderOrder = 2;

    // pavimento mÃ­nimo (explodeY)
    let minLevel = Infinity;
    for (const key of occ){
      const gy = parseInt(key.split(',')[1],10);
      if (gy < minLevel) minLevel = gy;
    }
    if (!Number.isFinite(minLevel)) minLevel = 0;

    const group = new THREE.Group();
    group.add(mesh); group.add(edges);
    group.position.set(0,0,0);

    // guardaremos basePos e anchor apÃ³s centralizar tudo
    group.userData = {
      apto: String(apto),
      mesh, edges,
      levelIndex: minLevel,
      basePos: new THREE.Vector3(0,0,0),
      anchor:  new THREE.Vector3(0,0,0)
    };

    // jÃ¡ calcula o centro LOCAL da malha (em coords do geometry)
    surface.computeBoundingBox();
    const bb = surface.boundingBox;
    const localCenter = new THREE.Vector3();
    bb.getCenter(localCenter);                 // centro no espaÃ§o LOCAL do mesh
    group.__localCenter = localCenter;         // usamos depois para calcular o anchor
    torre.add(group);
  }

  // === Centraliza TODO o conjunto no (0,0,0) movendo os grupos
  const bbox = new THREE.Box3().setFromObject(torre);
  const center = new THREE.Vector3(); bbox.getCenter(center);
  const size   = new THREE.Vector3(); bbox.getSize(size);

  for (const g of torre.children){
    // posiÃ§Ã£o "colada" = antes era (0,0,0), agora deslocamos pelo centro global
    g.position.sub(center);
    // basePos = onde o grupo fica quando explode = 0
    g.userData.basePos.copy(g.position);

    // === ANCHOR: centro do apto em mundo colado
    // Como o geometry estÃ¡ em "coords globais", seu centro local (.__localCenter)
    // somado Ã  translation do grupo dÃ¡ o centro em "mundo colado".
    const lc = g.__localCenter || new THREE.Vector3();
    g.userData.anchor.set(
      g.position.x + lc.x,
      g.position.y + lc.y,
      g.position.z + lc.z
    );
    delete g.__localCenter; // limpeza
  }

  // === CÃ¢mera inicial baseada no tamanho real
  const diag = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
  const idealRadius = Math.max(8, diag * 0.75);
  radius = clamp(idealRadius, 4, 200);

  // Se quiser mirar pro meio da altura, use size.y*0.5
  orbitTarget.set(0, 0, 0);
  updateCamera();

  // Aplica estado atual do explode (zero â†’ colado)
  applyExplode();
}


    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }

    buildFromLayout(layout);

    // ====== SeleÃ§Ã£o com mira refinada ======
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      // 1) faces
      const faceObjects = torre.children.map(g => g.userData.mesh);
      raycaster.setFromCamera(mouse, camera);
      let inter = raycaster.intersectObjects(faceObjects, false);

      // 2) fallback em arestas
      if (!inter.length) {
        const edgeObjects = torre.children.map(g => g.userData.edges);
        raycaster.params.Line = raycaster.params.Line || {};
        raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06;
        inter = raycaster.intersectObjects(edgeObjects, false);
      }

      // limpar seleÃ§Ã£o anterior
      if (window.__SEL_GROUP__) {
        const gPrev = window.__SEL_GROUP__;
        gPrev.userData.edges.material = gPrev.__lineBackup;
        gPrev.userData.mesh.material = gPrev.__faceBackup;
        delete gPrev.__lineBackup; delete gPrev.__faceBackup;
        window.__SEL_GROUP__ = null;
      }

      if (inter.length) {
        const hitObj = inter[0].object;
        const selGroup = hitObj.parent;
        if (selGroup && selGroup.userData) {
          selGroup.__lineBackup = selGroup.userData.edges.material;
          selGroup.__faceBackup = selGroup.userData.mesh.material.clone();

          selGroup.userData.edges.material = MAT.selLine;

          const faceClone = selGroup.userData.mesh.material.clone();
          faceClone.opacity = Math.min(1, faceOpacity + 0.2);
          selGroup.userData.mesh.material = faceClone;

          window.__SEL_GROUP__ = selGroup;
          console.log('Selecionado:', selGroup.userData.apto);
        }
      }
    });

    // ====== UI ======
    const opacity = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    opacity.addEventListener('input', () => {
      const v = parseInt(opacity.value, 10)/100;
      opacityVal.textContent = v.toFixed(2);
      setFaceOpacity(v);
    });
    document.getElementById('wireOnly').addEventListener('change', (e) => setFacesVisible(!e.target.checked));
// === HUD: Explode ===
// === HUD ===
const wireOnly = document.getElementById('wireOnly');
wireOnly.addEventListener('change', (e) => setFacesVisible(!e.target.checked));

const opacity = document.getElementById('opacity');
const opacityVal = document.getElementById('opacityVal');
opacity.addEventListener('input', () => {
  const v = Number(opacity.value) / 100;
  opacityVal.textContent = v.toFixed(2);
  setFaceOpacity(v);
});

const explodeXYRange = document.getElementById('explodeXY');
const explodeXYVal   = document.getElementById('explodeXYVal');
explodeXYRange.addEventListener('input', () => {
  explodeXY = Number(explodeXYRange.value) || 0;
  explodeXYVal.textContent = explodeXY.toFixed(2);
  applyExplode();
});

const explodeYRange = document.getElementById('explodeY');
const explodeYVal   = document.getElementById('explodeYVal');
explodeYRange.addEventListener('input', () => {
  explodeY = Number(explodeYRange.value) || 0;
  explodeYVal.textContent = explodeY.toFixed(2);
  applyExplode();
});

const resetExplodeBtn = document.getElementById('resetExplode');
resetExplodeBtn.addEventListener('click', () => {
  explodeXY = 0; explodeY = 0;
  explodeXYRange.value = '0'; explodeYRange.value = '0';
  explodeXYVal.textContent = '0.00'; explodeYVal.textContent = '0.00';
  applyExplode();
});

// RotaÃ§Ã£o e recentrar
document.getElementById('resetRot').addEventListener('click', () => {
  pivot.rotation.set(0,0,0);
  theta = 0;
  updateCamera();
});
document.getElementById('recenter').addEventListener('click', () => {
  recenterOrbitTarget();
  radius = INITIAL_RADIUS; phi = INITIAL_PHI;
  updateCamera();
});

// Estado inicial
setFaceOpacity(Number(opacity.value)/100);
setFacesVisible(true);

    // ====== Cores herdadas do 2D ======
    function normApto(s){
      if (s == null) return '';
      let t = String(s).trim().toUpperCase();
      t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
      t = t.replace(/[\s\-\._\/]/g, '');
      return t;
    }
function aplicarCoresFVS(payload){
  if (!payload) return;

  // payload esperado:
  // {
  //   default: "#RRGGBB",           // opcional
  //   colors: { "301":"#...", ... },// por apartamento (normalizado ou nÃ£o)
  //   byFloor: { "0":"#...", "1":"#...", ... } // opcional: por pavimento (levelIndex)
  // }
  const defHex = (payload.default || '#6e7681').trim();
  const mapApto = payload.colors || {};
  const mapFloor = payload.byFloor || {};

  const pickColor = (aptoId, floorIdx) => {
    // 1) por apartamento (aceita normalizado ou original)
    const hexA = mapApto[aptoId] || mapApto[normApto(aptoId)];
    if (hexA && /^#?[0-9a-f]{6}$/i.test(hexA)) return hexA.startsWith('#') ? hexA : '#'+hexA;

    // 2) por pavimento (levelIndex)
    const hexF = mapFloor[String(floorIdx)];
    if (hexF && /^#?[0-9a-f]{6}$/i.test(hexF)) return hexF.startsWith('#') ? hexF : '#'+hexF;

    // 3) default
    return defHex.startsWith('#') ? defHex : '#'+defHex;
  };

  for (const g of torre.children){
    const apt = g.userData.apto || '';
    const floor = g.userData.levelIndex ?? 0;
    const hex = pickColor(apt, floor);

    const mat = g.userData.mesh.material;
    mat.color = new THREE.Color(hex);
    // garante estado sÃ³lido/translÃºcido coerente com a opacidade atual
    if (faceOpacity >= 0.999){
      mat.transparent = false;
      mat.depthWrite = true;
      mat.opacity = 1.0;
    } else {
      mat.transparent = true;
      mat.depthWrite = false;
      mat.opacity = faceOpacity;
    }
    mat.needsUpdate = true;
  }
}
    window.addEventListener('message', (e)=>{
      const data = e.data || {};
      if (data.type === 'fvsColorMap') {
        aplicarCoresFVS(data.payload);
      }
    });
    try { parent.postMessage({ type: 'ready-3d' }, '*'); } catch(_) {}

    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      updateCamera();
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>








