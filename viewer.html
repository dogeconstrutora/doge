<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Pr√©dio 3D viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0d1117; color: #c9d1d9; font-family: system-ui, sans-serif; }
    #app { position: fixed; inset: 0; }
    canvas { display:block; }

    /* === HUD (desktop por padr√É¬£o) === */
    #hud {
      position: fixed; left: 12px; top: 12px; padding: 10px 12px;
      background: rgba(0,0,0,.45); backdrop-filter: blur(6px);
      border: 1px solid #30363d; border-radius: 10px; font-size: 14px; z-index: 10;
      display: grid; gap: 8px; width: max-content;
      transition: transform .25s ease;
    }
    #hud .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .val { width: 3.6rem; text-align: right; display: inline-block; }
    button, label { user-select: none; }

    /* Al√É¬ßa (handle) e bot√É¬£o de toggle */
    #hud .handle { display:flex; align-items:center; gap:8px; cursor:grab; user-select:none; }
    #hud .grabber {
      width: 44px; height: 6px; border-radius: 4px;
      background: #58606b; opacity: .85;
      margin-right: 4px;
    }
    #hudToggle {
      border: 1px solid #30363d;
      background: #0d1117;
      color: #c9d1d9;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 13px;
      line-height: 1;
    }

    /* Estado recolhido (no mobile vira bottom sheet; no desktop, opcional) */
    #hud.collapsed { transform: translateY(0); } /* neutro no desktop */

    /* === Mobile: HUD como bottom sheet === */
    @media (max-width: 640px) {
      #hud {
        left: 0; right: 0; top: auto; bottom: 0;
        margin: 0 8px 8px;
        width: auto;
        border-radius: 12px;
        backdrop-filter: blur(8px);
        max-height: 65vh;
        overflow: auto;
        transform: translateY(0); /* expandido */
      }
      /* No mobile, recolhido = s√É¬≥ a √¢‚Ç¨≈ìal√É¬ßa√¢‚Ç¨¬ù vis√É¬≠vel (~40px) */
      #hud.collapsed {
        transform: translateY(calc(100% - 40px));
      }
    }

    /* Respeita usu√É¬°rios com movimento reduzido */
    @media (prefers-reduced-motion: reduce) {
      #hud { transition: none; }
    }

    /* O canvas deve receber todos os gestos (sem scroll/browser gestures) */
    canvas { touch-action: none; }

    /* O HUD pode rolar verticalmente, mas a al√É¬ßa n√É¬£o */
    #hud { touch-action: pan-y; }
    #hudHandle { touch-action: none; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div class="row handle" id="hudHandle">
      <div class="grabber" aria-hidden="true"></div>
      <span style="font-weight:600; flex:1;">Controles</span>
      <button id="hudToggle" aria-expanded="true" title="Recolher/Expandir">‚ñæ</button>
    </div>
    <div class="row" id="dragHint">
      <b>Arraste</b> (esq = orbitar, dir = mover) ‚Ä¢ <b>Scroll</b> = zoom
    </div>
    <div class="row">
      <label><input id="wireOnly" type="checkbox" /> S√≥ arame</label>
      <button id="resetRot">üîÑ Resetar giro</button>
      <button id="recenter">üéØ Centralizar c√¢mera</button>
    </div>
    <div class="row">
      Opacidade: <input id="opacity" type="range" min="5" max="100" value="30" />
      <span id="opacityVal" class="val">0.30</span>
    </div>
<div class="row">
  Explodir XY: <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
  <span id="explodeXYVal" class="val">0.00</span>
</div>
<div class="row">
  Explodir Y (piso): <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
  <span id="explodeYVal" class="val">0.00</span>
</div>
<div class="row">
  2D (explode‚Üígrid): <input id="flatten2D" type="range" min="0" max="1" step="0.01" value="0" />
  <span id="flatten2DVal" class="val">0.00</span>
</div>
<div class="row">
  <button id="resetExplode">Reset</button>
</div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ====== Carrega o layout do repo ======
    const LAYOUT_URL = './data/layout-3d.json';
    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // ====== Setup ======
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== √É‚Äúrbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();

    // ===== √É‚Äúrbita + Pan (mouse) + Pin√É¬ßa (zoom) e 2 dedos (pan) √¢‚Ç¨‚Äù Pointer Events =====
    let activePointers = new Map();     // pointerId -> {x,y}
    let dragging = false;
    let dragMode = 'orbit';
    let lastX = 0, lastY = 0;

    const ptsArr   = () => Array.from(activePointers.values());
    const centroid = (pts)=>({ x: pts.reduce((a,p)=>a+p.x,0)/pts.length,
                               y: pts.reduce((a,p)=>a+p.y,0)/pts.length });
    const dist     = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);

    let gesture = null; // { startDist, startRadius, lastCentroid }

    function pointerDown3D(e){
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      renderer.domElement.setPointerCapture(e.pointerId);

      const pts = ptsArr();
      if (pts.length === 1){
        // 1 dedo / 1 mouse: ORBIT (bot√É¬£o direito do mouse = pan)
        dragMode = (e.button === 2) ? 'pan' : 'orbit';
        dragging = true;
        lastX = e.clientX; lastY = e.clientY;
      } else if (pts.length === 2){
        // 2 dedos: pin√É¬ßa + pan do centroide
        const [p1,p2] = pts;
        gesture = {
          startDist:   dist(p1,p2),
          startRadius: radius,
          lastCentroid: centroid(pts)
        };
      }
      e.preventDefault();
    }

    function pointerMove3D(e){
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

      const pts = ptsArr();

      // 1 apontador (mouse/1 dedo)
      if (pts.length === 1 && dragging){
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        if (dragMode === 'orbit'){
          pivot.rotation.y += dx * 0.005;
          theta = pivot.rotation.y;
          phi   = clamp(phi - dy * 0.005, minPhi, maxPhi);
          updateCamera();
        } else {
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
          updateCamera();
        }
        e.preventDefault();
        return;
      }

      // 2 apontadores (pin√É¬ßa para zoom + centroide para pan)
      if (pts.length === 2 && gesture){
        const c  = centroid(pts);
        const d  = dist(pts[0], pts[1]);

        if (gesture.startDist > 0){
          // afastar dedos afasta a c√É¬¢mera (zoom out)
          const scale = d / gesture.startDist;
          const newR  = gesture.startRadius / Math.max(0.2, Math.min(5, scale));
          radius = clamp(newR, minRadius, maxRadius);
        }

        const dx = c.x - gesture.lastCentroid.x;
        const dy = c.y - gesture.lastCentroid.y;
        if (dx || dy){
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
        }

        gesture.lastCentroid = c;
        updateCamera();
        e.preventDefault();
        return;
      }
    }

    function pointerUp3D(e){
      if (activePointers.has(e.pointerId)){
        try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
        activePointers.delete(e.pointerId);
      }
      const pts = ptsArr();
      if (pts.length === 0){ dragging = false; gesture = null; }
      if (pts.length < 2){ gesture = null; }
      e.preventDefault();
    }

    renderer.domElement.addEventListener('pointerdown',   pointerDown3D,   {passive:false});
    renderer.domElement.addEventListener('pointermove',   pointerMove3D,   {passive:false});
    renderer.domElement.addEventListener('pointerup',     pointerUp3D,     {passive:false});
    renderer.domElement.addEventListener('pointercancel', pointerUp3D,     {passive:false});

    // bloqueia menu do bot√É¬£o direito (para pan no desktop)
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Scroll do mouse (zoom)
    renderer.domElement.addEventListener('wheel', e=>{
      e.preventDefault();
      const f = 1 + (e.deltaY>0 ? 0.1 : -0.1);
      radius = clamp(radius*f, minRadius, maxRadius);
      updateCamera();
    }, {passive:false});

    // ====== Materiais com polygonOffset (linhas limpas, sem z-fighting) ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX = 0x6e7681;
    const MAT = {
      face: ()=> new THREE.MeshStandardMaterial({
        color: NEUTRAL_HEX,
        metalness: 0.05,
        roughness: 0.9,
        transparent: true,
        opacity: faceOpacity,
        depthWrite: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      }),
      line: new THREE.LineBasicMaterial({
        color: 0xcad7ff,
        linewidth: 1,
        depthTest: true,
        depthWrite: false,
        transparent: true,
        opacity: 0.95
      }),
      selLine: new THREE.LineBasicMaterial({
        color: 0xffc107,
        linewidth: 2
      })
    };

    function setFacesVisible(visible){
      for (const g of torre.children) g.userData.mesh.visible = visible;
    }

    function setFaceOpacity(op){
      faceOpacity = op;
      for (const g of torre.children){
        const m = g.userData.mesh.material;
        m.opacity = faceOpacity;

        if (faceOpacity >= 0.999) {
          m.transparent = false;
          m.depthWrite = true;
          m.opacity = 1.0;
        } else {
          m.transparent = true;
          m.depthWrite = false;
        }
        m.needsUpdate = true;
      }
    }

    // ===== Dimens√É¬£o b√É¬°sica em "mundo" =====
    const cellW = (layout.meta?.cellW ?? 1.2);
    const cellD = (layout.meta?.cellD ?? 1.2);
    const gap   = (layout.meta?.gap   ?? 0.15);

    const aptoHeight = 0.5;          // altura "unit√É¬°ria" por n√É¬≠vel
    const stepX = cellW + gap;
    const stepZ = cellD + gap;
    const stepY = aptoHeight + gap;

    function rectCenterX(x, w){ return x*stepX + (w*cellW + (w-1)*gap)/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*cellD + (d-1)*gap)/2; }

    // ===== Explode (√É¬∫nica fonte de verdade) =====
    let explodeXY = 0.0;
    let explodeY  = 0.0;
    let flatten2D = 0.0;   // NOVO
    function applyExplode(){
      if (!torre || torre.children.length === 0) return;

      if ((explodeXY === 0 || !Number.isFinite(explodeXY)) &&
          (explodeY  === 0 || !Number.isFinite(explodeY))) {
        for (const g of torre.children) g.position.copy(g.userData.basePos);
        return;
      }

      // Centroide dos anchors
      let sumX = 0, sumZ = 0, n = 0;
      for (const g of torre.children){
        const a = g.userData.anchor || g.userData.basePos;
        sumX += a.x; sumZ += a.z; n++;
      }
      const cx = n ? (sumX/n) : 0;
      const cz = n ? (sumZ/n) : 0;

      const step = Math.max(stepX, stepZ) || 1;

      for (const g of torre.children){
        const base = g.userData.basePos;
        const pos  = base.clone();

        if (explodeXY > 0){
          const a = g.userData.anchor || base;
          const dir = new THREE.Vector3(a.x - cx, 0, a.z - cz);
          const len = dir.length();
          if (len > 1e-6){
            dir.multiplyScalar(1/len);
            pos.addScaledVector(dir, explodeXY * step);
          }
        }

        if (explodeY !== 0){
          pos.y += (g.userData.levelIndex || 0) * explodeY;
        }

        g.position.copy(pos);
      }
    }

    /* ===== [DOGE] Alvos 2D (grade por pavimento√ócoluna, faixas por zIndex) ===== */
let __doge2DTargetsBuilt = false;

function doge_build2DTargets() {
  if (!torre || !torre.children) return;

  // 1) Colete todos os meshes "aptos" (com meta) dentro de 'torre'
  /** @type {Array<THREE.Mesh>} */
  const apts = [];
  torre.traverse(o => {
    if (o && o.isMesh) apts.push(o);
  });

  if (!apts.length) return;

  // 2) Descubra floors e cols m√°ximos, e agrupe por c√©lula (floor|col)
  const byCell = new Map();
  let maxFloor = 0, maxCol = 0;

  for (const m of apts) {
    const meta = (m.userData && (m.userData.meta || m.userData)) || {};
    const floor = Number(meta.floor) || 1;
    const col   = Number(meta.col)   || 1;
    const zIdx  = Number(meta.zIndex || meta.z || 0) || 0;

    maxFloor = Math.max(maxFloor, floor);
    maxCol   = Math.max(maxCol,   col);

    const k = `${floor}|${col}`;
    if (!byCell.has(k)) byCell.set(k, []);
    byCell.get(k).push({ mesh:m, floor, col, zIndex:zIdx });
  }

  // 3) Ordene cada c√©lula por zIndex e calcule faixas (slots)
  const cellW = 140, cardW = 100, cardH = 60, cellH = 95;
  const marginX = -((maxCol - 1) * cellW) / 2;
  const marginY =  ((maxFloor) * cellH) / 2;

  for (const [k, arr] of byCell.entries()) {
    arr.sort((a,b)=> a.zIndex - b.zIndex);
    const [fStr, cStr] = k.split('|');
    const floor = +fStr, col = +cStr;
    const slots = arr.length;

    // Posi√ß√£o base da c√©lula (topo/centro no plano Z=0)
    const baseX = marginX + (col - 1) * cellW;
    const baseY = marginY - (floor - 1) * cellH;
    const stripeH = cardH / Math.max(1, slots);

    arr.forEach((it, idx) => {
      // Centro de cada faixa dentro do card
      const stripeCenterY = baseY - cardH/2 + idx*stripeH + stripeH/2;

      it.mesh.userData._2dTarget = {
        x: baseX,            // eixo X do centro do card (grid)
        y: stripeCenterY,    // eixo Y do centro da faixa
        z: 0,                // plano frontal (chapado)
        slots,
        stripeIndex: idx,
        w: cardW,
        h: stripeH
      };

      // Garanta tamb√©m uma base (caso falte)
      if (!it.mesh.userData._base) {
        it.mesh.userData._base = {
          pos: it.mesh.position.clone(),
          rot: it.mesh.rotation.clone(),
          scale: it.mesh.scale.clone()
        };
      }
    });
  }

  __doge2DTargetsBuilt = true;
}

    // ===== 3D ‚Üí 2D (explode‚Üíflatten‚Üígrid) ‚Äî STUB =====

    // ===== [DOGE] 3D ‚Üí 2D (0..0.5 explodeZ ; 0.5..1 flatten+grid) =====
function apply2DTransition() {
  const t = flatten2D || 0;
  const phase = (t <= 0.5) ? 0 : 1;
  const local = (phase === 0) ? (t / 0.5) : ((t - 0.5) / 0.5);

  if (!torre) return;

  // Constr√≥i targets 2D (uma vez ou sempre que necess√°rio)
  if (!__doge2DTargetsBuilt) doge_build2DTargets();

  // Intera√ß√£o: trava rota√ß√£o quando em transi√ß√£o para 2D
  if (typeof controls !== 'undefined' && controls) {
    controls.enableRotate = (t === 0);
    controls.enablePan    = true;
    controls.enableZoom   = true;
  }

  // Percorra todos os meshes aptos
  torre.traverse(o => {
    if (!o || !o.isMesh) return;

    // Bases e metas
    const base = (o.userData && (o.userData._base || {
      pos: o.position.clone(),
      rot: o.rotation.clone(),
      scale: o.scale.clone()
    })) || null;

    if (!o.userData._base) o.userData._base = base;

    const meta = (o.userData && (o.userData.meta || o.userData)) || {};
    const zIndex = Number(meta.zIndex || meta.z || 0) || 0;

    // Explode "B" (afasta por profundidade)
    const Bpos = base.pos.clone();
    Bpos.z += (zIndex * -120); // ajuste a dist√¢ncia conforme desejar

    if (phase === 0) {
      // A (base) ‚Üí B (explode Z)
      o.position.lerpVectors(base.pos, Bpos, local);

      // levezinha ‚Äúchapada‚Äù para sugerir camadas (opcional)
      const sZ = THREE.MathUtils.lerp(base.scale.z, base.scale.z * 0.85, local);
      o.scale.set(base.scale.x, base.scale.y, sZ);

    } else {
      // B (explodido) ‚Üí C (alvo 2D em grid, ‚Äúcard‚Äù chapado)
      const tgt = o.userData._2dTarget;
      if (!tgt) {
        // Sem alvo, s√≥ mantemos B
        o.position.copy(Bpos);
        o.scale.copy(base.scale);
        return;
      }

      // C: centro da faixa no plano z=0
      const Cpos = new THREE.Vector3(tgt.x, tgt.y, 0);

      // Interpola√ß√£o posi√ß√£o
      o.position.lerpVectors(Bpos, Cpos, local);

      // Flatten em Z e normaliza√ß√£o leve em X/Y (mantemos visual similar a "card")
      const scaleZ = THREE.MathUtils.lerp(base.scale.z * 0.85, 0.05, local);
      const scaleX = THREE.MathUtils.lerp(base.scale.x, 1.0, local);
      const scaleY = THREE.MathUtils.lerp(base.scale.y, 1.0, local);
      o.scale.set(scaleX, scaleY, scaleZ);
    }
  });
}
    // ===== Voxeliza√É¬ß√É¬£o por APTO =====
    function voxelizeByApto(l){
      const byApto = new Map();
      for (const p of l.placements){
        const apt = String(p.apto);
        if (!byApto.has(apt)) byApto.set(apt, new Set());
        const set = byApto.get(apt);
        const baseY = (typeof p.andar === 'number') ? p.andar : 0; // 'AT' => 0
        for (let gx = p.x; gx < p.x + p.w; gx++){
          for (let gz = p.z; gz < p.z + p.d; gz++){
            for (let gy = baseY; gy < baseY + p.h; gy++){
              set.add(`${gx},${gy},${gz}`);
            }
          }
        }
      }
      return byApto;
    }

    // ===== Meshing de fronteira (sem faces internas) =====
    function buildSurfaceGeometryFromOcc(occSet){
      if (!occSet || occSet.size===0) return null;
      const has = (x,y,z)=> occSet.has(`${x},${y},${z}`);

      const pos = [];
      const idx = [];
      let vbase = 0;

      const pushQuad = (a,b,c,d)=>{
        pos.push( ...a, ...b, ...c, ...d );
        idx.push(vbase, vbase+1, vbase+2,  vbase, vbase+2, vbase+3);
        vbase += 4;
      };

      function voxelBounds(gx,gy,gz){
        const x0 = gx * stepX, x1 = x0 + cellW;
        const z0 = gz * stepZ, z1 = z0 + cellD;
        const y0 = gy * stepY, y1 = y0 + aptoHeight;
        return {x0,x1,y0,y1,z0,z1};
      }

      for (const key of occSet){
        const [gx,gy,gz] = key.split(',').map(Number);
        const {x0,x1,y0,y1,z0,z1} = voxelBounds(gx,gy,gz);

        if (!has(gx-1,gy,gz)) pushQuad([x0,y0,z1],[x0,y0,z0],[x0,y1,z0],[x0,y1,z1]); // -X
        if (!has(gx+1,gy,gz)) pushQuad([x1,y0,z0],[x1,y0,z1],[x1,y1,z1],[x1,y1,z0]); // +X
        if (!has(gx,gy,gz-1)) pushQuad([x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]); // -Z
        if (!has(gx,gy,gz+1)) pushQuad([x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]); // +Z
        if (!has(gx,gy-1,gz)) pushQuad([x0,y0,z0],[x1,y0,z0],[x1,y0,z1],[x0,y0,z1]); // -Y
        if (!has(gx,gy+1,gz)) pushQuad([x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]); // +Y
      }

      if (pos.length===0) return null;

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
      geom.setIndex(new THREE.Uint32BufferAttribute(new Uint32Array(idx), 1));
      geom.computeVertexNormals();
      geom.computeBoundingBox(); geom.computeBoundingSphere();
      return geom;
    }

    // ===== Inflar para desenhar edges limpas =====
    function inflateGeometry(geom, offset=0.04){
      const g = geom.clone();
      g.computeVertexNormals();
      const pos = g.getAttribute('position');
      const nor = g.getAttribute('normal');
      for (let i=0;i<pos.count;i++){
        pos.setX(i, pos.getX(i) + nor.getX(i)*offset);
        pos.setY(i, pos.getY(i) + nor.getY(i)*offset);
        pos.setZ(i, pos.getZ(i) + nor.getZ(i)*offset);
      }
      pos.needsUpdate = true;
      return g;
    }

    // ====== Constru√É¬ß√É¬£o ======
    function buildFromLayout(l){
      // limpa torre
      while (torre.children.length) torre.remove(torre.children[0]);

      // voxeliza por apartamento
      const occByApto = voxelizeByApto(l);

      for (const [apto, occ] of occByApto.entries()){
        const surface = buildSurfaceGeometryFromOcc(occ);
        if (!surface) continue;

        // material neutro (cores vir√É¬£o do FVS; opacidade coerente)
        const faceMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x6e7681),
          metalness: 0.05,
          roughness: 0.9,
          transparent: faceOpacity < 0.999,
          opacity: Math.min(1, faceOpacity),
          depthWrite: faceOpacity >= 0.999,
          side: THREE.DoubleSide,   // preenche laterais
          polygonOffset: true,
          polygonOffsetFactor: 1,
          polygonOffsetUnits: 1
        });

        const mesh = new THREE.Mesh(surface, faceMat);
        mesh.renderOrder = 1;

        // contorno limpo
        const inflated = inflateGeometry(surface, 0.04);
        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(inflated, 1), MAT.line);
        edges.renderOrder = 2;

        // pavimento m√É¬≠nimo (explodeY)
        let minLevel = Infinity;
        for (const key of occ){
          const gy = parseInt(key.split(',')[1],10);
          if (gy < minLevel) minLevel = gy;
        }
        if (!Number.isFinite(minLevel)) minLevel = 0;

        const group = new THREE.Group();
        group.add(mesh); group.add(edges);
        group.position.set(0,0,0);

        // guardaremos basePos e anchor ap√É¬≥s centralizar tudo
        group.userData = {
          apto: String(apto),
          mesh, edges,
          levelIndex: minLevel,
          basePos: new THREE.Vector3(0,0,0),
          anchor:  new THREE.Vector3(0,0,0)
        };

        // centro local do geometry (para anchor depois)
        surface.computeBoundingBox();
        const bb = surface.boundingBox;
        const localCenter = new THREE.Vector3();
        bb.getCenter(localCenter);
        group.__localCenter = localCenter;

        torre.add(group);
      }

      // Centraliza todo o conjunto no (0,0,0)
      const bbox = new THREE.Box3().setFromObject(torre);
      const center = new THREE.Vector3(); bbox.getCenter(center);
      const size   = new THREE.Vector3(); bbox.getSize(size);

      for (const g of torre.children){
        g.position.sub(center);
        g.userData.basePos.copy(g.position);

        // anchor = centro do apto em mundo colado
        const lc = g.__localCenter || new THREE.Vector3();
        g.userData.anchor.set(
          g.position.x + lc.x,
          g.position.y + lc.y,
          g.position.z + lc.z
        );
        delete g.__localCenter;
      }

      // C√É¬¢mera inicial baseada no tamanho real
      const diag = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
      const idealRadius = Math.max(8, diag * 0.75);
      radius = clamp(idealRadius, minRadius, maxRadius);

      orbitTarget.set(0, 0, 0);
      updateCamera();

      // Aplica estado atual do explode (zero √¢‚Ä†‚Äô colado)
      applyExplode();
    }

    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }

    buildFromLayout(layout);

    // ====== Sele√É¬ß√É¬£o com mira refinada ======
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      // 1) faces
      const faceObjects = torre.children.map(g => g.userData.mesh);
      raycaster.setFromCamera(mouse, camera);
      let inter = raycaster.intersectObjects(faceObjects, false);

      // 2) fallback em arestas
      if (!inter.length) {
        const edgeObjects = torre.children.map(g => g.userData.edges);
        raycaster.params.Line = raycaster.params.Line || {};
        raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06;
        inter = raycaster.intersectObjects(edgeObjects, false);
      }

      // limpar sele√É¬ß√É¬£o anterior
      if (window.__SEL_GROUP__) {
        const gPrev = window.__SEL_GROUP__;
        gPrev.userData.edges.material = gPrev.__lineBackup;
        gPrev.userData.mesh.material = gPrev.__faceBackup;
        delete gPrev.__lineBackup; delete gPrev.__faceBackup;
        window.__SEL_GROUP__ = null;
      }

      if (inter.length) {
        const hitObj = inter[0].object;
        const selGroup = hitObj.parent;
        if (selGroup && selGroup.userData) {
          selGroup.__lineBackup = selGroup.userData.edges.material;
          selGroup.__faceBackup = selGroup.userData.mesh.material.clone();

          selGroup.userData.edges.material = MAT.selLine;

          const faceClone = selGroup.userData.mesh.material.clone();
          faceClone.opacity = Math.min(1, faceOpacity + 0.2);
          selGroup.userData.mesh.material = faceClone;

          window.__SEL_GROUP__ = selGroup;
          console.log('Selecionado:', selGroup.userData.apto);
        }
      }
    });

    // ====== HUD / UI ======
    const hud       = document.getElementById('hud');
    const hudToggle = document.getElementById('hudToggle');
    const hudHandle = document.getElementById('hudHandle');

    hudToggle.addEventListener('click', () => {
      const collapsed = hud.classList.toggle('collapsed');
      hudToggle.textContent = collapsed ? '‚ñ¥' : '‚ñæ';
      hudToggle.setAttribute('aria-expanded', String(!collapsed));
    });

    // Gesto vertical simples: arrastar a al√É¬ßa para recolher/expandir
    let hudDragId = null, hudStartY = 0, hudDy = 0;
    function hudPointerDown(e){
      hudDragId = e.pointerId;
      hudStartY = e.clientY; hudDy = 0;
      hudHandle.setPointerCapture(hudDragId);
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerMove(e){
      if (e.pointerId !== hudDragId) return;
      hudDy = e.clientY - hudStartY;
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerUp(e){
      if (e.pointerId !== hudDragId) return;
      if (hudDy > 30) {
        hud.classList.add('collapsed');
        hudToggle.textContent = '√¢‚Äì¬¥';
        hudToggle.setAttribute('aria-expanded', 'false');
      } else if (hudDy < -30) {
        hud.classList.remove('collapsed');
        hudToggle.textContent = '√¢‚Äì¬æ';
        hudToggle.setAttribute('aria-expanded', 'true');
      }
      try { hudHandle.releasePointerCapture(hudDragId); } catch(_){}
      hudDragId = null; hudDy = 0;
      e.preventDefault(); e.stopPropagation();
    }
    hudHandle.addEventListener('pointerdown', hudPointerDown, {passive:false});
    hudHandle.addEventListener('pointermove', hudPointerMove, {passive:false});
    hudHandle.addEventListener('pointerup',   hudPointerUp,   {passive:false});
    hudHandle.addEventListener('pointercancel', hudPointerUp, {passive:false});

    // Clique na al√É¬ßa alterna (bom no desktop)
    hudHandle.addEventListener('click', (e) => {
      if (e.target === hudToggle) return;
      hudToggle.click();
    });

    document.getElementById('wireOnly').addEventListener('change', (e) => setFacesVisible(!e.target.checked));

    const opacity = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    opacity.addEventListener('input', () => {
      const v = Number(opacity.value) / 100;
      opacityVal.textContent = v.toFixed(2);
      setFaceOpacity(v);
    });

    const explodeXYRange = document.getElementById('explodeXY');
    const explodeXYVal   = document.getElementById('explodeXYVal');
    explodeXYRange.addEventListener('input', () => {
      explodeXY = Number(explodeXYRange.value) || 0;
      explodeXYVal.textContent = explodeXY.toFixed(2);
      applyExplode();
    });

    const explodeYRange = document.getElementById('explodeY');
    const explodeYVal   = document.getElementById('explodeYVal');
    explodeYRange.addEventListener('input', () => {
      explodeY = Number(explodeYRange.value) || 0;
      explodeYVal.textContent = explodeY.toFixed(2);
      applyExplode();
    });
    
const flatten2DRange = document.getElementById('flatten2D');
const flatten2DVal   = document.getElementById('flatten2DVal');
if (flatten2DRange && flatten2DVal){
  flatten2DRange.addEventListener('input', () => {
    flatten2D = Number(flatten2DRange.value) || 0;
    flatten2DVal.textContent = flatten2D.toFixed(2);
    apply2DTransition();
  });
}
    // Reset explode/2D e volta cada mesh √† base
document.getElementById('resetExplode')?.addEventListener('click', () => {
  explodeXY = 0;
  explodeY  = 0;
  flatten2D = 0;

  // sliders (se existirem)
  const ex = document.getElementById('explodeXY');
  const ey = document.getElementById('explodeY');
  const f2 = document.getElementById('flatten2D');
  const vx = document.getElementById('explodeXYVal');
  const vy = document.getElementById('explodeYVal');
  const v2 = document.getElementById('flatten2DVal');

  if (ex) ex.value = '0';
  if (ey) ey.value = '0';
  if (f2) f2.value = '0';

  if (vx) vx.textContent = '0.00';
  if (vy) vy.textContent = '0.00';
  if (v2) v2.textContent = '0.00';

  // libera rota√ß√£o
  if (typeof controls !== 'undefined' && controls) {
    controls.enableRotate = true;
  }

  // volta cada mesh para a base
  if (torre) {
    torre.traverse(o => {
      if (!o || !o.isMesh) return;
      const base = o.userData && o.userData._base;
      if (base) {
        o.position.copy(base.pos);
        o.rotation.copy(base.rot);
        o.scale.copy(base.scale);
      }
    });
  }
});

    document.getElementById('resetRot').addEventListener('click', () => {
      pivot.rotation.set(0,0,0);
      theta = 0;
      updateCamera();
    });

    document.getElementById('recenter').addEventListener('click', () => {
      recenterOrbitTarget();
      radius = INITIAL_RADIUS; phi = INITIAL_PHI;
      updateCamera();
    });

    // Estado inicial
    opacityVal.textContent = (Number(opacity.value)/100).toFixed(2);
    setFaceOpacity(Number(opacity.value)/100);
    setFacesVisible(true);

    // ====== Cores herdadas do 2D ======
    function normApto(s){
      if (s == null) return '';
      let t = String(s).trim().toUpperCase();
      t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
      t = t.replace(/[\s\-\._\/]/g, '');
      return t;
    }
    function aplicarCoresFVS(payload){
      if (!payload) return;

      // payload:
      // { default:"#RRGGBB", colors:{ "301":"#..." }, byFloor:{ "0":"#..." } }
      const defHex   = (payload.default || '#6e7681').trim();
      const mapApto  = payload.colors || {};
      const mapFloor = payload.byFloor || {};

      const pickColor = (aptoId, floorIdx) => {
        const hexA = mapApto[aptoId] || mapApto[normApto(aptoId)];
        if (hexA && /^#?[0-9a-f]{6}$/i.test(hexA)) return hexA.startsWith('#') ? hexA : '#'+hexA;

        const hexF = mapFloor[String(floorIdx)];
        if (hexF && /^#?[0-9a-f]{6}$/i.test(hexF)) return hexF.startsWith('#') ? hexF : '#'+hexF;

        return defHex.startsWith('#') ? defHex : '#'+defHex;
      };

      for (const g of torre.children){
        const apt   = g.userData.apto || '';
        const floor = g.userData.levelIndex ?? 0;
        const hex   = pickColor(apt, floor);

        const mat = g.userData.mesh.material;
        mat.color = new THREE.Color(hex);
        if (faceOpacity >= 0.999){
          mat.transparent = false;
          mat.depthWrite = true;
          mat.opacity = 1.0;
        } else {
          mat.transparent = true;
          mat.depthWrite = false;
          mat.opacity = faceOpacity;
        }
        mat.needsUpdate = true;
      }
    }
    window.addEventListener('message', (e)=>{
      const data = e.data || {};
      if (data.type === 'fvsColorMap') {
        aplicarCoresFVS(data.payload);
      }
      if (data.type === 'doge-2d-set') {
  flatten2D = Number(data.t) || 0;
  const r = document.getElementById('flatten2D');
  const v = document.getElementById('flatten2DVal');
  if (r) r.value = String(flatten2D);
  if (v) v.textContent = flatten2D.toFixed(2);
  apply2DTransition();
}
    });
    try { parent.postMessage({ type: 'ready-3d' }, '*'); } catch(_) {}
try { parent.postMessage({ type: 'doge-2d-ready' }, '*'); } catch(_) {}
    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      updateCamera();
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>




