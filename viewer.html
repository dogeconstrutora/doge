<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Prédio 3D — viewer (cores herdadas da FVS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<style>
  /* ===== Theme tokens ===== */
  :root{
    --bg:#0d1117;
    --card:#161b22;
    --text:#c9d1d9;
    --muted:#8b949e;
    --border:#30363d;
    --blue:#58a6ff;
    --green:#238636;
    --yellow:#d29922;
    --gray:#6e7681;
    --red:#f85149;
    --red-strong:#ff3b30; /* realce ON para NC */
  }

  /* ===== Base ===== */
  html, body { height: 100%; margin: 0; }
  body{
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial, sans-serif;
  }
  #app { position: fixed; inset: 0; }
  canvas { display: block; touch-action: none; }
  html, body { overscroll-behavior: contain; }

  /* ===== Overlay 2D ===== */
  #cards2d{
    position: fixed; inset: 0;
    z-index: 9;
    pointer-events: none;
    opacity: 0;
    overflow-x: hidden; overflow-y: auto;
  }
  #cards2d .card{
    position: absolute;
    width: 120px; height: 72px;
    display: flex; align-items: center; justify-content: center;
    transform: translate(-50%, -50%);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.18);
    background: rgba(34,40,53,.92);
    color: #e6eef7;
    box-shadow: 0 8px 24px rgba(0,0,0,.35);
    font: 12px/1.2 system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial;
    user-select: none; cursor: pointer; pointer-events: auto;
  }
  #cards2d .card .num{
    position: absolute; inset: 0;
    display: flex; align-items: center; justify-content: center;
    font-weight: 700; font-size: 14px;
    opacity: 0; transition: opacity .12s ease;
  }
  #cards2d .card .dur{
    position: absolute; right: 8px; bottom: 6px;
    font-size: 11px; line-height: 1; opacity: .95;
    padding: 2px 6px; border-radius: 999px;
    background: rgba(0,0,0,.28);
    border: 1px solid rgba(255,255,255,.12);
    transition: opacity .12s ease;
  }
  #cards2d .card:hover .num { opacity: 1; }
  #cards2d .card:hover .dur { opacity: 0; }

  /* ===== HUD (rodapé) ===== */
  #hud{
    position: fixed; left: 0; right: 0; bottom: 0;
    z-index: 20;
    display: flex; flex-wrap: wrap;
    gap: 6px;
    align-items: center; justify-content: center;
    padding: 6px 8px;
    background: rgba(0,0,0,.45);
    -webkit-backdrop-filter: blur(6px);
    backdrop-filter: blur(6px);
    color: #fff;
    border-top: 1px solid var(--border);
    border-radius: 10px 10px 0 0;
    font-size: 13px;
    touch-action: pan-y;
  }
  #hud .row{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  #hud .handle{ display:flex; align-items:center; gap:8px; cursor:grab; user-select:none; }
  #hud .grabber{ width:40px; height:5px; border-radius:4px; background:#58606b; opacity:.85; margin-right:4px; }
  #hudToggle{
    border: 1px solid var(--border);
    background: var(--bg);
    color: var(--text);
    border-radius: 8px;
    padding: 3px 6px;
    font-size: 12px; line-height: 1;
  }
  #hud.collapsed .row:not(.handle){ display:none; }
  #hud button, #hud input, #hud label { touch-action: manipulation; }

  /* Sliders */
  #hud input[type="range"]{
    width: clamp(120px, 35vw, 180px);
    height: 4px;
  }

  /* Botões “emoji” & demais botões do HUD */
  #hud .row > button{
    appearance: none; -webkit-appearance: none;
    background: rgba(240,246,252,0.06);
    color: #e6eef7;
    border: 1px solid rgba(240,246,252,0.15);
    border-radius: 10px;
    padding: clamp(6px, 1.6vh, 8px) clamp(10px, 3.5vw, 12px);
    height: auto; min-height: 32px; min-width: 32px;
    line-height: 1;
    font: 600 clamp(12px, 3.3vw, 14px)/1 system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial;
    display: inline-flex; align-items: center; justify-content: center;
    cursor: pointer;
    transition: filter .12s ease, background-color .15s ease, border-color .15s ease, transform .06s ease, box-shadow .15s ease;
  }
  #hud .row > button:hover{
    background: rgba(240,246,252,0.10);
    border-color: rgba(240,246,252,0.18);
  }
  #hud .row > button:active{ transform: scale(0.98); }
  #hud .row > button:focus{ outline: none; }
  #hud .row > button:focus-visible{ box-shadow: 0 0 0 2px rgba(88,166,255,.25); }

  /* Botão 2D (SVG) */
  :root{ --c-2d-off:#8b949e; --c-2d-on:#ff3b30; }
#btn2D.mode2d{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;

  border: 1px solid var(--border);
  border-radius: 10px;
  background: var(--bg);
  color: var(--c-2d-off);

  font-weight: 600;
  font-size: clamp(12px, 3.3vw, 14px);

  padding: clamp(6px, 1.6vh, 8px) clamp(10px, 3.5vw, 12px);
  line-height: 1;
  height: auto;
  min-height: 32px;
  min-width: clamp(48px, 16vw, 72px);

  cursor: pointer;
  user-select: none;
  transition: color .18s ease, box-shadow .18s ease, border-color .18s ease, transform .1s;
}
#btn2D.mode2d:hover{
  border-color:#3a3f46;
  background: rgba(240,246,252,0.08);
}
#btn2D.mode2d.active{
  color: var(--c-2d-on);
  box-shadow: 0 0 0 2px rgba(255,59,48,.18), 0 4px 16px rgba(255,59,48,.25);
  border-color: rgba(255,59,48,.55);
}
  #btn2D.mode2d svg{ width:18px; height:18px; }
  #btn2D.mode2d .badge{ fill:none; stroke:currentColor; stroke-width:2; opacity:.38; }
  #btn2D.mode2d .label{ fill:currentColor; font:700 13px/1 system-ui,-apple-system,"Segoe UI",Roboto,Inter,Arial; }

  /* ===== Botão NC (bonito, estável e responsivo) ===== */
  #btnNC{
    display:inline-flex; align-items:center; justify-content:center;
    white-space: nowrap;
    border: 1px solid rgba(240,246,252,0.15);
    border-radius: 10px;
    background: rgba(240,246,252,0.06);
    color: #c9d1d9;
    font-weight: 600;
    font-size: clamp(12px, 3.3vw, 14px);
    padding: clamp(6px, 1.6vh, 8px) clamp(10px, 3.5vw, 12px);
    line-height: 1;
    height: auto;
    min-width: clamp(48px, 16vw, 72px);
    cursor: pointer;
    transition: background-color .2s, color .2s, border-color .2s, box-shadow .2s, transform .1s;
  }
  #btnNC:hover{ background: rgba(240,246,252,0.10); }
  #btnNC:active{ transform: scale(0.98); }
  #btnNC.active{
    background: var(--red-strong);
    color: #fff;
    border-color: var(--red-strong);
    box-shadow: 0 0 12px rgba(255,59,48,0.35);
  }

  /* ===== Dropdown FVS (consistente com NC + responsivo) ===== */
  #hud label{
    font-size: clamp(12px, 3.3vw, 14px);
    white-space: nowrap;
  }
  #fvsSelect{
    appearance: none; -webkit-appearance: none; -moz-appearance: none;
    background: rgba(240,246,252,0.06);
    color: #e6eef7;
    border: 1px solid rgba(240,246,252,0.15);
    border-radius: 10px;
    padding: clamp(8px, 1.6vh, 10px) clamp(28px, 6vw, 36px) clamp(8px, 1.6vh, 10px) clamp(10px, 3.5vw, 12px);
    height: auto; min-height: 32px;
    min-width: 0; width: min(60vw, 320px); max-width: 100%;
    font: 500 clamp(12px, 3.3vw, 14px)/1.2 system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial;
    line-height: 1.2;
    cursor: pointer;
    transition: background-color .2s, border-color .2s, box-shadow .2s;
    color-scheme: dark; /* ajuda a forçar popup escuro em UAs compatíveis */
  }
  #fvsSelect:hover{ background: rgba(240,246,252,0.10); border-color: rgba(240,246,252,0.18); }
  #fvsSelect:focus{
    outline: none;
    border-color: #58a6ff;
    box-shadow: 0 0 0 3px rgba(88,166,255,.22);
  }
  /* Menu de opções (melhor legibilidade no escuro) */
  #fvsSelect option{
    background: #0d1117;
    color: #e6eef7;
    font: 500 13px system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial;
    padding: 6px 10px;
  }
  #fvsSelect option:checked{
    background-color: #238636;
    color: #fff;
  }

  /* Linha que contém FVS + NC pode quebrar bem no mobile */
  #row-fvs{
    display: flex; align-items: center;
    gap: clamp(6px, 2.8vw, 10px);
    flex-wrap: wrap;
    min-width: 0;
  }

  /* ===== Modal (única definição — sem duplicações) ===== */
  #doge-modal-backdrop{
    position: fixed; inset: 0;
    display: none;
    z-index: 10000;
    justify-content: center; align-items: center;
    background: rgba(13,17,23,0.35);
    -webkit-backdrop-filter: blur(14px) saturate(120%);
    backdrop-filter: blur(14px) saturate(120%);
    animation: fadeIn .25s ease;
  }
  @keyframes fadeIn{ from{opacity:0} to{opacity:1} }

  #doge-modal{
    position: relative;
    box-sizing: border-box;
    width: clamp(280px, 90vw, 520px);
    max-height: 80vh; overflow: auto;
    margin: 0;
    padding: 14px 16px;            /* compacto (modal menor) */
    line-height: 1.35;             /* menor espaçamento vertical */
    border-radius: 16px;
    background:
      linear-gradient(135deg, var(--modal-tint-strong, rgba(88,166,255,0.20)), transparent 60%),
      linear-gradient( 45deg, var(--modal-tint-soft,   rgba(88,166,255,0.10)), transparent 55%),
      rgba(22,27,34,0.40);
    border: 1px solid var(--modal-border, rgba(240,246,252,0.08));
    box-shadow: 0 10px 30px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.03);
    color: var(--text);
    font-size: 14px;
    animation: slideUp .25s ease;
  }
  @keyframes slideUp{ from{ transform:translateY(10px); opacity:0 } to{ transform:translateY(0); opacity:1 } }
  #doge-modal::-webkit-scrollbar{ width:0; height:0 }
  #doge-modal{ scrollbar-width:none; -ms-overflow-style:none; }

  #doge-modal h3{
    margin: 0 0 10px;
    font-weight: 600; font-size: 18px; color: #f0f6fc;
    border-bottom: 1px solid rgba(240,246,252,0.06);
    padding-bottom: 6px;           /* mais compacto */
    text-align: left;
  }
  #doge-modal .close{
    position: absolute; top: 10px; right: 10px;
    background: rgba(240,246,252,0.04);
    border: 1px solid rgba(240,246,252,0.08);
    color: #f0f6fc; font-size: 16px; font-weight: 700; line-height: 1;
    padding: 6px 10px; border-radius: 10px;
    cursor: pointer;
    transition: transform .12s ease, background-color .15s ease, border-color .15s ease;
    -webkit-backdrop-filter: blur(2px); backdrop-filter: blur(2px);
  }
  #doge-modal .close:hover{
    background: rgba(240,246,252,0.08);
    border-color: rgba(240,246,252,0.14);
    transform: scale(1.03);
  }

  /* Tabela mais compacta */
  #doge-modal table{ width:100%; border-collapse:collapse; margin-top:6px; font-size:12px; }
  #doge-modal th, #doge-modal td{
    text-align:left; padding:4px 2px;
    border-bottom:1px solid rgba(240,246,252,0.06);
  }
  #doge-modal th{ color: var(--muted); font-weight: 500; }
  #doge-modal td{ color: var(--text); }

  /* Link “Última inspeção” */
  #doge-modal a.link-row{
    color: inherit; text-decoration: none;
    display: inline-flex; align-items: center; gap: 8px;
    padding: 2px 6px; border-radius: 8px;
    transition: background-color .15s ease, transform .05s ease;
    vertical-align: middle;
  }
  #doge-modal a.link-row:hover{ background-color: rgba(240,246,252,0.06); }
  #doge-modal a.link-row:active{ transform: scale(0.99); }
  #doge-modal a.link-row svg{ width:14px; height:14px; stroke:currentColor; }

  /* Progress bar */
  .q-linear-progress{ display:flex; align-items:center; gap:8px; padding:4px 6px; border-radius:10px; background:rgba(240,246,252,0.06); border:1px solid rgba(240,246,252,0.10); }
  .q-linear-progress__track{ position:relative; flex:1; height:6px; background:rgba(240,246,252,0.08); border:1px solid rgba(240,246,252,0.10); border-radius:999px; overflow:hidden; }
  .q-linear-progress__bar{ position:absolute; inset:0 100% 0 0; background:currentColor; transition:width .45s ease; }
  .q-linear-progress__label{ font-variant-numeric:tabular-nums; min-width:3ch; text-align:right; font-size:11px; }
  .line-progress{ display:flex; align-items:center; gap:10px; }
  .line-progress .q-linear-progress{ margin-left:auto; min-width:96px; max-width:140px; }

  /* ===== Responsividade adicional ===== */
  @media (min-width: 900px){
    #hud{ flex-wrap: nowrap; padding: 8px 10px; gap: 10px; }
  }
  @media (max-width: 480px){
    #hud{ gap: 6px; padding: 6px 8px; }
    #hud .row{ gap: 6px; }
    #fvsSelect{ width: min(70vw, 360px); }
  }
</style>

</head>
<body>
  <div id="app"><div id="cards2d"></div></div>
  <div id="doge-loading" style="
  position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
  background: rgba(0,0,0,.35); z-index: 3500; color:#e6eef7; font: 500 14px system-ui;">
  Carregando dados…
</div>

<!-- Modal nativo do viewer -->
<!-- Modal nativo do viewer (AGORA aninhado no backdrop) -->
<div id="doge-modal-backdrop">
  <div id="doge-modal" role="dialog" aria-modal="true" aria-labelledby="doge-modal-title">
    <header>
      <h3 id="doge-modal-title">Detalhes do Apartamento</h3>
      <span class="pill" id="doge-modal-pill"></span>
      <button class="close" id="doge-modal-close" type="button">✕</button>
    </header>
    <div class="content" id="doge-modal-content"></div>
  </div>
</div>


<div id="doge-tip" role="tooltip" aria-hidden="true"></div>

  <div id="hud">
    <div class="row handle" id="hudHandle">
      <div class="grabber" aria-hidden="true"></div>
      <span style="font-weight:600; flex:1;">Controles</span>
      <button id="hudToggle" aria-expanded="true" title="Recolher/Expandir">▾</button>
    </div>
    <div class="row" id="row-fvs">
      <label for="fvsSelect" title="Selecionar FVS">FVS</label>
      <select id="fvsSelect">
        <option value="">Carregando...</option>
      </select>
      <button id="btnNC" type="button" title="Mostrar apenas NC">NC</button>
    </div>
    <div class="row">
      <button id="resetRot">🔄</button>
      <button id="recenter">🎯</button>
    </div>
    <div class="row">
      <label for="opacity" title="Opacidade">🌫️</label>
      <input id="opacity" type="range" min="0" max="100" value="100" />
    </div>
    <div class="row">
      <label for="explodeXY" title="Explodir XY">⤢</label>
      <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
    </div>
    <div class="row">
      <label for="explodeY" title="Explodir por piso (Y)">⬆️</label>
      <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
      <button id="resetExplode">Reset</button>
    </div>
    <div class="row">
      <button id="btn2D" class="mode2d" title="Alternar visualização 2D">
        <svg viewBox="0 0 48 48" aria-hidden="true" focusable="false">
          <circle class="badge" cx="24" cy="24" r="20"></circle>
          <text class="label" x="24" y="29" text-anchor="middle">2D</text>
        </svg>
      </button>
    </div>
  </div>
<div id="legend" aria-hidden="true"></div>
  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  
  (async function(){
    // ====== Carrega o layout ======
    const LAYOUT_URL = './data/layout-3d.json';
    const FVS_LIST_URL = './data/fvs-list.json';
const APTS_URL     = './data/apartamentos.json';

// === TDZ guards: declarar cedo para evitar "Cannot access ... before initialization"
let COLOR_MAP = { default: '#6e7681', colors: {}, byFloor: {} };
let META_MAP = new Map();

// Tooltip
const tipEl = document.getElementById('doge-tip');
let tipVisible = false;
let tipHideTO = null;

function showTip(x, y, text){
  if (!tipEl) return;
  tipEl.textContent = text || '';
  if (!text) { hideTip(); return; }

  // posiciona (protege bordas)
  const pad = 10;
  const W = innerWidth, H = innerHeight;
  let tx = Math.max(pad, Math.min(W - pad, x));
  let ty = Math.max(pad, Math.min(H - pad, y));
  tipEl.style.left = tx + 'px';
  tipEl.style.top  = ty + 'px';

  tipEl.style.opacity = '1';
  tipEl.setAttribute('aria-hidden', 'false');
  tipVisible = true;

  if (tipHideTO) { clearTimeout(tipHideTO); tipHideTO = null; }
}

function hideTip(delay=0){
  if (!tipEl || !tipVisible) return;
  if (tipHideTO) clearTimeout(tipHideTO);
  tipHideTO = setTimeout(()=>{
    tipEl.style.opacity = '0';
    tipEl.setAttribute('aria-hidden', 'true');
    tipVisible = false;
  }, delay);
}


// ==== Deep link & Persistência ====
const STORAGE_KEYS = {
  FVS: 'doge.viewer.fvs',
  NC:  'doge.viewer.nc',
};

function getQS(name){
  const u = new URL(location.href);
  return u.searchParams.get(name);
}
function setQS(updates){
  const u = new URL(location.href);
  for (const [k,v] of Object.entries(updates)){
    if (v == null || v === '' || v === false) u.searchParams.delete(k);
    else u.searchParams.set(k, String(v));
  }
  history.replaceState(null, '', u.toString());
}

function savePrefs(){
  try{
    if (CURRENT_FVS) localStorage.setItem(STORAGE_KEYS.FVS, CURRENT_FVS);
    localStorage.setItem(STORAGE_KEYS.NC, String(!!NC_MODE));
  }catch(_){}
}

function loadPrefs(){
  let fvs = null, nc = null;
  try{
    fvs = localStorage.getItem(STORAGE_KEYS.FVS);
    nc  = localStorage.getItem(STORAGE_KEYS.NC);
  }catch(_){}
  return {
    fvs: fvs || '',
    nc : (nc === 'true')
  };
}

// Compat: se estiver dentro de iframe (fase de transição), ainda enviaremos postMessage.
// O modal nativo abre SEMPRE, com ou sem iframe.
const LEGACY_IFRAME = false;

// Modal refs
const _modalBackdrop = document.getElementById('doge-modal-backdrop');
const _modal         = document.getElementById('doge-modal');
const _modalTitle    = document.getElementById('doge-modal-title');
const _modalPill     = document.getElementById('doge-modal-pill');
const _modalContent  = document.getElementById('doge-modal-content');
const _modalClose    = document.getElementById('doge-modal-close');
let _modalJustOpenedAt = 0;

// Estado inicial sempre fechado
if (_modalBackdrop) _modalBackdrop.style.display = 'none';
if (_modal)         _modal.style.display         = 'none';

function tintFromColor(hex){
  // retorna um background gradiente sutil usando a cor base como referência
  try{
    const c = new THREE.Color(hex || '#6e7681');
    const [r,g,b] = [c.r*255, c.g*255, c.b*255].map(v=>Math.round(v));
    return `linear-gradient(to bottom,
      rgba(${r},${g},${b},.12),
      rgba(0,0,0,.00) 40%)`;
  }catch(_){
    return `linear-gradient(to bottom, rgba(0,0,0,.12), rgba(0,0,0,0) 40%)`;
  }
}

function findAptRowByName(aptoName){
  if (!aptoName) return null;
  const key = normAptoKey(aptoName);
  // Usa META_MAP primeiro (já filtrado pela FVS atual)
  const meta = META_MAP.get(key);
  if (meta?.raw) return meta.raw;

  // Fallback: buscar direto em APT_DATA restringindo por FVS atual
  const rows = Array.isArray(APT_DATA)
    ? APT_DATA.filter(r => String(r?.fvs||'').trim() === String(CURRENT_FVS||'').trim())
    : [];
  return rows.find(r => normAptoKey(r?.apartamento) === key) || null;
}


function formatDateBR(dateStr){
  if(!dateStr) return "";
  const parts = String(dateStr).split('-');
  if(parts.length<3) return dateStr;
  const yyyy = parseInt(parts[0],10);
  const mm = parseInt(parts[1],10)-1;
  const dd = parseInt(parts[2].substring(0,2),10);
  const d = new Date(yyyy,mm,dd);
  if(isNaN(d)) return dateStr;
  return `${String(dd).padStart(2,'0')}/${String(mm+1).padStart(2,'0')}/${yyyy}`;
}
function getUltimaInspecaoInfo(reaberturas){
  if(!Array.isArray(reaberturas)||reaberturas.length===0){
    return { codigo_ultima_inspecao:null, qtd_pend_ultima_inspecao:0 };
  }
  let best=null;
  for(const r of reaberturas){
    const c = Number(r.codigo);
    if(!Number.isNaN(c)){
      if(!best || c>best.c) best = { c, q:Number(r.qtd_itens_pendentes)||0 };
    }
  }
  if(best) return { codigo_ultima_inspecao:String(best.c), qtd_pend_ultima_inspecao:best.q };
  const last = reaberturas[reaberturas.length-1];
  return { codigo_ultima_inspecao: last.codigo ?? null, qtd_pend_ultima_inspecao: Number(last.qtd_itens_pendentes) || 0 };
}
function linearProgress(pct, overrideColor){
  const p = Math.max(0, Math.min(100, Number(pct) || 0));
  const color = overrideColor || '#58a6ff';
  return `
    <span class="q-linear-progress q-linear-progress--sm" style="color:${color}">
      <span class="q-linear-progress__track">
        <span class="q-linear-progress__bar" data-w="${p}%"></span>
      </span>
      <span class="q-linear-progress__label">${p}%</span>
    </span>`;
}
function animateProgressBars(root=document){
  const bars = root.querySelectorAll('.q-linear-progress__bar[data-w]');
  requestAnimationFrame(()=> bars.forEach(b => { b.style.width = b.dataset.w; }));
}

// Mantém a função que colore o modal pela cor da FVS (você já tem setModalTint/hexToRgb)
function applyModalTint(fillHex){
  setModalTint(fillHex || '#58a6ff');
}

// ==== Busca a linha do apartamentos.json pela *chave de nome* + FVS atual ====
function findAptRowByName_strict(aptoName){
  if (!aptoName) return null;
  const key = normAptoKey(aptoName);
  // 1) usa META_MAP (já filtrado por FVS)
  const meta = META_MAP.get(key);
  if (meta?.raw) return meta.raw;
  // 2) fallback: filtra APT_DATA pela FVS e procura pelo nome
  const rows = Array.isArray(APT_DATA)
    ? APT_DATA.filter(r => String(r?.fvs||'').trim() === String(CURRENT_FVS||'').trim())
    : [];
  return rows.find(r => normAptoKey(r?.apartamento) === key) || null;
}

// ==== Substitua sua openAptModal por ESTA ====
// em escopo superior (uma vez)
// let _modalJustOpenedAt = 0;

function openAptModal({ id, floor }){
  const aptName = String(id||'').trim();
  const row = findAptRowByName_strict(aptName);

  // título + tint/gradiente iguais ao index
  const hex = pickFVSColor(aptName, floor ?? row?.pavimento_origem ?? null);
  _modalTitle.textContent = aptName || 'Apartamento';
  applyModalTint(hex);
  const headerEl = _modal.querySelector('header');
  if (headerEl) headerEl.style.background = tintFromColor(hex);

  // helpers
  const fmtInt  = (v)=> (v==null || v==='') ? '—' : String(v);
  const fmtBool = (b)=> b ? 'Sim' : 'Não';

  // conteúdo básico quando não há dados
  if (!row){
    _modalPill.textContent = '';
    _modalContent.innerHTML = `<p>Sem dados para o apartamento ${aptName}.</p>`;

    // abrir (com anti-ghost)
    _modalBackdrop.style.display = 'flex';
    _modal.style.display         = 'block';
    _modalBackdrop.style.pointerEvents = 'none';
    _modal.style.pointerEvents         = 'none';
    _modalJustOpenedAt = performance.now();
    requestAnimationFrame(()=>requestAnimationFrame(()=>{
      _modalBackdrop.style.pointerEvents = 'auto';
      _modal.style.pointerEvents         = 'auto';
    }));
    void _modal.offsetHeight;
    if (renderer?.domElement) renderer.domElement.style.pointerEvents = 'none';
    return;
  }

  // ===== Campos usados no index =====
  let codUlt  = row.codigo_ultima_inspecao;
  let pendUlt = row.qtd_pend_ultima_inspecao;
  if (codUlt == null){
    const aux = getUltimaInspecaoInfo(row.reaberturas);
    codUlt  = aux.codigo_ultima_inspecao;
    pendUlt = aux.qtd_pend_ultima_inspecao;
  }

  // NC da última inspeção
  let ncUlt = row.qtd_nao_conformidades_ultima_inspecao;
  if (ncUlt == null && Array.isArray(row.reaberturas) && row.reaberturas.length){
    const lastReab = row.reaberturas[row.reaberturas.length - 1];
    ncUlt = Number(lastReab.qtd_nao_conformidades);
  }

  const idLink = row.id_ultima_inspecao || row.id;
  const inmetaUrl = idLink
    ? `https://app.inmeta.com.br/app/360/servico/inspecoes/realizadas?inspecao=${encodeURIComponent(idLink)}`
    : null;

  // Pill no header (curto)
  _modalPill.textContent =
    (row.duracao_real != null)
      ? `Duração: ${row.duracao_real} dia${Number(row.duracao_real)===1?'':'s'}`
      : (row.percentual_ultima_inspecao != null ? `Progresso: ${row.percentual_ultima_inspecao}%` : '');

  // ===== HTML do conteúdo =====
  let html = '';
  html += `<p><strong>Apartamento:</strong> ${row.apartamento}</p>`;
  if (row.pavimento_origem){
    html += `<p><strong>Pavimento origem:</strong> ${row.pavimento_origem}</p>`;
  }
  html += `<p><strong>Início:</strong> ${formatDateBR(row.data_abertura)}</p>`;
  if (row.data_termino_inicial){
    html += `<p><strong>Término:</strong> ${formatDateBR(row.data_termino_inicial)}</p>`;
  }

  // Progress bar (mesma lógica de cor)
  let progressMarkup = '';
  const pct = Number(row.percentual_ultima_inspecao);
  if (!Number.isNaN(pct)){
    if (!row.data_termino_inicial){
      progressMarkup = linearProgress(pct, 'var(--blue)');
    } else if ((Number(row.qtd_pend_ultima_inspecao||0)>0) || (Number(ncUlt||0)>0) || pct<100){
      progressMarkup = linearProgress(pct, 'var(--yellow)');
    }
  }
  html += `<p class="line-progress"><span><strong>Duração inicial:</strong> ${row.duracao_inicial}</span>${progressMarkup}</p>`;

  if (ncUlt != null && !Number.isNaN(Number(ncUlt)) && Number(ncUlt) > 0){
    html += `<p><strong>Não conformidades:</strong> ${Number(ncUlt)}</p>`;
  }

  // Reinspeções (ordenadas)
  if (row.reaberturas?.length){
    const toTime = (d) => {
      const [yy, mm, dd] = (d || '').split('-').map(x => parseInt(x,10));
      const t = new Date(yy, (mm||1)-1, dd||1).getTime();
      return Number.isFinite(t) ? t : 0;
    };
    const reabs = [...row.reaberturas].sort((a, b) => {
      const ta = toTime(a.data_abertura), tb = toTime(b.data_abertura);
      if (ta !== tb) return ta - tb;
      const pa = Number(a.qtd_itens_pendentes) || 0;
      const pb = Number(b.qtd_itens_pendentes) || 0;
      if (pa !== pb) return pa - pb;
      const na = Number(a.qtd_nao_conformidades) || 0;
      const nb = Number(b.qtd_nao_conformidades) || 0;
      if (na !== nb) return na - nb;
      return String(a.codigo ?? '').localeCompare(String(b.codigo ?? ''), 'pt-BR', { numeric:true });
    });

    html += `<hr><table><tr><th>Código</th><th>Data Abertura</th><th>Pendências</th><th>Não conformidades</th></tr>`;
    reabs.forEach(r=>{
      html += `<tr>
        <td>${r.codigo ?? '-'}</td>
        <td>${formatDateBR(r.data_abertura)}</td>
        <td>${r.qtd_itens_pendentes}</td>
        <td>${r.qtd_nao_conformidades ?? '-'}</td>
      </tr>`;
    });
    html += `</table>`;
    html += `<p><strong>Duração reinspeções:</strong> ${row.duracao_reaberturas || 0}</p>`;
  }

  // Link da última inspeção
  if (inmetaUrl){
    html += `
      <p>
        <a class="link-row" href="${inmetaUrl}" target="_blank" rel="noopener noreferrer">
          <span><strong>Última inspeção:</strong> código ${codUlt ?? '-'} | pendências ${pendUlt ?? '-'}${(ncUlt!=null)?` | NC ${ncUlt}`:''}</span>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
               stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M15 3h6v6"/><path d="M10 14L21 3"/><path d="M18 13v6a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V8a2 2 0 0 1-2-2h6"/>
          </svg>
        </a>
      </p>`;
  } else {
    html += `<p><strong>Última inspeção:</strong> código ${codUlt ?? '-'} | pendências ${pendUlt ?? '-'}${(ncUlt!=null)?` | NC ${ncUlt}`:''}</p>`;
  }

  html += `<p><strong>Duração total:</strong> ${row.duracao_real}</p>`;
  if (row.termino_final){
    html += `<p><strong>Término final:</strong> ${formatDateBR(row.termino_final)}</p>`;
  }

  _modalContent.innerHTML = html;
  animateProgressBars(_modalContent);

  // abrir (com anti-ghost)
  _modalBackdrop.style.display = 'flex';
  _modal.style.display         = 'block';
  _modalBackdrop.style.pointerEvents = 'none';
  _modal.style.pointerEvents         = 'none';
  _modalJustOpenedAt = performance.now();
  requestAnimationFrame(()=>requestAnimationFrame(()=>{
    _modalBackdrop.style.pointerEvents = 'auto';
    _modal.style.pointerEvents         = 'auto';
  }));
  void _modal.offsetHeight;

  if (renderer?.domElement) renderer.domElement.style.pointerEvents = 'none';
}


function hexToRgb(hex){
  const m = String(hex||'').replace('#','').match(/^([0-9a-f]{6})$/i);
  if (!m) return {r:88,g:166,b:255}; // fallback azul do index
  const n = parseInt(m[1],16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function setModalTint(hex){
  const el = document.getElementById('doge-modal');
  if (!el) return;
  const {r,g,b} = hexToRgb(hex || '#58a6ff');
  el.style.setProperty('--modal-tint-strong', `rgba(${r},${g},${b},0.20)`);
  el.style.setProperty('--modal-tint-soft',   `rgba(${r},${g},${b},0.10)`);
  el.style.setProperty('--modal-border',      `rgba(${r},${g},${b},0.28)`); // << igual ao index
}



function focusModalInitial(){
  const preferred = _modal.querySelector('#doge-modal-close') || _modal.querySelector('button, [href], [tabindex]');
  if (preferred) preferred.focus({ preventScroll: true });
}

let _lastFocusEl = null;

function trapFocus(e){
  if (!_modal || _modal.style.display !== 'block') return;
  const focusables = _modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  const list = Array.from(focusables).filter(el => !el.hasAttribute('disabled'));
  if (list.length === 0) return;
  const first = list[0], last = list[list.length - 1];

  if (e.key === 'Tab'){
    if (e.shiftKey && document.activeElement === first) {
      last.focus(); e.preventDefault();
    } else if (!e.shiftKey && document.activeElement === last) {
      first.focus(); e.preventDefault();
    }
  }
}
function closeAptModal(){
  _modalBackdrop.style.display = 'none';
  _modal.style.display         = 'none';
  if (renderer?.domElement) renderer.domElement.style.pointerEvents = 'auto';
  if (_lastFocusEl && typeof _lastFocusEl.focus === 'function') {
    try { _lastFocusEl.focus({ preventScroll: true }); } catch(_){}
  }
  _lastFocusEl = null;
}

_modalBackdrop.addEventListener('click', (e)=>{
  if (e.target === _modalBackdrop) closeAptModal();
});
_modalClose.addEventListener('click', closeAptModal);
addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeAptModal(); });
function suppressGhostClick(e){
  if (_modal.style.display !== 'block') return;
  const dt = performance.now() - _modalJustOpenedAt;
  if (dt < 400) {  // ~0.4s é um bom colchão em iOS/Android
    e.stopPropagation();
    e.preventDefault();
  }
}
// Captura no backdrop e no conteúdo do modal
_modalBackdrop.addEventListener('click', suppressGhostClick, true);
_modal.addEventListener('click', suppressGhostClick, true);




// === Paleta padrão (ajuste livre, se quiser ficar idêntico ao index)
const PALETTE = {
  default: '#6e7681',   // cinza
  done:    '#238636',   // verde
  working: '#58a6ff',   // azul
  pending: '#d29922',   // amarelo
  failed:  '#ff3b30'    // vermelho (NCs)
};

// === Função de decisão de cor por linha de apartamentos.json
// === MODO NORMAL: "pendências" (amarelo) tem prioridade sobre "em andamento/percentual"
// === MODO NORMAL: mesma regra do main.js (2D)
function colorFromRowNormal(row){
  const nc   = Number(row?.qtd_nao_conformidades_ultima_inspecao ?? 0);
  const pend = Number(row?.qtd_pend_ultima_inspecao ?? 0);
  const pct  = Number(row?.percentual_ultima_inspecao);
  const terminouInicial = !!row?.data_termino_inicial;

  // Sem término inicial -> azul (em andamento)
  if (!terminouInicial) return PALETTE.working;

  // Com término inicial:
  const ultimaOK = (pct === 100 && pend === 0 && nc === 0);
  return ultimaOK ? PALETTE.done : PALETTE.pending; // verde ou amarelo
}


// === MODO NC: só destaca NC>0 em vermelho; o resto cinza
function colorFromRowNC(row){
  const ncs = Number(row?.qtd_nao_conformidades_ultima_inspecao ?? 0);
  return (ncs > 0) ? PALETTE.failed : PALETTE.default;
}

let FVS_LIST = [];
let APT_DATA = [];      // conteúdo bruto de apartamentos.json
let CURRENT_FVS = '';   // FVS selecionada
let NC_MODE = false;    // estado do botão NC


    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // Carrega FVS e Apartamentos
[FVS_LIST, APT_DATA] = await Promise.all([
  fetch(FVS_LIST_URL, { cache: 'no-store' }).then(r=>r.json()).catch(()=>[]),
  fetch(APTS_URL,     { cache: 'no-store' }).then(r=>r.json()).catch(()=>[])
]);



const loadingEl = document.getElementById('doge-loading');
if (loadingEl) loadingEl.style.display = 'none';

// Estado inicial: query string tem prioridade; fallback no storage
const prefs = loadPrefs();
let QS_FVS = getQS('fvs');
let QS_NC  = getQS('nc');
let QS_APT = getQS('apt');  // se presente, abriremos modal após montar tudo

if (QS_FVS == null || QS_FVS === '') QS_FVS = prefs.fvs || '';
if (QS_NC == null) QS_NC = (prefs.nc ? '1' : '0');

NC_MODE = (QS_NC === '1' || QS_NC === 'true');


// Popular dropdown
const fvsSelect = document.getElementById('fvsSelect');
if (Array.isArray(FVS_LIST) && fvsSelect) {
  fvsSelect.innerHTML = '';
  for (const f of FVS_LIST) {
    const val = (typeof f === 'string') ? f : (f?.nome || f?.id || '');
    if (!val) continue;
    const opt = document.createElement('option');
    opt.value = String(val);
    opt.textContent = String(val);
    fvsSelect.appendChild(opt);
  }
  if (QS_FVS && [...fvsSelect.options].some(o => o.value === QS_FVS)) {
    fvsSelect.value = QS_FVS;
  } else if (fvsSelect.options.length) {
    fvsSelect.selectedIndex = 0;
  }
  CURRENT_FVS = fvsSelect.value || '';
}

function computeFvsNcCounts(){
  // Retorna { 'FVS A': 3, 'FVS B': 0, ... }
  const counts = {};
  if (!Array.isArray(APT_DATA)) return counts;
  for (const r of APT_DATA){
    const fvs = String(r?.fvs||'').trim(); if (!fvs) continue;
    const ncs = Number(r?.qtd_nao_conformidades_ultima_inspecao ?? 0);
    counts[fvs] = (counts[fvs] || 0) + (ncs > 0 ? 1 : 0);
  }
  return counts;
}

function rebuildFvsDropdown(){
  const fvsSelect = document.getElementById('fvsSelect'); if (!fvsSelect) return;
  const counts = computeFvsNcCounts();

  // Monta lista base
  const all = Array.isArray(FVS_LIST)
    ? FVS_LIST.map(f => (typeof f === 'string') ? f.trim() : String(f?.nome ?? f?.id ?? '').trim())
    : [];

  // Se NC ativo: filtra só FVS com NC>0 e mostra contagem. Senão: mostra todas, sem contagem.
  const values = NC_MODE
    ? all.filter(name => (counts[name]||0) > 0)
    : all;

  const previous = fvsSelect.value;
  fvsSelect.innerHTML = '';
  for (const name of values){
    if (!name) continue;
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = NC_MODE
      ? `${name} (${counts[name]||0})`
      : name;
    fvsSelect.appendChild(opt);
  }

  // Seleção inteligente: mantém a atual se existir; senão, pega a primeira
  if (values.includes(previous)){
    fvsSelect.value = previous;
  } else if (fvsSelect.options.length){
    fvsSelect.selectedIndex = 0;
  } else {
    fvsSelect.value = '';
  }
  CURRENT_FVS = fvsSelect.value || '';
}
rebuildFvsDropdown();
// Sincroniza UI do NC com o estado inicial
const btnNC = document.getElementById('btnNC');
if (btnNC) btnNC.classList.toggle('active', NC_MODE);

function normAptoKey(s){
  if (s == null) return '';
  let t = String(s).trim().toUpperCase();
  t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
  t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
  t = t.replace(/[\s\-\._\/]/g, '');
  return t;
}

// Constrói o COLOR_MAP a partir da FVS selecionada.
// Observação: aqui fazemos um mapeamento neutro (cinza) para garantir funcionamento.
// Na próxima etapa, você pode plugar exatamente a regra de cores que já usava no index.
// buildColorMapForFVS (NORMAL)
function buildColorMapForFVS(fvsName){
  const map = { default: PALETTE.default, colors: {}, byFloor: {} };
  if (!fvsName || !Array.isArray(APT_DATA)) return map;

  const rows = APT_DATA.filter(r => String(r?.fvs||'').trim() === String(fvsName).trim());

  for (const r of rows){
    const aptName = r?.apartamento; if (!aptName) continue;
    map.colors[normAptoKey(aptName)] = colorFromRowNormal(r);
  }

  // agregação por pavimento: working > pending > done > default
  const agg = new Map(), bump=(o,k)=>o[k]=(o[k]||0)+1;
  for (const r of rows){
    const pav = (r?.pavimento_origem != null) ? String(r.pavimento_origem) : null;
    if (!pav) continue;
    const col = colorFromRowNormal(r);
    const stat = (col===PALETTE.working)?'working':(col===PALETTE.pending)?'pending':(col===PALETTE.done)?'done':'default';
    const o = agg.get(pav)||{}; bump(o,stat); agg.set(pav,o);
  }
  for (const [pav,o] of agg){
    let chosen = PALETTE.default;
    if (o.working) chosen = PALETTE.working;
    else if (o.pending) chosen = PALETTE.pending;
    else if (o.done)    chosen = PALETTE.done;
    map.byFloor[pav] = chosen;
  }
  return map;
}

// buildColorMapForFVS_NC (NC)
function buildColorMapForFVS_NC(fvsName){
  const map = { default: PALETTE.default, colors: {}, byFloor: {} };
  if (!fvsName || !Array.isArray(APT_DATA)) return map;

  const rows = APT_DATA.filter(r => String(r?.fvs||'').trim() === String(fvsName).trim());
  for (const r of rows){
    const aptName = r?.apartamento; if (!aptName) continue;
    map.colors[normAptoKey(aptName)] = colorFromRowNC(r);
  }
  const floors = new Map();
  for (const r of rows){
    const pav = (r?.pavimento_origem != null) ? String(r.pavimento_origem) : null;
    if (!pav) continue;
    const hasNC = Number(r?.qtd_nao_conformidades_ultima_inspecao ?? 0) > 0;
    const e = floors.get(pav) || { hasNC:false }; if (hasNC) e.hasNC = true; floors.set(pav,e);
  }
  for (const [pav,e] of floors) map.byFloor[pav] = e.hasNC ? PALETTE.failed : PALETTE.default;
  return map;
}
// Constrói metadados (duração etc.) por apartamento para os cards e modal
function buildMetaMapForFVS(fvsName){
  const meta = new Map();
  if (!fvsName || !Array.isArray(APT_DATA)) return meta;

  const rows = APT_DATA.filter(r => String(r?.fvs||'').trim() === String(fvsName).trim());
  for (const r of rows){
    const aptName = r?.apartamento;
    if (!aptName) continue;
    const key = normAptoKey(aptName);

    meta.set(key, {
      apto: String(aptName),
      duracao: (r?.duracao_real ?? r?.duracao_inicial ?? null),
      percentual: r?.percentual_ultima_inspecao ?? null,
      pendencias: r?.qtd_pend_ultima_inspecao ?? null,
      pavimento: r?.pavimento_origem ?? null,
      raw: r
    });
  }
  return meta;
}

function applyFVSAndRefresh(){
  let cm;
  if (NC_MODE) {
    cm = buildColorMapForFVS_NC(CURRENT_FVS);   // só NCs em vermelho
  } else {
    cm = buildColorMapForFVS(CURRENT_FVS);      // normal, IGNORA NCs
  }
  setFVSColorMap(cm);
  META_MAP = buildMetaMapForFVS(CURRENT_FVS);
  refreshCardsWithMeta();
}// Dropdown FVS
if (fvsSelect){
  fvsSelect.addEventListener('change', ()=>{
    CURRENT_FVS = String(fvsSelect.value || '');
    setQS({ fvs: CURRENT_FVS || null });  // atualiza URL
    savePrefs();
    applyFVSAndRefresh();
  });
}

// Botão NC
if (btnNC){
btnNC.addEventListener('click', ()=>{
  NC_MODE = !NC_MODE;
  btnNC.classList.toggle('active', NC_MODE);
  rebuildFvsDropdown();          // << atualiza o dropdown conforme regra NC
  setQS({ nc: NC_MODE ? '1' : null, fvs: CURRENT_FVS || null });
  savePrefs();
  applyFVSAndRefresh();
});
}


    // ====== Setup ======
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== Órbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();

    // ===== Gestos (pointer + tap detector) =====
    let activePointers = new Map();
    let dragging = false;
    let dragMode = 'orbit';
    let lastX = 0, lastY = 0;

    // Tap detector
    let tapState = { isDown:false, startX:0, startY:0, moved:false, multi:false, downAt:0 };
    const TAP_MOVE_THRESH = 6;   // px
    const TAP_TIME_MAX   = 600;  // ms

    const ptsArr   = () => Array.from(activePointers.values());
    const centroid = (pts)=>({ x: pts.reduce((a,p)=>a+p.x,0)/pts.length,
                               y: pts.reduce((a,p)=>a+p.y,0)/pts.length });
    const dist     = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);

    let gesture = null; // { startDist, startRadius, lastCentroid }

    function pointerDown3D(e){
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      renderer.domElement.setPointerCapture(e.pointerId);

      const pts = ptsArr();
      if (pts.length === 1){
        dragMode = (e.button === 2) ? 'pan' : 'orbit';
        dragging = true;
        lastX = e.clientX; lastY = e.clientY;
      } else if (pts.length === 2){
        dragging = false;
        const [p1,p2] = pts;
        gesture = {
          startDist:   dist(p1,p2),
          startRadius: radius,
          lastCentroid: centroid(pts)
        };
      }
      e.preventDefault();

      // tap tracking
      tapState.isDown = true;
      tapState.startX = e.clientX;
      tapState.startY = e.clientY;
      tapState.moved  = false;
      tapState.multi  = (pts.length >= 2);
      tapState.downAt = performance.now();
    }
    renderer.domElement.style.touchAction = 'none';

    function pointerMove3D(e){
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

      // tap tracking
      if (tapState.isDown) {
        const dx = e.clientX - tapState.startX;
        const dy = e.clientY - tapState.startY;
        if (Math.hypot(dx, dy) > TAP_MOVE_THRESH) tapState.moved = true;
      }

      const pts = ptsArr();

      // 1 apontador
      if (pts.length === 1 && dragging){
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        if (dragMode === 'orbit'){
          pivot.rotation.y += dx * 0.005;
          theta = pivot.rotation.y;
          phi   = clamp(phi - dy * 0.005, minPhi, maxPhi);
          updateCamera();
        } else {
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
          updateCamera();
        }
        e.preventDefault();
        return;
      }

      // 2 apontadores (pinça + pan do centroide)
      if (pts.length === 2 && gesture){
        const c  = centroid(pts);
        const d  = dist(pts[0], pts[1]);

        if (gesture.startDist > 0){
          const scale = d / gesture.startDist;
          const newR  = gesture.startRadius / Math.max(0.2, Math.min(5, scale));
          radius = clamp(newR, minRadius, maxRadius);
        }

        const dx = c.x - gesture.lastCentroid.x;
        const dy = c.y - gesture.lastCentroid.y;
        if (dx || dy){
          const panScale = radius * 0.0025;
          const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
          const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
          const upv     = new THREE.Vector3().copy(camera.up).normalize();
          orbitTarget.addScaledVector(right, -dx * panScale);
          orbitTarget.addScaledVector(upv,     dy * panScale);
        }

        gesture.lastCentroid = c;
        updateCamera();
        e.preventDefault();
        return;
      }
    }

    function pointerUp3D(e){
      if (activePointers.has(e.pointerId)){
        try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
        activePointers.delete(e.pointerId);
      }
      const pts = ptsArr();
      if (pts.length === 0){ dragging = false; gesture = null; }
      if (pts.length < 2){ gesture = null; }
      e.preventDefault();
    }

    renderer.domElement.addEventListener('pointerdown',   pointerDown3D,   {passive:false});
    renderer.domElement.addEventListener('pointermove',   pointerMove3D,   {passive:false});
    renderer.domElement.addEventListener('pointerup',     pointerUp3D,     {passive:false});
    renderer.domElement.addEventListener('pointercancel', pointerUp3D,     {passive:false});

    // bloqueia menu do botão direito (para pan no desktop)
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Scroll do mouse (zoom)
    renderer.domElement.addEventListener('wheel', e=>{
      e.preventDefault();
      const f = 1 + (e.deltaY>0 ? 0.1 : -0.1);
      radius = clamp(radius*f, minRadius, maxRadius);
      updateCamera();
    }, {passive:false});
    // ====== Materiais ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX = 0x6e7681;
    const MAT = {
      face: ()=> new THREE.MeshStandardMaterial({
        color: NEUTRAL_HEX,
        metalness: 0.05,
        roughness: 0.9,
        transparent: true,
        opacity: faceOpacity,
        depthWrite: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      }),
      line: new THREE.LineBasicMaterial({
        color: 0xcad7ff,
        linewidth: 1,
        depthTest: true,
        depthWrite: false,
        transparent: true,
        opacity: 0.95
      }),
      selLine: new THREE.LineBasicMaterial({
        color: 0xffc107,
        linewidth: 2
      })
    };

    function setFacesVisible(visible){
      for (const g of torre.children) g.userData.mesh.visible = visible;
    }

    // ===== Helpers de Opacidade (NOVOS) =====
    const MIN_OPACITY_2D = 0.03;

    function computeEffectiveOpacity(baseOpacity, t2d){
      return THREE.MathUtils.lerp(baseOpacity, MIN_OPACITY_2D, t2d || 0);
    }

    function applyOpacityToAllMeshes(effective){
      if (!torre) return;
      const isOpaque = effective >= 0.999;

      torre.traverse(n=>{
        if (!n.material || !n.isMesh) return;
        n.material.opacity = effective;
        if (isOpaque){
          n.material.transparent = false;
          n.material.depthWrite  = true;
        } else {
          n.material.transparent = true;
          n.material.depthWrite  = false;
        }
        n.material.needsUpdate = true;
      });
    }

    function applyEdgesFade(t2d){
      const lineEff = THREE.MathUtils.lerp(0.95, 0.08, t2d || 0);
      if (!torre) return;
      torre.traverse(n=>{
        if (!(n.isLine || n.isLineSegments) || !n.material) return;
        n.material.opacity     = lineEff;
        n.material.transparent = lineEff < 1;
        n.material.depthWrite  = !n.material.transparent;
        n.material.needsUpdate = true;
      });
    }

    // ===== Dimensão básica em "mundo" =====
    const cellW = (layout.meta?.cellW ?? 1.2);
    const cellD = (layout.meta?.cellD ?? 1.2);
    const gap   = (layout.meta?.gap   ?? 0.15);

    const aptoHeight = 0.5;
    const stepX = cellW + gap;
    const stepZ = cellD + gap;
    const stepY = aptoHeight + gap;

    function rectCenterX(x, w){ return x*stepX + (w*cellW + (w-1)*gap)/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*cellD + (d-1)*gap)/2; }

    // ===== Explode =====
    let explodeXY = 0.0;
    let explodeY  = 0.0;

    function applyExplode(){
      if (!torre || torre.children.length === 0) return;

      if ((explodeXY === 0 || !Number.isFinite(explodeXY)) &&
          (explodeY  === 0 || !Number.isFinite(explodeY))) {
        for (const g of torre.children) g.position.copy(g.userData.basePos);
        return;
      }

      // Centroide dos anchors
      let sumX = 0, sumZ = 0, n = 0;
      for (const g of torre.children){
        const a = g.userData.anchor || g.userData.basePos;
        sumX += a.x; sumZ += a.z; n++;
      }
      const cx = n ? (sumX/n) : 0;
      const cz = n ? (sumZ/n) : 0;

      const step = Math.max(stepX, stepZ) || 1;

      for (const g of torre.children){
        const base = g.userData.basePos;
        const pos  = base.clone();

        if (explodeXY > 0){
          const a = g.userData.anchor || base;
          const dir = new THREE.Vector3(a.x - cx, 0, a.z - cz);
          const len = dir.length();
          if (len > 1e-6){
            dir.multiplyScalar(1/len);
            pos.addScaledVector(dir, explodeXY * step);
          }
        }

        if (explodeY !== 0){
          pos.y += (g.userData.levelIndex || 0) * explodeY;
        }

        g.position.copy(pos);
      }
    }

    // ===== Voxelização por NOME =====
    function voxelizeByNome(l){
      const byNome = new Map();
      for (const p of (l.placements || [])){
        const nome = String(p.nome);
        if (!byNome.has(nome)) byNome.set(nome, new Set());
        const set = byNome.get(nome);
        const baseY = (typeof p.andar === 'number') ? p.andar : 0;
        for (let gx = p.x; gx < p.x + p.w; gx++){
          for (let gz = p.z; gz < p.z + p.d; gz++){
            for (let gy = baseY; gy < baseY + p.h; gy++){
              set.add(`${gx},${gy},${gz}`);
            }
          }
        }
      }
      return byNome;
    }

    // ===== Meshing de fronteira =====
    function buildSurfaceGeometryFromOcc(occSet){
      if (!occSet || occSet.size===0) return null;
      const has = (x,y,z)=> occSet.has(`${x},${y},${z}`);

      const pos = [];
      const idx = [];
      let vbase = 0;

      const pushQuad = (a,b,c,d)=>{
        pos.push( ...a, ...b, ...c, ...d );
        idx.push(vbase, vbase+1, vbase+2,  vbase, vbase+2, vbase+3);
        vbase += 4;
      };

      function voxelBounds(gx,gy,gz){
        const x0 = gx * stepX, x1 = x0 + cellW;
        const z0 = gz * stepZ, z1 = z0 + cellD;
        const y0 = gy * stepY, y1 = y0 + aptoHeight;
        return {x0,x1,y0,y1,z0,z1};
      }

      for (const key of occSet){
        const [gx,gy,gz] = key.split(',').map(Number);
        const {x0,x1,y0,y1,z0,z1} = voxelBounds(gx,gy,gz);

        if (!has(gx-1,gy,gz)) pushQuad([x0,y0,z1],[x0,y0,z0],[x0,y1,z0],[x0,y1,z1]); // -X
        if (!has(gx+1,gy,gz)) pushQuad([x1,y0,z0],[x1,y0,z1],[x1,y1,z1],[x1,y1,z0]); // +X
        if (!has(gx,gy,gz-1)) pushQuad([x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]); // -Z
        if (!has(gx,gy,gz+1)) pushQuad([x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]); // +Z
        if (!has(gx,gy-1,gz)) pushQuad([x0,y0,z0],[x1,y0,z0],[x1,y0,z1],[x0,y0,z1]); // -Y
        if (!has(gx,gy+1,gz)) pushQuad([x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]); // +Y
      }

      if (pos.length===0) return null;

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
      geom.setIndex(new THREE.Uint32BufferAttribute(new Uint32Array(idx), 1));
      geom.computeVertexNormals();
      geom.computeBoundingBox(); geom.computeBoundingSphere();
      return geom;
    }

    // ===== Inflar para desenhar edges limpas =====
    function inflateGeometry(geom, offset=0.04){
      const g = geom.clone();
      g.computeVertexNormals();
      const pos = g.getAttribute('position');
      const nor = g.getAttribute('normal');
      for (let i=0;i<pos.count;i++){
        pos.setX(i, pos.getX(i) + nor.getX(i)*offset);
        pos.setY(i, pos.getY(i) + nor.getY(i)*offset);
        pos.setZ(i, pos.getZ(i) + nor.getZ(i)*offset);
      }
      pos.needsUpdate = true;
      return g;
    }

    // ====== Construção ======
    function buildFromLayout(l){
      // 1) Metadados por NOME
      const aptMeta = new Map();
      if (l && Array.isArray(l.placements)){
        for (const p of l.placements){
          const id = String(p.nome);
          const m  = aptMeta.get(id) || {};
          m.name       = String(p.nome);
          if (p.ordemcol != null) m.ordemcol = Number(p.ordemcol);
          if (p.zindex  != null)  m.zIndex   = Number(p.zindex);
          if (p.floor   != null)  m.floor    = Number(p.floor);
          aptMeta.set(id, m);
        }
      }

      // limpa torre
      while (torre.children.length) torre.remove(torre.children[0]);

      // voxeliza por nome
      const occByNome = voxelizeByNome(l);
      for (const [nome, occ] of occByNome.entries()){
        const surface = buildSurfaceGeometryFromOcc(occ);
        if (!surface) continue;

        const faceMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x6e7681),
          metalness: 0.05,
          roughness: 0.9,
          transparent: faceOpacity < 0.999,
          opacity: Math.min(1, faceOpacity),
          depthWrite: faceOpacity >= 0.999,
          side: THREE.DoubleSide,
          polygonOffset: true,
          polygonOffsetFactor: 1,
          polygonOffsetUnits: 1
        });

        const mesh = new THREE.Mesh(surface, faceMat);
        mesh.renderOrder = 1;

        const inflated = inflateGeometry(surface, 0.04);
        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(inflated, 1), MAT.line);
        edges.renderOrder = 2;

        // pavimento mínimo
        let minLevel = Infinity;
        for (const key of occ){
          const gy = parseInt(key.split(',')[1],10);
          if (gy < minLevel) minLevel = gy;
        }
        if (!Number.isFinite(minLevel)) minLevel = 0;

        const group = new THREE.Group();
        group.add(mesh); group.add(edges);

        const metaFromJson = aptMeta.get(String(nome)) || {};
        const idStr   = String(nome);
        const nameStr = metaFromJson.name || idStr;

        group.userData = {
          nome: idStr,
          mesh, edges,
          levelIndex: minLevel,
          basePos: new THREE.Vector3(0,0,0),
          anchor:  new THREE.Vector3(0,0,0),
          meta: {
            id: idStr,
            name: nameStr,
            ordemcol: (typeof metaFromJson.ordemcol === 'number') ? metaFromJson.ordemcol : undefined,
            zIndex:   (typeof metaFromJson.zIndex   === 'number') ? metaFromJson.zIndex   : undefined
          }
        };

        // centro local → anchor
        surface.computeBoundingBox();
        const bb = surface.boundingBox;
        const localCenter = new THREE.Vector3();
        bb.getCenter(localCenter);
        group.__localCenter = localCenter;

        torre.add(group);
      }

      // Centraliza torre
      const bbox = new THREE.Box3().setFromObject(torre);
      const center = new THREE.Vector3(); bbox.getCenter(center);
      const size   = new THREE.Vector3(); bbox.getSize(size);

      for (const g of torre.children){
        g.position.sub(center);
        g.userData.basePos.copy(g.position);

        const lc = g.__localCenter || new THREE.Vector3();
        g.userData.anchor.set(
          g.position.x + lc.x,
          g.position.y + lc.y,
          g.position.z + lc.z
        );
        delete g.__localCenter;
      }

      // Câmera inicial
      const diag = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
      const idealRadius = Math.max(8, diag * 0.75);
      radius = clamp(idealRadius, minRadius, maxRadius);
      orbitTarget.set(0, 0, 0);
      updateCamera();

      applyExplode();
    }

    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }

    // metaByNome (se precisar no futuro)
    const metaByNome = new Map();
    for (const p of (layout.placements||[])){
      const key = String(p.nome);
      if (!metaByNome.has(key)){
        metaByNome.set(key, { ordemcol: (p.ordemcol|0) });
      }
    }

    buildFromLayout(layout);

    // ===== Seleção com mira (tap real) =====
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

function pickAtClientXY(clientX, clientY){
  // Converter coordenadas do clique para NDC
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

  // Raycast nas faces
  const faceObjects = torre.children.map(g => g.userData.mesh);
  raycaster.setFromCamera(mouse, camera);
  let inter = raycaster.intersectObjects(faceObjects, false);

  // Fallback: tentar nas arestas (aumenta um pouco o threshold)
  if (!inter.length) {
    const edgeObjects = torre.children.map(g => g.userData.edges);
    raycaster.params.Line = raycaster.params.Line || {};
    raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06;
    inter = raycaster.intersectObjects(edgeObjects, false);
  }

  // Hover 3D (sem selecionar)
let lastHoverGroup = null;
const HOVER_THROTTLE_MS = 40;
let lastHoverTS = 0;

function hoverAtClientXY(clientX, clientY){
  const now = performance.now();
  if (now - lastHoverTS < HOVER_THROTTLE_MS) return; // throttle
  lastHoverTS = now;

  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

  const faceObjects = torre.children.map(g => g.userData.mesh);
  raycaster.setFromCamera(mouse, camera);
  let inter = raycaster.intersectObjects(faceObjects, false);

  if (!inter.length){
    const edgeObjects = torre.children.map(g => g.userData.edges);
    raycaster.params.Line = raycaster.params.Line || {};
    raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06;
    inter = raycaster.intersectObjects(edgeObjects, false);
  }

  if (!inter.length){
    lastHoverGroup = null;
    hideTip(50);
    return;
  }

  const g = inter[0].object.parent;
  if (!g || !g.userData) { hideTip(50); return; }

  lastHoverGroup = g;
  const nomeId = String(g.userData.nome || g.userData?.meta?.id || '').trim();
  // Mostra tooltip perto do cursor
  showTip(clientX, clientY, nomeId || 'apt');
}

// liga o hover no canvas (só quando não estiver em 2D "cheio")
renderer.domElement.addEventListener('pointermove', (e)=>{
  if (flatten2D >= 0.95) { hideTip(0); return; }
  // se estiver arrastando para orbitar/panar, não mostrar tooltip
  if (dragging) { hideTip(0); return; }
  hoverAtClientXY(e.clientX, e.clientY);
}, { passive: true });

renderer.domElement.addEventListener('pointerleave', ()=> hideTip(0), { passive: true });

  // Limpa seleção anterior
  if (window.__SEL_GROUP__) {
    const gPrev = window.__SEL_GROUP__;
    if (gPrev.__lineBackup) gPrev.userData.edges.material = gPrev.__lineBackup;
    if (gPrev.__faceBackup) gPrev.userData.mesh.material  = gPrev.__faceBackup;
    delete gPrev.__lineBackup;
    delete gPrev.__faceBackup;
    window.__SEL_GROUP__ = null;
  }

  // Nada atingido
  if (!inter.length) return;

  // Grupo selecionado
  const hitObj   = inter[0].object;
  const selGroup = hitObj.parent;
  if (!selGroup || !selGroup.userData) return;

  // Destaque visual (salva materiais e aplica highlight)
  selGroup.__lineBackup = selGroup.userData.edges.material;
  selGroup.__faceBackup = selGroup.userData.mesh.material.clone();
  selGroup.userData.edges.material = MAT.selLine;
  const faceClone = selGroup.userData.mesh.material.clone();
  faceClone.opacity = Math.min(1, (typeof faceOpacity === 'number' ? faceOpacity : 0.3) + 0.2);
  selGroup.userData.mesh.material = faceClone;
  window.__SEL_GROUP__ = selGroup;

  // Identificação e cor atual
  const nomeId = String(selGroup.userData.nome || selGroup.userData?.meta?.id || '').trim();
  let hex = null;
  try { const c = selGroup.userData.mesh.material.color; if (c) hex = '#' + c.getHexString(); } catch(_){}

  // Compat: se estiver dentro de um iframe, ainda notifica o parent
  if (typeof LEGACY_IFRAME !== 'undefined' && LEGACY_IFRAME){
    try { parent.postMessage({ type: 'viewer:open-apt', apt: nomeId, color: hex }, '*'); } catch(_){}
  }

  // Modal nativo SEMPRE
  openAptModal({ id: nomeId, floor: selGroup.userData.levelIndex ?? null });

  // Log útil para debug
  console.log('[viewer] tap nome:', nomeId);
}

    // Tap “real” (bloqueia click fantasma)
    renderer.domElement.addEventListener('pointerup', (e) => {
      if (e.pointerType === 'mouse' && e.button === 2) return;

      const dt = performance.now() - tapState.downAt;
      const dx = e.clientX - tapState.startX;
      const dy = e.clientY - tapState.startY;
      const moved = Math.hypot(dx, dy) > TAP_MOVE_THRESH;

      const isTap = !tapState.multi && !moved && dt <= TAP_TIME_MAX;

      tapState.isDown = false;
      tapState.multi  = false;

      if (!isTap) return;
      pickAtClientXY(e.clientX, e.clientY);
    }, { passive:false });
    // ===== HUD / UI =====
    const hud  = document.getElementById('hud');
    const hudToggle = document.getElementById('hudToggle');
    const hudHandle = document.getElementById('hudHandle');

    hudToggle.addEventListener('click', () => {
      const collapsed = hud.classList.toggle('collapsed');
      hudToggle.textContent = collapsed ? '▴' : '▾';
      hudToggle.setAttribute('aria-expanded', String(!collapsed));
    });

    // Gesto vertical simples: arrastar a alça para recolher/expandir
    let hudDragId = null, hudStartY = 0, hudDy = 0;
    function hudPointerDown(e){
      hudDragId = e.pointerId;
      hudStartY = e.clientY; hudDy = 0;
      hudHandle.setPointerCapture(hudDragId);
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerMove(e){
      if (e.pointerId !== hudDragId) return;
      hudDy = e.clientY - hudStartY;
      e.preventDefault(); e.stopPropagation();
    }
    function hudPointerUp(e){
      if (e.pointerId !== hudDragId) return;
      if (hudDy > 30) {
        hud.classList.add('collapsed');
        hudToggle.textContent = '▴';
        hudToggle.setAttribute('aria-expanded', 'false');
      } else if (hudDy < -30) {
        hud.classList.remove('collapsed');
        hudToggle.textContent = '▾';
        hudToggle.setAttribute('aria-expanded', 'true');
      }
      try { hudHandle.releasePointerCapture(hudDragId); } catch(_){}
      hudDragId = null; hudDy = 0;
      e.preventDefault(); e.stopPropagation();
    }
    hudHandle.addEventListener('pointerdown', hudPointerDown, {passive:false});
    hudHandle.addEventListener('pointermove', hudPointerMove, {passive:false});
    hudHandle.addEventListener('pointerup',   hudPointerUp,   {passive:false});
    hudHandle.addEventListener('pointercancel', hudPointerUp, {passive:false});

    hudHandle.addEventListener('click', (e) => {
      if (e.target === hudToggle) return;
      hudToggle.click();
    });



    // Opacidade (slider)
    const opacity = document.getElementById('opacity');
    opacity.addEventListener('input', () => {
      const v = Number(opacity.value) / 100;
      setFaceOpacity(v);
    });

    // Explodir XY
    const explodeXYRange = document.getElementById('explodeXY');
    explodeXYRange.addEventListener('input', () => {
      explodeXY = Number(explodeXYRange.value) || 0;
      applyExplode();
    });

    // Explodir Y (piso)
    const explodeYRange = document.getElementById('explodeY');
    explodeYRange.addEventListener('input', () => {
      explodeY = Number(explodeYRange.value) || 0;
      applyExplode();
    });

    // Reset explode (e 2D)
    document.getElementById('resetExplode').addEventListener('click', () => {
      explodeXY = 0; explodeY = 0;
      explodeXYRange.value = '0';
      explodeYRange.value  = '0';
      applyExplode();
    });

    // Reset rotação
    document.getElementById('resetRot').addEventListener('click', () => {
      pivot.rotation.set(0,0,0);
      theta = 0;
      updateCamera();
    });

    // Recentrar
    document.getElementById('recenter').addEventListener('click', () => {
      recenterOrbitTarget();
      radius = INITIAL_RADIUS;
      phi = INITIAL_PHI;
      updateCamera();
    });

    // ===== Correção de Opacidade — funções NOVAS/ALTERADAS =====
    function setFaceOpacity(op){
      faceOpacity = Math.max(0, Math.min(1, op));
      const eff = computeEffectiveOpacity(faceOpacity, flatten2D || 0);
      applyOpacityToAllMeshes(eff);
    }

    // ===== 2D Toggle / Transição =====
    let flatten2D = 0;
    const cards2d = document.getElementById('cards2d');

    function cacheBaseVisualsIfNeeded(){
      if (!torre || torre.userData.__dogeBaseCached) return;
      torre.userData.__dogeBaseCached = true;
      torre.userData.__baseScale = torre.scale.clone();

      torre.traverse(n=>{
        if (!n.material) return;
        if (n.isMesh && typeof n.userData.__baseOpacityMesh === 'undefined') {
          n.userData.__baseOpacityMesh =
            (typeof n.material.opacity === 'number') ? n.material.opacity : 1.0;
        }
        if ((n.isLine || n.isLineSegments) && typeof n.userData.__baseOpacityLine === 'undefined') {
          n.userData.__baseOpacityLine =
            (typeof n.material.opacity === 'number') ? n.material.opacity : 0.95;
        }
      });
    }

    function apply2DTransition(){
      if (!torre) return;
      cacheBaseVisualsIfNeeded();

      if (!__aptRoots || __aptRoots.length === 0) collectApartmentRoots();
      if (!__gridModel) prepareGridModel();
      if (!__cardsBuilt) build2DCards();

      const t = flatten2D;

      // 1) Escala
      const baseScale = torre.userData.__baseScale || new THREE.Vector3(1,1,1);
      const s = THREE.MathUtils.lerp(1.0, 0.50, t);
      torre.scale.set(baseScale.x * s, baseScale.y * s, baseScale.z * s);

      // 2) Opacidade unificada (sem disputar com slider)
      const eff = computeEffectiveOpacity(faceOpacity, t);
      applyOpacityToAllMeshes(eff);
      applyEdgesFade(t);

      // 3) Overlay 2D
      render2DCardsToScreen(t);

      // 4) Eventos
      if (renderer && renderer.domElement) {
        renderer.domElement.style.pointerEvents = (t >= 0.95) ? 'none' : 'auto';
      }
    }

    const btn2D = document.getElementById('btn2D');
    function update2DButtonVisual(){
      if (!btn2D) return;
      btn2D.classList.toggle('active', flatten2D >= 0.999);
    }

    function tweenFlatten2D(target, ms=280){
      const from = flatten2D;
      const to   = Math.max(0, Math.min(1, target));
      if (Math.abs(from - to) < 1e-4){ update2DButtonVisual(); return; }

      const start = performance.now();
      function step(now){
        const k = Math.min(1, (now - start) / ms);
        const eased = k < 0.5 ? 2*k*k : 1 - Math.pow(-2*k + 2, 2)/2;
        flatten2D = from + (to - from) * eased;
        apply2DTransition();

        if (k < 1) {
          requestAnimationFrame(step);
        } else {
          flatten2D = to;
          apply2DTransition();
          update2DButtonVisual();

          // Se voltou ao 3D, não precisamos reescrever opacidades manualmente;
          // computeEffectiveOpacity já resolve com t=0.
        }
      }
      requestAnimationFrame(step);
    }

    if (btn2D){
      btn2D.addEventListener('click', ()=>{
        const going2D = flatten2D < 0.5;
        tweenFlatten2D(going2D ? 1 : 0);
      });
    }
    update2DButtonVisual();

    // Reset geral (explode + sair do 2D + opacidade consistente)
    const resetBtn = document.getElementById('resetExplode');
    if (resetBtn){
      resetBtn.addEventListener('click', ()=>{
        // 1) explode volta ao zero
        explodeXY = 0; explodeY = 0;
        const elExplodeXY = document.getElementById('explodeXY');
        const elExplodeY  = document.getElementById('explodeY');
        if (elExplodeXY) elExplodeXY.value = '0';
        if (elExplodeY)  elExplodeY.value  = '0';
        if (typeof applyExplode === 'function') applyExplode();

        // 2) sai do 2D com animação curta
        tweenFlatten2D(0, 220);

        // 3) restaura escala e re-aplica opacidade via helpers
        if (torre && torre.userData.__baseScale){
          torre.scale.copy(torre.userData.__baseScale);
        }
        const eff = computeEffectiveOpacity(faceOpacity, 0);
        applyOpacityToAllMeshes(eff);
        applyEdgesFade(0);
        delete torre.userData.__dogeBaseCached;

        // 4) oculta overlay 2D
        if (cards2d){
          cards2d.style.opacity = '0';
          cards2d.style.pointerEvents = 'none';
        }
        // 5) canvas 3D volta a receber eventos
        if (renderer && renderer.domElement) {
          renderer.domElement.style.pointerEvents = 'auto';
        }
        // 6) botão
        update2DButtonVisual();
      });
    }

    // Inicializa opacidade conforme slider
    setFaceOpacity(Number(opacity.value)/100);
    setFacesVisible(true);
    // ================== [DOGE] Globais da grade 2D ==================
    let __aptRoots   = [];
    let __gridModel  = null;
    let __cardsBuilt = false;
// Garante coleta de aptos/cards já construídos antes do 1º refresh
if (!__aptRoots || __aptRoots.length === 0) collectApartmentRoots();
if (!__gridModel) prepareGridModel();
if (!__cardsBuilt) build2DCards();

// Aplica FVS padrão (ou primeira do dropdown)
applyFVSAndRefresh();

// Se veio ?apt=301 na URL, abre o modal quando tudo já estiver pronto
if (QS_APT){
  // aguarda um microtask para garantir que recolor/refresh aplicou
  setTimeout(()=>{
    openAptModal({ id: QS_APT, floor: null });
  }, 0);
}

// Sempre manter URL coerente com o estado atual (primeiro load)
setQS({
  fvs: CURRENT_FVS || null,
  nc : NC_MODE ? '1' : null,
  apt: null // não manter apt aberto na URL por padrão (se quiser, remova esta linha)
});
savePrefs();


    // Coleta de apartamentos
    function collectApartmentRoots(){
      __aptRoots = [];
      if (!torre) return;

      const seen = new Set();
      torre.updateMatrixWorld(true);

      const candidates = [];
      torre.traverse(n=>{
        if (n.type === 'Group' && typeof n.userData.levelIndex === 'number') candidates.push(n);
      });
      if (candidates.length === 0){
        for (const child of torre.children){
          if (child.isGroup) candidates.push(child);
        }
      }

      for (const root of candidates){
        if (seen.has(root.id)) continue;
        seen.add(root.id);

        const meta = root.userData.meta || (root.userData.meta = {});
        if (meta.floor == null){
          meta.floor = (typeof root.userData.levelIndex === 'number') ? root.userData.levelIndex : 0;
        }

        const ax = (root.userData.anchor && typeof root.userData.anchor.x === 'number')
                    ? root.userData.anchor.x : 0;
        meta.__anchorX = ax;

        if (!meta.id && root.userData.nome) meta.id = String(root.userData.nome);
        if (!meta.name) meta.name = meta.id || `apt-${root.id}`;

        if (!root.userData._base){
          root.userData._base = {
            pos: root.position.clone(),
            rot: root.rotation.clone(),
            scale: root.scale.clone()
          };
        }

        __aptRoots.push({ root, meta, base: root.userData._base });
      }
    }

    // Modelo da grade + cards
    function colorFor(meta){
      if (meta && meta.status && window.COLOR_MAP?.colors?.[meta.status]) return window.COLOR_MAP.colors[meta.status];
      if (meta && meta.color) return meta.color;
      return '#6e7681';
    }

    function prepareGridModel(){
      if (!__aptRoots || !__aptRoots.length) return;

      const hasOrdem = __aptRoots.some(A => Number.isFinite(Number(A.meta?.ordemcol)));
      if (hasOrdem){
        for (const A of __aptRoots){
          const col1 = Number(A.meta?.ordemcol);
          A.meta.__colIdx = Number.isFinite(col1) ? Math.max(0, Math.floor(col1 - 1)) : 0;
        }
      } else {
        const xs = __aptRoots.map(A => (typeof A.meta?.__anchorX === 'number') ? A.meta.__anchorX : 0);
        xs.sort((a,b)=>a-b);
        const COL_EPS = 0.001;
        const groups = [];
        for (const x of xs){
          const g = groups[groups.length-1];
          if (!g || Math.abs(x - g.center) > COL_EPS){
            groups.push({ center:x, values:[x] });
          } else {
            g.values.push(x);
            g.center = g.values.reduce((s,v)=>s+v,0)/g.values.length;
          }
        }
        function colIndexFor(x){
          if (groups.length === 0) return 0;
          let best = 0, bestD = Math.abs(x - groups[0].center);
          for (let i=1;i<groups.length;i++){
            const d = Math.abs(x - groups[i].center);
            if (d < bestD){ bestD = d; best = i; }
          }
          return best;
        }
        for (const A of __aptRoots){
          const x = (typeof A.meta?.__anchorX === 'number') ? A.meta.__anchorX : 0;
          A.meta.__colIdx = colIndexFor(x);
        }
      }

      const floors = new Set();
      const cols   = new Set();
      const map    = new Map();
      for (const A of __aptRoots){
        const f = Number(A.meta?.floor)   || 0;
        const c = Number(A.meta?.__colIdx)|| 0;
        floors.add(f); cols.add(c);
        const k = `${f}|${c}`;
        if (!map.has(k)) map.set(k, []);
        map.get(k).push(A);
      }

      const floorsArr = Array.from(floors).sort((a,b)=>b-a);
      const colsArr   = Array.from(cols).sort((a,b)=>a-b);

      for (const arr of map.values()){
        arr.sort((a,b)=>{
          const za = Number(a.meta?.zIndex || a.meta?.z || 0) || 0;
          const zb = Number(b.meta?.zIndex || b.meta?.z || 0) || 0;
          return za - zb;
        });
      }

      __gridModel = { floors: floorsArr, cols: colsArr, map };
    }

function build2DCards(){
  if (!__aptRoots || !__aptRoots.length) return;
  if (!__gridModel) prepareGridModel();
  if (!__gridModel) return;

  cards2d.innerHTML = '';

  for (const A of __aptRoots){
    const el = document.createElement('div');
    el.className  = 'card';
    const idStr = A.meta?.id || A.meta?.name || A.root.userData.nome || '';
    el.dataset.id = idStr;

    // cor pela FVS (igual ao 3D)
    const piso = (A.meta?.floor ?? A.root.userData.levelIndex ?? 0);
    el.style.background = pickFVSColor(idStr, piso);

    // ===== NOVO: conteúdo interno do card
    // número do apto (visível só no hover) + duração (padrão)
    const aptLabel = String(A.meta?.name || A.meta?.id || A.root.userData.nome || 'apt');

    const numEl = document.createElement('div');
    numEl.className = 'num';
    numEl.textContent = aptLabel;
    el.appendChild(numEl);

    const durEl = document.createElement('div');
    durEl.className = 'dur';
    // preenchimento inicial simples (refreshCardsWithMeta fará o update oficial)
    try {
      const key = normAptoKey(aptLabel);
      const info = META_MAP?.get ? META_MAP.get(key) : null;
      if (!NC_MODE && info?.duracao != null) {
        durEl.textContent = `${info.duracao}`;
      } else {
        durEl.style.display = 'none';
      }
    } catch(_) { /* noop */ }
    el.appendChild(durEl);

    // guarda refs para updates posteriores
    A.root.userData._cardEl = el;
    A.root.userData._numEl  = numEl;
    A.root.userData._durEl  = durEl;

    // ===== Ações
    el.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      const aptId = String(A.meta?.id || A.meta?.name || '').trim();
      let hex = null;
      try {
        const c = (A.root?.userData?.mesh?.material?.color);
        if (c) hex = '#' + c.getHexString();
      } catch(_) {}

      if (LEGACY_IFRAME){
        try { parent.postMessage({ type: 'viewer:open-apt', apt: aptId, color: hex }, '*'); } catch(_) {}
      }
      openAptModal({ id: aptId, floor: (A.meta?.floor ?? A.root.userData.levelIndex ?? null) });
    });

    // Hover: tooltip com apto + duração (quando NC desligado)
    el.addEventListener('pointerenter', (ev)=>{
      const aptId = String(A.meta?.id || A.meta?.name || A.root.userData.nome || '').trim();
      const key = normAptoKey(aptId);
      const info = META_MAP.get ? META_MAP.get(key) : null;
      const dur = (!NC_MODE && info?.duracao != null) ? ` • ${info.duracao}` : '';
      showTip(ev.clientX, ev.clientY, aptId + dur);
    }, { passive: true });

    el.addEventListener('pointermove', (ev)=>{
      if (!tipVisible) return;
      showTip(ev.clientX, ev.clientY, tipEl.textContent);
    }, { passive: true });

    el.addEventListener('pointerleave', ()=> hideTip(0), { passive: true });

    cards2d.appendChild(el);
  }

  __cardsBuilt = true;
}

    function getDurationForCard(info){
  // Heurística: duracao_real > (duracao_inicial + duracao_reaberturas) > duracao_inicial
  if (!info) return null;
  const real = info?.duracao;
  if (real != null) return `${real}`;
  const ini  = Number(info?.raw?.duracao_inicial ?? NaN);
  const reab = Number(info?.raw?.duracao_reaberturas ?? NaN);
  if (!Number.isNaN(ini) && !Number.isNaN(reab)) return `${ini + reab}`;
  if (!Number.isNaN(ini)) return `${ini}`;
  return null;
}
function refreshCardsWithMeta(){
  if (!__aptRoots || !__aptRoots.length) return;

  for (const A of __aptRoots){
    const el   = A.root.userData?._cardEl;
    const num  = A.root.userData?._numEl;
    const dur  = A.root.userData?._durEl;
    if (!el || !num || !dur) continue;

    // chave
    const aptId = String(A.meta?.id || A.meta?.name || A.root.userData.nome || '').trim();
    const key   = normAptoKey(aptId);
    const info  = META_MAP.get(key) || null;

    // número do apto (mostrado no hover)
    num.textContent = aptId || 'apt';

    // duração (padrão) — some se NC_MODE
    if (NC_MODE){
      dur.textContent = '';
      dur.style.display = 'none';
    } else {
      const d = getDurationForCard(info);
      if (d){
        dur.textContent = d;
        dur.style.display = '';
      } else {
        dur.textContent = '';
        dur.style.display = 'none';
      }
    }
  }
}

    function layout2D_computeMetrics(){
      const pad = 16;
      const W = window.innerWidth, H = window.innerHeight;
      const usableW = Math.max(320, W - pad*2);
      const usableH = Math.max(260, H - pad*2);

      const floorsCount = (__gridModel?.floors?.length || 1);
      const colsCount   = (__gridModel?.cols?.length   || 1);

      const CARD_RATIO = 120/72;
      const MIN_H = 40, MAX_H = 120;
      const V_GAP_MIN = 6, V_GAP_MAX = 14;
      const H_GAP_MIN = 10, H_GAP_MAX = 22;

      let cardH = Math.min(MAX_H, Math.floor(usableH / Math.max(1, floorsCount*0.9)));
      cardH = Math.max(MIN_H, cardH);
      let vGap = Math.min(V_GAP_MAX, Math.max(V_GAP_MIN, Math.floor(cardH*0.12)));

      const totalH = (h, gap) => floorsCount*h + Math.max(0, floorsCount-1)*gap;
      while (totalH(cardH, vGap) > usableH && cardH > MIN_H) cardH -= 1;
      while (totalH(cardH, vGap) > usableH && vGap  > V_GAP_MIN) vGap -= 1;

      const cardW = Math.floor(cardH * CARD_RATIO);
      let hGap = Math.min(H_GAP_MAX, Math.max(H_GAP_MIN, Math.floor(cardW*0.15)));

      const totalW = colsCount*cardW + Math.max(0, colsCount-1)*hGap;
      const originX = Math.floor((W - totalW)/2) + Math.floor(cardW/2);
      const totalHpx = totalH(cardH, vGap);
      const originY = Math.floor((H - totalHpx)/2) + Math.floor(cardH/2);

      return { cardW, cardH, vGap, hGap, originX, originY, floorsCount, colsCount };
    }

    function render2DCardsToScreen(tFade){
      if (!__gridModel) prepareGridModel();
      if (!__gridModel) return;
      if (!__cardsBuilt) build2DCards();

      const { floors, cols, map } = __gridModel;
      const rows    = floors.length;
      const colsLen = cols.length;
      if (!rows || !colsLen) return;

      const hud = document.getElementById('hud');
      const hudH = hud ? hud.offsetHeight : 0;

      const pane = cards2d;
      pane.style.position      = 'fixed';
      pane.style.top           = '0';
      pane.style.left          = '0';
      pane.style.right         = '0';
      pane.style.setProperty('bottom', `${hudH}px`, 'important');
      pane.style.opacity       = String(tFade);
      pane.style.pointerEvents = (tFade > 0) ? 'auto' : 'none';
      pane.style.display       = (tFade > 0 ? 'block' : 'none');
      pane.style.overflowY     = 'hidden';

      // força reflow
      pane.offsetHeight;
      const availW = Math.max(240, pane.clientWidth);
      const availH = Math.max(180, pane.clientHeight);

      const slotsPerFloor = floors.map(f=>{
        let m = 1;
        for (let i=0;i<colsLen;i++){
          const arr = map.get(`${f}|${cols[i]}`) || [];
          if (arr.length > m) m = arr.length;
        }
        return m;
      });
      const sumSlots = slotsPerFloor.reduce((s,v)=>s+v,0);

      const RATIO = 120/72;
      const MIN_W=44, MIN_H=18, MIN_FONT=8;

      let hGap = Math.max(8, Math.floor(availW * 0.012));
      let vGap = Math.max(6, Math.floor(availH * 0.012));

      let cardH = Math.floor((availH - Math.max(0, rows-1)*vGap) / Math.max(1, sumSlots));
      cardH = Math.max(MIN_H, cardH);
      let cardW = Math.max(MIN_W, Math.floor(cardH * RATIO));
        // >>> gap vertical ENTRE cards empilhados na MESMA coluna/piso
  let cardGapY = Math.max(6, Math.floor(cardH * 0.12)); // ~12% da altura do card

      const totalW = () => colsLen*cardW + Math.max(0, colsLen-1)*hGap;
      
       // Altura total agora considera o gap entre cards empilhados
  const totalH = () => {
    let H = 0;
    for (let r=0; r<rows; r++){
      const slots = slotsPerFloor[r];
      const bandH = slots*cardH + Math.max(0, slots-1)*cardGapY;
      H += bandH + (r < rows-1 ? vGap : 0);
    }
    return H;
  };
  

      let TW = totalW(), TH = totalH();
      if (TW > availW){
        const sx = availW / TW;
        cardW = Math.max(MIN_W, Math.floor(cardW * sx));
        hGap  = Math.max(6, Math.floor(hGap  * sx));
        TW = totalW(); TH = totalH();
      }

  // se estourar na altura, tenta reduzir gaps/altura
  let useScroll = false, guard = 400;
  while (TH > availH && guard-- > 0){
    if (vGap > 2) vGap -= 1;
    else if (cardGapY > 2) cardGapY -= 1;
    else if (cardH > MIN_H) cardH -= 1;
    else { useScroll = true; break; }
    TW = totalW(); TH = totalH();
  }
  pane.style.overflowY = useScroll ? 'auto' : 'hidden';

      const originX = Math.floor(availW/2);
      const padTop = 8;
      const originY = useScroll
        ? (padTop + Math.floor(cardH/2))
        : (Math.floor(availH/2 - TH/2) + Math.floor(cardH/2));

      const fontPx = Math.max(MIN_FONT, Math.round(Math.min(cardW, cardH) * 0.18));
      for (const A of __aptRoots){
        const el = A.root.userData?._cardEl;
        if (!el) continue;
        el.style.width     = `${cardW}px`;
        el.style.height    = `${cardH}px`;
        el.style.fontSize  = `${fontPx}px`;
        el.style.opacity   = String(0.15 + 0.85*tFade);
      }

let cursorY = useScroll ? (originY - Math.floor(cardH/2)) : (originY - TH/2);

for (let r = 0; r < rows; r++) {
  const f = floors[r];

  // altura da faixa do piso r (com gap entre cards empilhados)
  const slotsR = slotsPerFloor[r];
  const bandH  = slotsR * cardH + Math.max(0, slotsR - 1) * cardGapY;
  const rowCenterY = cursorY + bandH / 2;

  for (let cx = 0; cx < colsLen; cx++) {
    const key  = `${f}|${cols[cx]}`;
    const arr  = map.get(key) || [];
    const slots = Math.max(1, arr.length);

    const colCenterX = originX - (TW / 2) + cx * (cardW + hGap) + cardW / 2;
    const topBand = rowCenterY - (bandH / 2); // topo da banda do piso

    for (let k = 0; k < arr.length; k++) {
      const A  = arr[k];
      const el = A.root.userData?._cardEl;
      if (!el) continue;

      const x = colCenterX;
      // cada card desce cardH + cardGapY
      const y = topBand + k * (cardH + cardGapY) + cardH / 2;

      el.style.left = `${x}px`;
      el.style.top  = `${y}px`;
    }
  }

  cursorY += bandH + (r < rows - 1 ? vGap : 0);
}


      if (useScroll) pane.scrollTop = 0;
    }

    (function watchHudAndRerender(){
      let lastHudH = -1;
      function tick(){
        const hud = document.getElementById('hud');
        const h = hud ? hud.offsetHeight : 0;
        if (flatten2D > 0 && h !== lastHudH){
          lastHudH = h;
          render2DCardsToScreen(flatten2D);
        }
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();

    function hide2DCards(){
      cards2d.style.opacity = '0';
      cards2d.style.pointerEvents = 'none';
    }

    // ===== Cores herdadas do 2D =====

    function doge_openDetails(aptoId, floorIdx){
      try {
        parent.postMessage({
          type: 'open-fvs-modal',
          payload: {
            aptoId: String(aptoId ?? ''),
            floorIdx: Number.isFinite(floorIdx) ? Number(floorIdx) : null
          }
        }, '*');
      } catch (_) {}

      if (typeof window.openAptModal === 'function') {
        window.openAptModal({ id: String(aptoId ?? ''), floor: floorIdx });
      }
    }

    
    function doge_decideAndOpen(aptoId, floorIdx){
      const idNorm = (aptoId != null) ? String(aptoId) : '';
      const hasApt = !!(COLOR_MAP.colors[idNorm] || COLOR_MAP.colors[normApto(idNorm)]);
      const hasFloor = !!COLOR_MAP.byFloor?.[String(floorIdx)];
      if (hasApt) {
        doge_openDetails(idNorm, null);
      } else if (hasFloor) {
        doge_openDetails(null, floorIdx);
      } else {
        doge_openDetails(idNorm, floorIdx);
      }
    }

    function normApto(s){
      if (s == null) return '';
      let t = String(s).trim().toUpperCase();
      t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
      t = t.replace(/[\s\-\._\/]/g, '');
      return t;
    }

    function pickFVSColor(aptoId, floorIdx){
      const hexA = COLOR_MAP.colors[aptoId] || COLOR_MAP.colors[normApto(aptoId)];
      if (hexA && /^#?[0-9a-f]{6}$/i.test(hexA)) return hexA.startsWith('#') ? hexA : '#'+hexA;

      const hexF = COLOR_MAP.byFloor[String(floorIdx)];
      if (hexF && /^#?[0-9a-f]{6}$/i.test(hexF)) return hexF.startsWith('#') ? hexF : '#'+hexF;

      const defHex = COLOR_MAP.default || '#6e7681';
      return defHex.startsWith('#') ? defHex : '#'+defHex;
    }

    // Recolor (ajustada para não disputar opacidade)
    function recolorMeshes3D(){
      if (!torre) return;
      for (const g of torre.children){
        const nome  = g.userData.nome || g.userData.meta?.id || '';
        const floor = g.userData.levelIndex ?? 0;
        const hex   = pickFVSColor(nome, floor);

        const mat = g.userData.mesh.material;
        mat.color = new THREE.Color(hex);
        mat.needsUpdate = true;
      }
      // Reaplica opacidade efetiva após recolorir
      const eff = computeEffectiveOpacity(faceOpacity, flatten2D || 0);
      applyOpacityToAllMeshes(eff);
    }

    function recolorCards2D(){
      if (!__aptRoots || !__aptRoots.length) return;
      for (const A of __aptRoots){
        const el = A.root.userData?._cardEl;
        if (!el) continue;
        const id   = A.meta?.id || A.meta?.name || A.root.userData.nome || '';
        const piso = (A.meta?.floor ?? A.root.userData.levelIndex ?? 0);
        el.style.background = pickFVSColor(id, piso);
      }
    }

    function setFVSColorMap(payload){
      if (!payload) return;
      COLOR_MAP = {
        default: payload.default || '#6e7681',
        colors:  payload.colors  || {},
        byFloor: payload.byFloor || {}
      };
      recolorMeshes3D();
      recolorCards2D();
    }
    

    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      updateCamera();

      if (typeof flatten2D !== 'undefined' && flatten2D > 0 && typeof render2DCardsToScreen === 'function') {
        render2DCardsToScreen(flatten2D);
      }
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>