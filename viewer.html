<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Pr√©dio 3D ‚Äî viewer (cores herdadas da FVS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body { height: 100%; margin: 0; }
  body { background: #0d1117; color: #c9d1d9; font-family: system-ui, sans-serif; }
  #app { position: fixed; inset: 0; }
  canvas { display:block; }

  /* === HUD (desktop por padr√£o) === */
  #hud {
    position: fixed; left: 12px; top: 12px; padding: 10px 12px;
    background: rgba(0,0,0,.45); backdrop-filter: blur(6px);
    border: 1px solid #30363d; border-radius: 10px; font-size: 14px; z-index: 10;
    display: grid; gap: 8px; width: max-content;
    transition: transform .25s ease;
  }
  #hud .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  .val { width: 3.6rem; text-align: right; display: inline-block; }
  button, label { user-select: none; }

  /* Al√ßa (handle) e bot√£o de toggle */
  #hud .handle { display:flex; align-items:center; gap:8px; cursor:grab; user-select:none; }
  #hud .grabber {
    width: 44px; height: 6px; border-radius: 4px;
    background: #58606b; opacity: .85;
    margin-right: 4px;
  }
  #hudToggle {
    border: 1px solid #30363d;
    background: #0d1117;
    color: #c9d1d9;
    border-radius: 8px;
    padding: 4px 8px;
    font-size: 13px;
    line-height: 1;
  }

  /* Estado recolhido (no mobile vira bottom sheet; no desktop, opcional) */
  #hud.collapsed { transform: translateY(0); } /* neutro no desktop */

  /* === Mobile: HUD como bottom sheet === */
  @media (max-width: 640px) {
    #hud {
      left: 0; right: 0; top: auto; bottom: 0;
      margin: 0 8px 8px;
      width: auto;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      max-height: 65vh;
      overflow: auto;
      transform: translateY(0); /* expandido */
    }
    /* No mobile, recolhido = s√≥ a ‚Äúal√ßa‚Äù vis√≠vel (~40px) */
    #hud.collapsed {
      transform: translateY(calc(100% - 40px));
    }
  }

  /* Respeita usu√°rios com movimento reduzido */
  @media (prefers-reduced-motion: reduce) {
    #hud { transition: none; }
  }

/* O canvas deve receber todos os gestos (sem scroll/browser gestures) */
canvas { touch-action: none; }

/* O HUD pode rolar verticalmente, mas a al√ßa n√£o */
#hud { touch-action: pan-y; }
#hudHandle { touch-action: none; } /* nossa al√ßa (grip) */
</style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div class="row handle" id="hudHandle">
    <div class="grabber" aria-hidden="true"></div>
    <span style="font-weight:600; flex:1;">Controles</span>
    <button id="hudToggle" aria-expanded="true" title="Recolher/Expandir">‚ñæ</button>
    </div>
    <div class="row" id="dragHint">
      <b>Arraste</b> (esq = orbitar, dir = mover) ‚Ä¢ <b>Scroll</b> = zoom
    </div>
    <div class="row">
      <label><input id="wireOnly" type="checkbox" /> S√≥ arame</label>
      <button id="resetRot">üîÑ Resetar giro</button>
      <button id="recenter">üéØ Centralizar c√¢mera</button>
    </div>
    <div class="row">
      Opacidade: <input id="opacity" type="range" min="5" max="100" value="30" />
      <span id="opacityVal" class="val">0.30</span>
    </div>
    <div class="row">
      Explodir XY: <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
      <span id="explodeXYVal" class="val">0.00</span>
    </div>
    <div class="row">
      Explodir Y (piso): <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
      <span id="explodeYVal" class="val">0.00</span>
      <button id="resetExplode">Reset</button>
    </div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ====== Carrega o layout do repo ======
    const LAYOUT_URL = './data/layout-3d.json';
    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // ====== Setup ======
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== √ìrbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();


// ===== √ìrbita + Pan (Pointer Events unificados) =====
let dragging = false, dragMode = 'orbit', lastX = 0, lastY = 0, activePointerId = null;

function pointerDown3D(e){
  // Bot√£o direito = pan, sen√£o orbit. Em toque, default = orbit.
  const isRight = (e.button === 2);
  dragMode = isRight ? 'pan' : 'orbit';

  activePointerId = e.pointerId;
  dragging = true;
  lastX = e.clientX; lastY = e.clientY;

  // Captura e bloqueia gesto do navegador (scroll/zoom)
  renderer.domElement.setPointerCapture(activePointerId);
  e.preventDefault();
}

function pointerMove3D(e){
  if (!dragging || e.pointerId !== activePointerId) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  lastX = e.clientX; lastY = e.clientY;

  if (dragMode === 'orbit') {
    pivot.rotation.y += dx * 0.005;
    theta = pivot.rotation.y;
    phi -= dy * 0.005; phi = clamp(phi, minPhi, maxPhi);
    updateCamera();
  } else {
    const panScale = radius * 0.0025;
    const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
    const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
    const upv     = new THREE.Vector3().copy(camera.up).normalize();
    orbitTarget.addScaledVector(right, -dx * panScale);
    orbitTarget.addScaledVector(upv,    dy * panScale);
    updateCamera();
  }
  e.preventDefault();
}

function pointerUp3D(e){
  if (e.pointerId !== activePointerId) return;
  dragging = false;
  try { renderer.domElement.releasePointerCapture(activePointerId); } catch(_){}
  activePointerId = null;
  e.preventDefault();
}

renderer.domElement.addEventListener('pointerdown', pointerDown3D, {passive:false});
renderer.domElement.addEventListener('pointermove', pointerMove3D,   {passive:false});
renderer.domElement.addEventListener('pointerup',   pointerUp3D,     {passive:false});
renderer.domElement.addEventListener('pointercancel', pointerUp3D,   {passive:false});

// bloqueia menu do bot√£o direito (para pan no desktop)
renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

// Zoom: mant√©m wheel como estava
renderer.domElement.addEventListener('wheel', e=>{
  e.preventDefault();
  const f = 1 + (e.deltaY>0 ? 0.1 : -0.1);
  radius = clamp(radius*f, minRadius, maxRadius);
  updateCamera();
}, {passive:false});
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Touch (1 dedo = orbitar)
    renderer.domElement.addEventListener('touchstart',e=>{
      if(e.touches.length===1){
        dragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; dragMode='orbit';
      }
    },{passive:true});
    renderer.domElement.addEventListener('touchmove',e=>{
      if(e.touches.length===1){
        onMoveMouse({ clientX:e.touches[0].clientX, clientY:e.touches[0].clientY });
      }
    },{passive:true});
    window.addEventListener('touchend',()=>{ dragging=false; });

    // Zoom
    renderer.domElement.addEventListener('wheel',e=>{
      e.preventDefault();
      const f=1+(e.deltaY>0?0.1:-0.1);
      radius=clamp(radius*f,minRadius,maxRadius);
      updateCamera();
    },{passive:false});

    // ====== Materiais com polygonOffset (linhas limpas, sem z-fighting) ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX = 0x6e7681;
    const MAT = {
      face: ()=> new THREE.MeshStandardMaterial({
        color: NEUTRAL_HEX,
        metalness: 0.05,
        roughness: 0.9,
        transparent: true,
        opacity: faceOpacity,
        depthWrite: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      }),
      line: new THREE.LineBasicMaterial({
        color: 0xcad7ff,
        linewidth: 1,
        depthTest: true,
        depthWrite: false,
        transparent: true,
        opacity: 0.95
      }),
      selLine: new THREE.LineBasicMaterial({
        color: 0xffc107,
        linewidth: 2
      })
    };

    function setFacesVisible(visible){
      for (const g of torre.children) g.userData.mesh.visible = visible;
    }
    
function setFaceOpacity(op){
  faceOpacity = op;
  for (const g of torre.children){
    const m = g.userData.mesh.material;
    m.opacity = faceOpacity;

    if (faceOpacity >= 0.999) {
      m.transparent = false;
      m.depthWrite = true;
      m.opacity = 1.0; // garante s√≥lido
    } else {
      m.transparent = true;
      m.depthWrite = false;
    }
    m.needsUpdate = true;
  }
}

    // ===== Dimens√£o b√°sica em "mundo" =====
    const cellW = (layout.meta?.cellW ?? 1.2);
    const cellD = (layout.meta?.cellD ?? 1.2);
    const gap   = (layout.meta?.gap   ?? 0.15);

    const aptoHeight = 0.5;          // altura "unit√°ria" por n√≠vel
    const stepX = cellW + gap;
    const stepZ = cellD + gap;
    const stepY = aptoHeight + gap;

    function rectCenterX(x, w){ return x*stepX + (w*cellW + (w-1)*gap)/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*cellD + (d-1)*gap)/2; }

    // ===== Explodir =====
// ===== Explode (√∫nica fonte de verdade) =====
let explodeXY = 0.0;
let explodeY  = 0.0;

// aplica explode atual √†s posi√ß√µes dos grupos
function applyExplode(){
  if (!torre || torre.children.length === 0) return;

  // Se ambos zero ‚Üí volta para as posi√ß√µes coladas
  if ((explodeXY === 0 || !Number.isFinite(explodeXY)) &&
      (explodeY  === 0 || !Number.isFinite(explodeY))) {
    for (const g of torre.children) g.position.copy(g.userData.basePos);
    return;
  }

  // Centroide dos ANCHORS (n√£o das basePos)
  let sumX = 0, sumZ = 0, n = 0;
  for (const g of torre.children){
    const a = g.userData.anchor || g.userData.basePos;
    sumX += a.x; sumZ += a.z; n++;
  }
  const cx = n ? (sumX/n) : 0;
  const cz = n ? (sumZ/n) : 0;

  const step = Math.max(stepX, stepZ) || 1;

  for (const g of torre.children){
    const base = g.userData.basePos;            // onde fica "colado"
    const pos  = base.clone();

    // Explode radial no plano XZ a partir do centroide dos anchors
    if (explodeXY > 0){
      const a = g.userData.anchor || base;
      const dir = new THREE.Vector3(a.x - cx, 0, a.z - cz);
      const len = dir.length();
      if (len > 1e-6){
        dir.multiplyScalar(1/len);              // mesmo deslocamento p/ todos
        pos.addScaledVector(dir, explodeXY * step);
        // Se quiser proporcional ao raio, troque por:
        // pos.addScaledVector(dir, explodeXY * step * (len/Math.max(1, step)));
      }
    }

    // Explode vertical por pavimento
    if (explodeY !== 0){
      pos.y += (g.userData.levelIndex || 0) * explodeY;
    }

    g.position.copy(pos);
  }
}
    // ===== Voxeliza√ß√£o por APTO =====
    function voxelizeByApto(l){
      const byApto = new Map();
      for (const p of l.placements){
        const apt = String(p.apto);
        if (!byApto.has(apt)) byApto.set(apt, new Set());
        const set = byApto.get(apt);
        const baseY = (typeof p.andar === 'number') ? p.andar : 0; // 'AT' => 0
        for (let gx = p.x; gx < p.x + p.w; gx++){
          for (let gz = p.z; gz < p.z + p.d; gz++){
            for (let gy = baseY; gy < baseY + p.h; gy++){
              set.add(`${gx},${gy},${gz}`);
            }
          }
        }
      }
      return byApto;
    }

    // ===== Meshing de fronteira (sem faces internas) =====
    function buildSurfaceGeometryFromOcc(occSet){
      if (!occSet || occSet.size===0) return null;
      const has = (x,y,z)=> occSet.has(`${x},${y},${z}`);

      const pos = [];
      const idx = [];
      let vbase = 0;

      const pushQuad = (a,b,c,d)=>{
        pos.push( ...a, ...b, ...c, ...d );
        idx.push(vbase, vbase+1, vbase+2,  vbase, vbase+2, vbase+3);
        vbase += 4;
      };

      function voxelBounds(gx,gy,gz){
        const x0 = gx * stepX, x1 = x0 + cellW;
        const z0 = gz * stepZ, z1 = z0 + cellD;
        const y0 = gy * stepY, y1 = y0 + aptoHeight;
        return {x0,x1,y0,y1,z0,z1};
      }

      for (const key of occSet){
        const [gx,gy,gz] = key.split(',').map(Number);
        const {x0,x1,y0,y1,z0,z1} = voxelBounds(gx,gy,gz);

        if (!has(gx-1,gy,gz)) pushQuad([x0,y0,z1],[x0,y0,z0],[x0,y1,z0],[x0,y1,z1]); // -X
        if (!has(gx+1,gy,gz)) pushQuad([x1,y0,z0],[x1,y0,z1],[x1,y1,z1],[x1,y1,z0]); // +X
        if (!has(gx,gy,gz-1)) pushQuad([x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]); // -Z
        if (!has(gx,gy,gz+1)) pushQuad([x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]); // +Z
        if (!has(gx,gy-1,gz)) pushQuad([x0,y0,z0],[x1,y0,z0],[x1,y0,z1],[x0,y0,z1]); // -Y
        if (!has(gx,gy+1,gz)) pushQuad([x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]); // +Y
      }

      if (pos.length===0) return null;

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
      geom.setIndex(new THREE.Uint32BufferAttribute(new Uint32Array(idx), 1));
      geom.computeVertexNormals();
      geom.computeBoundingBox(); geom.computeBoundingSphere();
      return geom;
    }

    // ===== Inflar para desenhar edges limpas =====
    function inflateGeometry(geom, offset=0.04){
      const g = geom.clone();
      g.computeVertexNormals();
      const pos = g.getAttribute('position');
      const nor = g.getAttribute('normal');
      for (let i=0;i<pos.count;i++){
        pos.setX(i, pos.getX(i) + nor.getX(i)*offset);
        pos.setY(i, pos.getY(i) + nor.getY(i)*offset);
        pos.setZ(i, pos.getZ(i) + nor.getZ(i)*offset);
      }
      pos.needsUpdate = true;
      return g;
    }

    // ====== Constru√ß√£o ======
function buildFromLayout(l){
  // limpa torre
  while (torre.children.length) torre.remove(torre.children[0]);

  // voxeliza por apartamento
  const occByApto = voxelizeByApto(l);

  for (const [apto, occ] of occByApto.entries()){
    const surface = buildSurfaceGeometryFromOcc(occ);
    if (!surface) continue;

    // material neutro (cores vir√£o do FVS; opacidade coerente)
const faceMat = new THREE.MeshStandardMaterial({
  color: new THREE.Color(0x6e7681),
  metalness: 0.05,
  roughness: 0.9,
  transparent: faceOpacity < 0.999,
  opacity: Math.min(1, faceOpacity),
  depthWrite: faceOpacity >= 0.999,
  side: THREE.DoubleSide,          // <‚Äî chave para colorir as laterais
  polygonOffset: true,
  polygonOffsetFactor: 1,
  polygonOffsetUnits: 1
});

    const mesh = new THREE.Mesh(surface, faceMat);
    mesh.renderOrder = 1;

    // contorno limpo
    const inflated = inflateGeometry(surface, 0.04);
    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(inflated, 1), MAT.line);
    edges.renderOrder = 2;

    // pavimento m√≠nimo (explodeY)
    let minLevel = Infinity;
    for (const key of occ){
      const gy = parseInt(key.split(',')[1],10);
      if (gy < minLevel) minLevel = gy;
    }
    if (!Number.isFinite(minLevel)) minLevel = 0;

    const group = new THREE.Group();
    group.add(mesh); group.add(edges);
    group.position.set(0,0,0);

    // guardaremos basePos e anchor ap√≥s centralizar tudo
    group.userData = {
      apto: String(apto),
      mesh, edges,
      levelIndex: minLevel,
      basePos: new THREE.Vector3(0,0,0),
      anchor:  new THREE.Vector3(0,0,0)
    };

    // j√° calcula o centro LOCAL da malha (em coords do geometry)
    surface.computeBoundingBox();
    const bb = surface.boundingBox;
    const localCenter = new THREE.Vector3();
    bb.getCenter(localCenter);                 // centro no espa√ßo LOCAL do mesh
    group.__localCenter = localCenter;         // usamos depois para calcular o anchor
    torre.add(group);
  }

  // === Centraliza TODO o conjunto no (0,0,0) movendo os grupos
  const bbox = new THREE.Box3().setFromObject(torre);
  const center = new THREE.Vector3(); bbox.getCenter(center);
  const size   = new THREE.Vector3(); bbox.getSize(size);

  for (const g of torre.children){
    // posi√ß√£o "colada" = antes era (0,0,0), agora deslocamos pelo centro global
    g.position.sub(center);
    // basePos = onde o grupo fica quando explode = 0
    g.userData.basePos.copy(g.position);

    // === ANCHOR: centro do apto em mundo colado
    // Como o geometry est√° em "coords globais", seu centro local (.__localCenter)
    // somado √† translation do grupo d√° o centro em "mundo colado".
    const lc = g.__localCenter || new THREE.Vector3();
    g.userData.anchor.set(
      g.position.x + lc.x,
      g.position.y + lc.y,
      g.position.z + lc.z
    );
    delete g.__localCenter; // limpeza
  }

  // === C√¢mera inicial baseada no tamanho real
  const diag = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
  const idealRadius = Math.max(8, diag * 0.75);
  radius = clamp(idealRadius, 4, 200);

  // Se quiser mirar pro meio da altura, use size.y*0.5
  orbitTarget.set(0, 0, 0);
  updateCamera();

  // Aplica estado atual do explode (zero ‚Üí colado)
  applyExplode();
}


    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }

    buildFromLayout(layout);

    // ====== Sele√ß√£o com mira refinada ======
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      // 1) faces
      const faceObjects = torre.children.map(g => g.userData.mesh);
      raycaster.setFromCamera(mouse, camera);
      let inter = raycaster.intersectObjects(faceObjects, false);

      // 2) fallback em arestas
      if (!inter.length) {
        const edgeObjects = torre.children.map(g => g.userData.edges);
        raycaster.params.Line = raycaster.params.Line || {};
        raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06;
        inter = raycaster.intersectObjects(edgeObjects, false);
      }

      // limpar sele√ß√£o anterior
      if (window.__SEL_GROUP__) {
        const gPrev = window.__SEL_GROUP__;
        gPrev.userData.edges.material = gPrev.__lineBackup;
        gPrev.userData.mesh.material = gPrev.__faceBackup;
        delete gPrev.__lineBackup; delete gPrev.__faceBackup;
        window.__SEL_GROUP__ = null;
      }

      if (inter.length) {
        const hitObj = inter[0].object;
        const selGroup = hitObj.parent;
        if (selGroup && selGroup.userData) {
          selGroup.__lineBackup = selGroup.userData.edges.material;
          selGroup.__faceBackup = selGroup.userData.mesh.material.clone();

          selGroup.userData.edges.material = MAT.selLine;

          const faceClone = selGroup.userData.mesh.material.clone();
          faceClone.opacity = Math.min(1, faceOpacity + 0.2);
          selGroup.userData.mesh.material = faceClone;

          window.__SEL_GROUP__ = selGroup;
          console.log('Selecionado:', selGroup.userData.apto);
        }
      }
    });

    // ====== UI ======
    document.getElementById('wireOnly').addEventListener('change', (e) => setFacesVisible(!e.target.checked));
// === HUD: Explode ===
// ===== HUD: recolher/expandir e gesto de deslizar =====
const hud       = document.getElementById('hud');
const hudToggle = document.getElementById('hudToggle');
const hudHandle = document.getElementById('hudHandle');

// bot√£o de toggle
hudToggle.addEventListener('click', () => {
  const collapsed = hud.classList.toggle('collapsed');
  hudToggle.textContent = collapsed ? '‚ñ¥' : '‚ñæ';
  hudToggle.setAttribute('aria-expanded', String(!collapsed));
});

// gesto simples no mobile: deslizar a al√ßa pra baixo/para cima
let touchStartY = null;
hudHandle.addEventListener('touchstart', (e) => {
  touchStartY = e.touches[0].clientY;
}, {passive:true});

hudHandle.addEventListener('touchend', (e) => {
  if (touchStartY == null) return;
  const endY = (e.changedTouches[0] || e.touches[0]).clientY;
  const dy = endY - touchStartY;
  // limiares simples: >30px desce (recolhe), < -30px sobe (expande)
  if (dy > 30) {
    hud.classList.add('collapsed');
    hudToggle.textContent = '‚ñ¥';
    hudToggle.setAttribute('aria-expanded', 'false');
  } else if (dy < -30) {
    hud.classList.remove('collapsed');
    hudToggle.textContent = '‚ñæ';
    hudToggle.setAttribute('aria-expanded', 'true');
  }
  touchStartY = null;
}, {passive:true});

// opcional: clique na al√ßa tamb√©m alterna (bom em desktop)
hudHandle.addEventListener('click', (e) => {
  // evita conflito com o bot√£o
  if (e.target === hudToggle) return;
  hudToggle.click();
});

// ===== HUD: recolher/expandir + gesto na al√ßa (Pointer Events) =====
const hud       = document.getElementById('hud');
const hudToggle = document.getElementById('hudToggle');
const hudHandle = document.getElementById('hudHandle');

hudToggle.addEventListener('click', () => {
  const collapsed = hud.classList.toggle('collapsed');
  hudToggle.textContent = collapsed ? '‚ñ¥' : '‚ñæ';
  hudToggle.setAttribute('aria-expanded', String(!collapsed));
});

// Gesto vertical simples: arrastar a al√ßa para recolher/expandir
let hudDragId = null, hudStartY = 0, hudDy = 0;
function hudPointerDown(e){
  hudDragId = e.pointerId;
  hudStartY = e.clientY; hudDy = 0;
  hudHandle.setPointerCapture(hudDragId);
  e.preventDefault(); e.stopPropagation();
}
function hudPointerMove(e){
  if (e.pointerId !== hudDragId) return;
  hudDy = e.clientY - hudStartY;
  // feedback opcional: poderia aplicar transform parcial aqui
  e.preventDefault(); e.stopPropagation();
}
function hudPointerUp(e){
  if (e.pointerId !== hudDragId) return;
  // limiares: >30px desce (recolhe), < -30px sobe (expande)
  if (hudDy > 30) {
    hud.classList.add('collapsed');
    hudToggle.textContent = '‚ñ¥';
    hudToggle.setAttribute('aria-expanded', 'false');
  } else if (hudDy < -30) {
    hud.classList.remove('collapsed');
    hudToggle.textContent = '‚ñæ';
    hudToggle.setAttribute('aria-expanded', 'true');
  }
  try { hudHandle.releasePointerCapture(hudDragId); } catch(_){}
  hudDragId = null; hudDy = 0;
  e.preventDefault(); e.stopPropagation();
}
hudHandle.addEventListener('pointerdown', hudPointerDown, {passive:false});
hudHandle.addEventListener('pointermove', hudPointerMove, {passive:false});
hudHandle.addEventListener('pointerup',   hudPointerUp,   {passive:false});
hudHandle.addEventListener('pointercancel', hudPointerUp, {passive:false});

// Clique na al√ßa alterna (bom no desktop)
hudHandle.addEventListener('click', (e) => {
  if (e.target === hudToggle) return;
  hudToggle.click();
});
const wireOnly = document.getElementById('wireOnly');
wireOnly.addEventListener('change', (e) => setFacesVisible(!e.target.checked));

const opacity = document.getElementById('opacity');
const opacityVal = document.getElementById('opacityVal');
opacity.addEventListener('input', () => {
  const v = Number(opacity.value) / 100;
  opacityVal.textContent = v.toFixed(2);
  setFaceOpacity(v);
});

const explodeXYRange = document.getElementById('explodeXY');
const explodeXYVal   = document.getElementById('explodeXYVal');
explodeXYRange.addEventListener('input', () => {
  explodeXY = Number(explodeXYRange.value) || 0;
  explodeXYVal.textContent = explodeXY.toFixed(2);
  applyExplode();
});

const explodeYRange = document.getElementById('explodeY');
const explodeYVal   = document.getElementById('explodeYVal');
explodeYRange.addEventListener('input', () => {
  explodeY = Number(explodeYRange.value) || 0;
  explodeYVal.textContent = explodeY.toFixed(2);
  applyExplode();
});

const resetExplodeBtn = document.getElementById('resetExplode');
resetExplodeBtn.addEventListener('click', () => {
  explodeXY = 0; explodeY = 0;
  explodeXYRange.value = '0'; explodeYRange.value = '0';
  explodeXYVal.textContent = '0.00'; explodeYVal.textContent = '0.00';
  applyExplode();
});

// Rota√ß√£o e recentrar
document.getElementById('resetRot').addEventListener('click', () => {
  pivot.rotation.set(0,0,0);
  theta = 0;
  updateCamera();
});
document.getElementById('recenter').addEventListener('click', () => {
  recenterOrbitTarget();
  radius = INITIAL_RADIUS; phi = INITIAL_PHI;
  updateCamera();
});

// Estado inicial
setFaceOpacity(Number(opacity.value)/100);
setFacesVisible(true);

    // ====== Cores herdadas do 2D ======
    function normApto(s){
      if (s == null) return '';
      let t = String(s).trim().toUpperCase();
      t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
      t = t.replace(/[\s\-\._\/]/g, '');
      return t;
    }
function aplicarCoresFVS(payload){
  if (!payload) return;

  // payload esperado:
  // {
  //   default: "#RRGGBB",           // opcional
  //   colors: { "301":"#...", ... },// por apartamento (normalizado ou n√£o)
  //   byFloor: { "0":"#...", "1":"#...", ... } // opcional: por pavimento (levelIndex)
  // }
  const defHex = (payload.default || '#6e7681').trim();
  const mapApto = payload.colors || {};
  const mapFloor = payload.byFloor || {};

  const pickColor = (aptoId, floorIdx) => {
    // 1) por apartamento (aceita normalizado ou original)
    const hexA = mapApto[aptoId] || mapApto[normApto(aptoId)];
    if (hexA && /^#?[0-9a-f]{6}$/i.test(hexA)) return hexA.startsWith('#') ? hexA : '#'+hexA;

    // 2) por pavimento (levelIndex)
    const hexF = mapFloor[String(floorIdx)];
    if (hexF && /^#?[0-9a-f]{6}$/i.test(hexF)) return hexF.startsWith('#') ? hexF : '#'+hexF;

    // 3) default
    return defHex.startsWith('#') ? defHex : '#'+defHex;
  };

  for (const g of torre.children){
    const apt = g.userData.apto || '';
    const floor = g.userData.levelIndex ?? 0;
    const hex = pickColor(apt, floor);

    const mat = g.userData.mesh.material;
    mat.color = new THREE.Color(hex);
    // garante estado s√≥lido/transl√∫cido coerente com a opacidade atual
    if (faceOpacity >= 0.999){
      mat.transparent = false;
      mat.depthWrite = true;
      mat.opacity = 1.0;
    } else {
      mat.transparent = true;
      mat.depthWrite = false;
      mat.opacity = faceOpacity;
    }
    mat.needsUpdate = true;
  }
}
    window.addEventListener('message', (e)=>{
      const data = e.data || {};
      if (data.type === 'fvsColorMap') {
        aplicarCoresFVS(data.payload);
      }
    });
    try { parent.postMessage({ type: 'ready-3d' }, '*'); } catch(_) {}

    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      updateCamera();
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>



